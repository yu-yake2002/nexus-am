#ifndef MATRIX_TESTS_ISA_ELETWISE_H_
#define MATRIX_TESTS_ISA_ELETWISE_H_

#include <riscv_matrix.h>

#include "utils.h"

static void test_maddu_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      22, 1,  0,  12, 17, 18, 0,  15, 20, 4,  9,  2,  6,  4,  23, 9,
      2,  21, 4,  2,  23, 2,  4,  7,  9,  11, 12, 11, 10, 12, 1,  15,
      17, 21, 1,  4,  23, 24, 13, 16, 8,  9,  18, 2,  23, 19, 6,  12,
      16, 22, 10, 4,  24, 10, 16, 0,  13, 11, 6,  24, 10, 23, 15, 11};
  const uint8_t src2[M * N] = {
      4,  23, 16, 5,  3, 17, 4, 15, 19, 20, 22, 0,  9,  5,  23, 1,
      15, 7,  16, 1,  3, 10, 1, 23, 10, 14, 20, 17, 23, 10, 23, 14,
      14, 16, 10, 19, 8, 5,  5, 21, 6,  14, 7,  6,  5,  23, 13, 10,
      16, 9,  9,  7,  9, 0,  7, 14, 15, 4,  23, 20, 11, 2,  3,  5};
  const uint8_t answ[M * N] = {
      26, 24, 16, 17, 20, 35, 4,  30, 39, 24, 31, 2,  15, 9,  46, 10,
      17, 28, 20, 3,  26, 12, 5,  30, 19, 25, 32, 28, 33, 22, 24, 29,
      31, 37, 11, 23, 31, 29, 18, 37, 14, 23, 25, 8,  28, 42, 19, 22,
      32, 31, 19, 11, 33, 10, 23, 14, 28, 15, 29, 44, 21, 25, 18, 16};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = maddu_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MADDU_MM U8");
}

static void test_maddu_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      22, 1,  0,  12, 17, 18, 0,  15, 20, 4,  9,  2,  6,  4,  23, 9,
      2,  21, 4,  2,  23, 2,  4,  7,  9,  11, 12, 11, 10, 12, 1,  15,
      17, 21, 1,  4,  23, 24, 13, 16, 8,  9,  18, 2,  23, 19, 6,  12,
      16, 22, 10, 4,  24, 10, 16, 0,  13, 11, 6,  24, 10, 23, 15, 11};
  const uint8_t src2[M * N] = {
      4,  23, 16, 5,  3, 17, 4, 15, 19, 20, 22, 0,  9,  5,  23, 1,
      15, 7,  16, 1,  3, 10, 1, 23, 10, 14, 20, 17, 23, 10, 23, 14,
      14, 16, 10, 19, 8, 5,  5, 21, 6,  14, 7,  6,  5,  23, 13, 10,
      16, 9,  9,  7,  9, 0,  7, 14, 15, 4,  23, 20, 11, 2,  3,  5};
  const uint8_t answ[M * N] = {
      26, 24, 16, 17, 20, 35, 4,  30, 39, 24, 31, 2,  15, 9,  46, 10,
      17, 28, 20, 3,  26, 12, 5,  30, 19, 25, 32, 28, 33, 22, 24, 29,
      31, 37, 11, 23, 31, 29, 18, 37, 14, 23, 25, 8,  28, 42, 19, 22,
      32, 31, 19, 11, 33, 10, 23, 14, 28, 15, 29, 44, 21, 25, 18, 16};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = maddu_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MADDU_B_MM");
}

static void test_maddu_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      2827, 3173, 4675, 2876, 5452, 4219, 1128, 3886, 5795, 5305, 4644,
      5124, 4284, 4908, 6321, 6012, 3441, 6098, 2971, 5093, 2058, 2610,
      4406, 2865, 5569, 2081, 539,  3709, 321,  4386, 3740, 1158, 1145,
      5163, 3696, 1442, 6418, 3500, 2864, 4856, 510,  3815, 4504, 3822,
      356,  2634, 3032, 2124, 4191, 2344, 5494, 4075, 6299, 1447, 3116,
      4665, 1080, 456,  5999, 234,  4404, 2717, 879,  3080};
  const uint16_t src2[M * N] = {
      5396, 2206, 567,  2906, 755,  1004, 5299, 3954, 3252, 2975, 5951,
      4493, 1550, 3118, 4638, 2258, 266,  4691, 3947, 4537, 6052, 3800,
      2502, 3396, 6432, 1730, 5479, 4977, 647,  4861, 138,  2078, 1554,
      5581, 6139, 4679, 3276, 5237, 2611, 687,  3909, 2080, 3479, 4876,
      465,  1672, 6385, 4384, 2976, 625,  2287, 341,  3668, 117,  4326,
      3377, 376,  3686, 3167, 5392, 1270, 626,  4493, 5536};
  const uint16_t answ[M * N] = {
      8223,  5379, 5242,  5782,  6207, 5223, 6427,  7840, 9047, 8280, 10595,
      9617,  5834, 8026,  10959, 8270, 3707, 10789, 6918, 9630, 8110, 6410,
      6908,  6261, 12001, 3811,  6018, 8686, 968,   9247, 3878, 3236, 2699,
      10744, 9835, 6121,  9694,  8737, 5475, 5543,  4419, 5895, 7983, 8698,
      821,   4306, 9417,  6508,  7167, 2969, 7781,  4416, 9967, 1564, 7442,
      8042,  1456, 4142,  9166,  5626, 5674, 3343,  5372, 8616};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = maddu_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MADDU_MM U16");
}

static void test_maddu_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      2827, 3173, 4675, 2876, 5452, 4219, 1128, 3886, 5795, 5305, 4644,
      5124, 4284, 4908, 6321, 6012, 3441, 6098, 2971, 5093, 2058, 2610,
      4406, 2865, 5569, 2081, 539,  3709, 321,  4386, 3740, 1158, 1145,
      5163, 3696, 1442, 6418, 3500, 2864, 4856, 510,  3815, 4504, 3822,
      356,  2634, 3032, 2124, 4191, 2344, 5494, 4075, 6299, 1447, 3116,
      4665, 1080, 456,  5999, 234,  4404, 2717, 879,  3080};
  const uint16_t src2[M * N] = {
      5396, 2206, 567,  2906, 755,  1004, 5299, 3954, 3252, 2975, 5951,
      4493, 1550, 3118, 4638, 2258, 266,  4691, 3947, 4537, 6052, 3800,
      2502, 3396, 6432, 1730, 5479, 4977, 647,  4861, 138,  2078, 1554,
      5581, 6139, 4679, 3276, 5237, 2611, 687,  3909, 2080, 3479, 4876,
      465,  1672, 6385, 4384, 2976, 625,  2287, 341,  3668, 117,  4326,
      3377, 376,  3686, 3167, 5392, 1270, 626,  4493, 5536};
  const uint16_t answ[M * N] = {
      8223,  5379, 5242,  5782,  6207, 5223, 6427,  7840, 9047, 8280, 10595,
      9617,  5834, 8026,  10959, 8270, 3707, 10789, 6918, 9630, 8110, 6410,
      6908,  6261, 12001, 3811,  6018, 8686, 968,   9247, 3878, 3236, 2699,
      10744, 9835, 6121,  9694,  8737, 5475, 5543,  4419, 5895, 7983, 8698,
      821,   4306, 9417,  6508,  7167, 2969, 7781,  4416, 9967, 1564, 7442,
      8042,  1456, 4142,  9166,  5626, 5674, 3343,  5372, 8616};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = maddu_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MADDU_H_MM");
}

static void test_maddu_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {241799244, 74296593,  228281663, 218187139,
                                222563261, 12702,     10217716,  224558958,
                                393900521, 270212516, 253666287, 231209558,
                                137664295, 418848188, 301749107, 385014842};
  const uint32_t src2[M * N] = {303670602, 328002301, 406338852, 70638117,
                                313138809, 297730609, 422807792, 41990166,
                                418183195, 348417275, 235660307, 163266814,
                                250218250, 364637698, 118964910, 397619235};
  const uint32_t answ[M * N] = {545469846, 402298894, 634620515, 288825256,
                                535702070, 297743311, 433025508, 266549124,
                                812083716, 618629791, 489326594, 394476372,
                                387882545, 783485886, 420714017, 782634077};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = maddu_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MADDU_MM U32");
}

static void test_maddu_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {241799244, 74296593,  228281663, 218187139,
                                222563261, 12702,     10217716,  224558958,
                                393900521, 270212516, 253666287, 231209558,
                                137664295, 418848188, 301749107, 385014842};
  const uint32_t src2[M * N] = {303670602, 328002301, 406338852, 70638117,
                                313138809, 297730609, 422807792, 41990166,
                                418183195, 348417275, 235660307, 163266814,
                                250218250, 364637698, 118964910, 397619235};
  const uint32_t answ[M * N] = {545469846, 402298894, 634620515, 288825256,
                                535702070, 297743311, 433025508, 266549124,
                                812083716, 618629791, 489326594, 394476372,
                                387882545, 783485886, 420714017, 782634077};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = maddu_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MADDU_W_MM");
}

static void test_maddu_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1654851041586320339, 1209968811153100014,
                                1793923472738236660, 353414726923287190};
  const uint64_t src2[M * N] = {173062791205868769, 805708308345800809,
                                1819156415836923188, 890549185150380480};
  const uint64_t answ[M * N] = {1827913832792189108, 2015677119498900823,
                                3613079888575159848, 1243963912073667670};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = maddu_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MADDU_MM U64");
}

static void test_maddu_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1654851041586320339, 1209968811153100014,
                                1793923472738236660, 353414726923287190};
  const uint64_t src2[M * N] = {173062791205868769, 805708308345800809,
                                1819156415836923188, 890549185150380480};
  const uint64_t answ[M * N] = {1827913832792189108, 2015677119498900823,
                                3613079888575159848, 1243963912073667670};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = maddu_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MADDU_DW_MM");
}

static void test_maddu_mm() {
  test_maddu_mm_u8();
  test_maddu_b_mm();
  test_maddu_mm_u16();
  test_maddu_h_mm();
  test_maddu_mm_u32();
  test_maddu_w_mm();
  test_maddu_mm_u64();
  test_maddu_dw_mm();
}

static void test_msaddu_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t src2[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t answ[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msaddu_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSADDU_MM U8");
}

static void test_msaddu_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t src2[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t answ[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msaddu_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSADDU_MM U8");
}

static void test_msaddu_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const uint16_t src2[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const uint16_t answ[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msaddu_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSADDU_MM U16");
}

static void test_msaddu_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const uint16_t src2[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const uint16_t answ[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msaddu_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSADDU_MM U16");
}

static void test_msaddu_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t src2[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t answ[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msaddu_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSADDU_MM U32");
}

static void test_msaddu_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t src2[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t answ[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msaddu_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSADDU_MM U32");
}

static void test_msaddu_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const uint64_t src2[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const uint64_t answ[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msaddu_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSADDU_MM U64");
}

static void test_msaddu_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const uint64_t src2[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const uint64_t answ[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msaddu_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSADDU_MM U64");
}

static void test_msaddu_mm() {
  test_msaddu_mm_u8();
  test_msaddu_b_mm();
  test_msaddu_mm_u16();
  test_msaddu_h_mm();
  test_msaddu_mm_u32();
  test_msaddu_w_mm();
  test_msaddu_mm_u64();
  test_msaddu_dw_mm();
}

static void test_mwaddu_mm_u8() {
  enum { M = 8, N = 8 };
  const uint8_t src1[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t src2[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint16_t answ[M * N] = {
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, N * sizeof(uint8_t));
  muint8_t ms2 = mlc_m(src2, N * sizeof(uint8_t));
  muint16_t md = mwaddu_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, u16_buffer, N * sizeof(uint16_t));
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MWADDU_MM U8");
}

static void test_mwaddu_b_mm() {
  enum { M = 8, N = 8 };
  const uint8_t src1[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t src2[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint16_t answ[M * N] = {
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,
      510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, N * sizeof(uint8_t));
  muint8_t ms2 = mlc_m(src2, N * sizeof(uint8_t));
  muint16_t md = mwaddu_b_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, u16_buffer, N * sizeof(uint16_t));
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MWADDU_MM U8");
}

static void test_mwaddu_mm_u16() {
  enum { M = 4, N = 4 };
  const uint16_t src1[M * N] = {65535, 65535, 65535, 65535, 65535, 65535,
                                65535, 65535, 65535, 65535, 65535, 65535,
                                65535, 65535, 65535, 65535};
  const uint16_t src2[M * N] = {65535, 65535, 65535, 65535, 65535, 65535,
                                65535, 65535, 65535, 65535, 65535, 65535,
                                65535, 65535, 65535, 65535};
  const uint32_t answ[M * N] = {131070, 131070, 131070, 131070, 131070, 131070,
                                131070, 131070, 131070, 131070, 131070, 131070,
                                131070, 131070, 131070, 131070};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, N * sizeof(uint16_t));
  muint16_t ms2 = mlc_m(src2, N * sizeof(uint16_t));
  muint32_t md = mwaddu_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, u16_buffer, N * sizeof(uint32_t));
  EXCEPT_U32_ARRAY_EQ(answ, u16_buffer, M * N, "MWADDU_MM U16");
}

static void test_mwaddu_h_mm() {
  enum { M = 4, N = 4 };
  const uint16_t src1[M * N] = {65535, 65535, 65535, 65535, 65535, 65535,
                                65535, 65535, 65535, 65535, 65535, 65535,
                                65535, 65535, 65535, 65535};
  const uint16_t src2[M * N] = {65535, 65535, 65535, 65535, 65535, 65535,
                                65535, 65535, 65535, 65535, 65535, 65535,
                                65535, 65535, 65535, 65535};
  const uint32_t answ[M * N] = {131070, 131070, 131070, 131070, 131070, 131070,
                                131070, 131070, 131070, 131070, 131070, 131070,
                                131070, 131070, 131070, 131070};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, N * sizeof(uint16_t));
  muint16_t ms2 = mlc_m(src2, N * sizeof(uint16_t));
  muint32_t md = mwaddu_h_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, u16_buffer, N * sizeof(uint32_t));
  EXCEPT_U32_ARRAY_EQ(answ, u16_buffer, M * N, "MWADDU_MM U16");
}

static void test_mwaddu_mm_u32() {
  enum { M = 2, N = 2 };
  const uint32_t src1[M * N] = {4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t src2[M * N] = {4294967295, 4294967295, 4294967295, 4294967295};
  const uint64_t answ[M * N] = {8589934590, 8589934590, 8589934590, 8589934590};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, N * sizeof(uint32_t));
  muint32_t ms2 = mlc_m(src2, N * sizeof(uint32_t));
  muint64_t md = mwaddu_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, u32_buffer, N * sizeof(uint64_t));
  EXCEPT_U64_ARRAY_EQ(answ, u32_buffer, M * N, "MWADDU_MM U32");
}

static void test_mwaddu_w_mm() {
  enum { M = 2, N = 2 };
  const uint32_t src1[M * N] = {4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t src2[M * N] = {4294967295, 4294967295, 4294967295, 4294967295};
  const uint64_t answ[M * N] = {8589934590, 8589934590, 8589934590, 8589934590};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, N * sizeof(uint32_t));
  muint32_t ms2 = mlc_m(src2, N * sizeof(uint32_t));
  muint64_t md = mwaddu_w_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, u32_buffer, N * sizeof(uint64_t));
  EXCEPT_U64_ARRAY_EQ(answ, u32_buffer, M * N, "MWADDU_MM U32");
}

static void test_mwaddu_mm() {
  test_mwaddu_mm_u8();
  test_mwaddu_b_mm();
  test_mwaddu_mm_u16();
  test_mwaddu_h_mm();
  test_mwaddu_mm_u32();
  test_mwaddu_w_mm();
}

static void test_madd_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      2,  8,  4,   6,   7,  -10, -11, 8,  8,  -12, -3, 10, 4,  -9,  11, 11,
      -5, -9, -12, 9,   5,  5,   -8,  1,  0,  -4,  -4, 10, 5,  8,   3,  1,
      -9, -8, 4,   -12, 10, 0,   4,   1,  -2, 9,   -1, -9, 5,  -11, 1,  5,
      -3, 11, 8,   -6,  -9, 6,   9,   11, -1, 4,   4,  5,  -1, -7,  7,  -8};
  const int8_t src2[M * N] = {
      -7, 6,   -1, -9, 1, 9,  -12, -9, 9,  -1,  7,  5,  -9,  0,  -3,  -8,
      9,  4,   -1, 4,  8, -3, 10,  4,  -1, 5,   -5, -7, -8,  -9, -9,  4,
      4,  -1,  6,  -9, 9, -3, 8,   11, -3, 6,   7,  10, -12, 2,  -10, 0,
      0,  -10, -9, -3, 6, -9, 11,  -6, 9,  -12, 2,  5,  -2,  9,  -2,  9};
  const int8_t answ[M * N] = {
      -5, 14, 3,   -3,  8,  -1, -23, -1, 17, -13, 4,  15, -5, -9, 8,  3,
      4,  -5, -13, 13,  13, 2,  2,   5,  -1, 1,   -9, 3,  -3, -1, -6, 5,
      -5, -9, 10,  -21, 19, -3, 12,  12, -5, 15,  6,  1,  -7, -9, -9, 5,
      -3, 1,  -1,  -9,  -3, -3, 20,  5,  8,  -8,  6,  10, -3, 2,  5,  1};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = madd_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MADD_MM I8");
}

static void test_madd_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      2,  8,  4,   6,   7,  -10, -11, 8,  8,  -12, -3, 10, 4,  -9,  11, 11,
      -5, -9, -12, 9,   5,  5,   -8,  1,  0,  -4,  -4, 10, 5,  8,   3,  1,
      -9, -8, 4,   -12, 10, 0,   4,   1,  -2, 9,   -1, -9, 5,  -11, 1,  5,
      -3, 11, 8,   -6,  -9, 6,   9,   11, -1, 4,   4,  5,  -1, -7,  7,  -8};
  const int8_t src2[M * N] = {
      -7, 6,   -1, -9, 1, 9,  -12, -9, 9,  -1,  7,  5,  -9,  0,  -3,  -8,
      9,  4,   -1, 4,  8, -3, 10,  4,  -1, 5,   -5, -7, -8,  -9, -9,  4,
      4,  -1,  6,  -9, 9, -3, 8,   11, -3, 6,   7,  10, -12, 2,  -10, 0,
      0,  -10, -9, -3, 6, -9, 11,  -6, 9,  -12, 2,  5,  -2,  9,  -2,  9};
  const int8_t answ[M * N] = {
      -5, 14, 3,   -3,  8,  -1, -23, -1, 17, -13, 4,  15, -5, -9, 8,  3,
      4,  -5, -13, 13,  13, 2,  2,   5,  -1, 1,   -9, 3,  -3, -1, -6, 5,
      -5, -9, 10,  -21, 19, -3, 12,  12, -5, 15,  6,  1,  -7, -9, -9, 5,
      -3, 1,  -1,  -9,  -3, -3, 20,  5,  8,  -8,  6,  10, -3, 2,  5,  1};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = madd_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MADD_B_MM");
}

static void test_madd_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -3247, 2000,  95,    -1381, -933, 385,   -547,  3025,  -200,  2769,
      245,   -1482, 584,   64,    2541, 2260,  -2389, -935,  1071,  -1682,
      329,   -84,   -55,   1537,  -178, -3189, -2827, -2955, -1522, 1522,
      1932,  1883,  -1702, 385,   2866, -1546, 2333,  -1303, 871,   1246,
      -772,  -1709, -108,  1451,  1122, 3191,  -963,  -2033, 450,   -1991,
      -1499, -2842, 1643,  -3274, -20,  2399,  1873,  1117,  -2008, 357,
      -1236, -177,  -431,  1463};
  const int16_t src2[M * N] = {
      1474,  -3071, 1789,  2780,  446,   405,   181,   1143,  -1648, 1082,
      -2666, 2050,  -3086, -1684, -1580, -486,  1660,  -2153, 982,   -3215,
      -1949, -2141, -2489, 2167,  1397,  -6,    534,   -1320, -878,  -816,
      2754,  555,   1137,  559,   -2659, 2854,  2760,  -2643, -1446, -945,
      -2120, -448,  -2996, -180,  -520,  242,   3000,  -2615, -1379, -2155,
      2047,  334,   -2486, -479,  -1412, -2610, -3245, -1229, -1853, -896,
      240,   -142,  -2870, 3001};
  const int16_t answ[M * N] = {
      -1773, -1071, 1884,  1399,  -487,  790,   -366,  4168,  -1848, 3851,
      -2421, 568,   -2502, -1620, 961,   1774,  -729,  -3088, 2053,  -4897,
      -1620, -2225, -2544, 3704,  1219,  -3195, -2293, -4275, -2400, 706,
      4686,  2438,  -565,  944,   207,   1308,  5093,  -3946, -575,  301,
      -2892, -2157, -3104, 1271,  602,   3433,  2037,  -4648, -929,  -4146,
      548,   -2508, -843,  -3753, -1432, -211,  -1372, -112,  -3861, -539,
      -996,  -319,  -3301, 4464};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = madd_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MADD_MM I16");
}

static void test_madd_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -3247, 2000,  95,    -1381, -933, 385,   -547,  3025,  -200,  2769,
      245,   -1482, 584,   64,    2541, 2260,  -2389, -935,  1071,  -1682,
      329,   -84,   -55,   1537,  -178, -3189, -2827, -2955, -1522, 1522,
      1932,  1883,  -1702, 385,   2866, -1546, 2333,  -1303, 871,   1246,
      -772,  -1709, -108,  1451,  1122, 3191,  -963,  -2033, 450,   -1991,
      -1499, -2842, 1643,  -3274, -20,  2399,  1873,  1117,  -2008, 357,
      -1236, -177,  -431,  1463};
  const int16_t src2[M * N] = {
      1474,  -3071, 1789,  2780,  446,   405,   181,   1143,  -1648, 1082,
      -2666, 2050,  -3086, -1684, -1580, -486,  1660,  -2153, 982,   -3215,
      -1949, -2141, -2489, 2167,  1397,  -6,    534,   -1320, -878,  -816,
      2754,  555,   1137,  559,   -2659, 2854,  2760,  -2643, -1446, -945,
      -2120, -448,  -2996, -180,  -520,  242,   3000,  -2615, -1379, -2155,
      2047,  334,   -2486, -479,  -1412, -2610, -3245, -1229, -1853, -896,
      240,   -142,  -2870, 3001};
  const int16_t answ[M * N] = {
      -1773, -1071, 1884,  1399,  -487,  790,   -366,  4168,  -1848, 3851,
      -2421, 568,   -2502, -1620, 961,   1774,  -729,  -3088, 2053,  -4897,
      -1620, -2225, -2544, 3704,  1219,  -3195, -2293, -4275, -2400, 706,
      4686,  2438,  -565,  944,   207,   1308,  5093,  -3946, -575,  301,
      -2892, -2157, -3104, 1271,  602,   3433,  2037,  -4648, -929,  -4146,
      548,   -2508, -843,  -3753, -1432, -211,  -1372, -112,  -3861, -539,
      -996,  -319,  -3301, 4464};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = madd_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MADD_H_MM");
}

static void test_madd_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-176282820, 135114613, -118416732, -39871586,
                               150246182,  183622204, -120187949, 67134905,
                               -139421732, 138383467, -184608783, -18547157,
                               -16151514,  7336905,   -203176109, -90036574};
  const int32_t src2[M * N] = {138698108, 91645999,   12386132,   -213616000,
                               -63979015, 213008896,  101626160,  -147429444,
                               213241270, -145245797, -131458907, 102988829,
                               -17026906, 177536224,  -93566967,  130154110};
  const int32_t answ[M * N] = {-37584712, 226760612, -106030600, -253487586,
                               86267167,  396631100, -18561789,  -80294539,
                               73819538,  -6862330,  -316067690, 84441672,
                               -33178420, 184873129, -296743076, 40117536};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = madd_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MADD_MM I32");
}

static void test_madd_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-176282820, 135114613, -118416732, -39871586,
                               150246182,  183622204, -120187949, 67134905,
                               -139421732, 138383467, -184608783, -18547157,
                               -16151514,  7336905,   -203176109, -90036574};
  const int32_t src2[M * N] = {138698108, 91645999,   12386132,   -213616000,
                               -63979015, 213008896,  101626160,  -147429444,
                               213241270, -145245797, -131458907, 102988829,
                               -17026906, 177536224,  -93566967,  130154110};
  const int32_t answ[M * N] = {-37584712, 226760612, -106030600, -253487586,
                               86267167,  396631100, -18561789,  -80294539,
                               73819538,  -6862330,  -316067690, 84441672,
                               -33178420, 184873129, -296743076, 40117536};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = madd_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MADD_W_MM");
}

static void test_madd_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {894986677683767416, -863860936474233883,
                               418880271765247332, -306426502970563119};
  const int64_t src2[M * N] = {333500496896953575, 379184521475530800,
                               -334886478300997448, -253653784772072244};
  const int64_t answ[M * N] = {1228487174580720991, -484676414998703083,
                               83993793464249884, -560080287742635363};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = madd_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MADD_MM I64");
}

static void test_madd_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {894986677683767416, -863860936474233883,
                               418880271765247332, -306426502970563119};
  const int64_t src2[M * N] = {333500496896953575, 379184521475530800,
                               -334886478300997448, -253653784772072244};
  const int64_t answ[M * N] = {1228487174580720991, -484676414998703083,
                               83993793464249884, -560080287742635363};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = madd_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MADD_DW_MM");
}

static void test_madd_mm() {
  test_madd_mm_i8();
  test_madd_b_mm();
  test_madd_mm_i16();
  test_madd_h_mm();
  test_madd_mm_i32();
  test_madd_w_mm();
  test_madd_mm_i64();
  test_madd_dw_mm();
}

static void test_msadd_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  const int8_t src2[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  const int8_t answ[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msadd_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSADD_MM I8");
}

static void test_msadd_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  const int8_t src2[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  const int8_t answ[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msadd_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSADD_B_MM");
}

static void test_msadd_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  const int16_t src2[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  const int16_t answ[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msadd_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSADD_MM I16");
}

static void test_msadd_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  const int16_t src2[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  const int16_t answ[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msadd_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSADD_MM I16");
}

static void test_msadd_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  const int32_t src2[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  const int32_t answ[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msadd_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSADD_MM I32");
}

static void test_msadd_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  const int32_t src2[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  const int32_t answ[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msadd_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSADD_MM I32");
}

static void test_msadd_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  const int64_t src2[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  const int64_t answ[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msadd_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSADD_MM I64");
}

static void test_msadd_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  const int64_t src2[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  const int64_t answ[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msadd_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSADD_MM I64");
}

static void test_msadd_mm() {
  test_msadd_mm_i8();
  test_msadd_b_mm();
  test_msadd_mm_i16();
  test_msadd_h_mm();
  test_msadd_mm_i32();
  test_msadd_w_mm();
  test_msadd_mm_i64();
  test_msadd_dw_mm();
}

static void test_mwadd_mm_i8() {
  enum { M = 8, N = 8 };
  const int8_t src1[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  const int8_t src2[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  const int16_t answ[M * N] = {
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, N * sizeof(int8_t));
  mint8_t ms2 = mlc_m(src2, N * sizeof(int8_t));
  mint16_t md = mwadd_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, i16_buffer, N * sizeof(int16_t));
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MWADD_MM I8");
}

static void test_mwadd_b_mm() {
  enum { M = 8, N = 8 };
  const int8_t src1[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  const int8_t src2[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  const int16_t answ[M * N] = {
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
      -256, -256, -256, -256, -256, -256, -256, -256, -256};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, N * sizeof(int8_t));
  mint8_t ms2 = mlc_m(src2, N * sizeof(int8_t));
  mint16_t md = mwadd_b_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, i16_buffer, N * sizeof(int16_t));
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MWADD_B_MM");
}

static void test_mwadd_mm_i16() {
  enum { M = 4, N = 4 };
  const int16_t src1[M * N] = {-32768, -32768, -32768, -32768, -32768, -32768,
                               -32768, -32768, -32768, -32768, -32768, -32768,
                               -32768, -32768, -32768, -32768};
  const int16_t src2[M * N] = {-32768, -32768, -32768, -32768, -32768, -32768,
                               -32768, -32768, -32768, -32768, -32768, -32768,
                               -32768, -32768, -32768, -32768};
  const int32_t answ[M * N] = {-65536, -65536, -65536, -65536, -65536, -65536,
                               -65536, -65536, -65536, -65536, -65536, -65536,
                               -65536, -65536, -65536, -65536};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, N * sizeof(int16_t));
  mint16_t ms2 = mlc_m(src2, N * sizeof(int16_t));
  mint32_t md = mwadd_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, i16_buffer, N * sizeof(int32_t));
  EXCEPT_I32_ARRAY_EQ(answ, i16_buffer, M * N, "MWADD_MM I16");
}

static void test_mwadd_h_mm() {
  enum { M = 4, N = 4 };
  const int16_t src1[M * N] = {-32768, -32768, -32768, -32768, -32768, -32768,
                               -32768, -32768, -32768, -32768, -32768, -32768,
                               -32768, -32768, -32768, -32768};
  const int16_t src2[M * N] = {-32768, -32768, -32768, -32768, -32768, -32768,
                               -32768, -32768, -32768, -32768, -32768, -32768,
                               -32768, -32768, -32768, -32768};
  const int32_t answ[M * N] = {-65536, -65536, -65536, -65536, -65536, -65536,
                               -65536, -65536, -65536, -65536, -65536, -65536,
                               -65536, -65536, -65536, -65536};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, N * sizeof(int16_t));
  mint16_t ms2 = mlc_m(src2, N * sizeof(int16_t));
  mint32_t md = mwadd_h_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, i16_buffer, N * sizeof(int32_t));
  EXCEPT_I32_ARRAY_EQ(answ, i16_buffer, M * N, "MWADD_H_MM");
}

static void test_mwadd_mm_i32() {
  enum { M = 2, N = 2 };
  const int32_t src1[M * N] = {-2147483648, -2147483648, -2147483648,
                               -2147483648};
  const int32_t src2[M * N] = {-2147483648, -2147483648, -2147483648,
                               -2147483648};
  const int64_t answ[M * N] = {-4294967296, -4294967296, -4294967296,
                               -4294967296};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, N * sizeof(int32_t));
  mint32_t ms2 = mlc_m(src2, N * sizeof(int32_t));
  mint64_t md = mwadd_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, i32_buffer, N * sizeof(int64_t));
  EXCEPT_I64_ARRAY_EQ(answ, i32_buffer, M * N, "MWADD_MM I32");
}

static void test_mwadd_w_mm() {
  enum { M = 2, N = 2 };
  const int32_t src1[M * N] = {-2147483648, -2147483648, -2147483648,
                               -2147483648};
  const int32_t src2[M * N] = {-2147483648, -2147483648, -2147483648,
                               -2147483648};
  const int64_t answ[M * N] = {-4294967296, -4294967296, -4294967296,
                               -4294967296};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, N * sizeof(int32_t));
  mint32_t ms2 = mlc_m(src2, N * sizeof(int32_t));
  mint64_t md = mwadd_w_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, i32_buffer, N * sizeof(int64_t));
  EXCEPT_I64_ARRAY_EQ(answ, i32_buffer, M * N, "MWADD_W_MM");
}

static void test_mwadd_mm() {
  test_mwadd_mm_i8();
  test_mwadd_b_mm();
  test_mwadd_mm_i16();
  test_mwadd_h_mm();
  test_mwadd_mm_i32();
  test_mwadd_w_mm();
}

static void test_msubu_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      1,  7,  7,  15, 23, 14, 19, 21, 8,  17, 13, 4,  8,  13, 10, 4,
      0,  19, 4,  5,  20, 22, 7,  19, 10, 9,  20, 11, 20, 18, 11, 23,
      15, 7,  16, 17, 17, 14, 10, 4,  1,  6,  3,  3,  20, 7,  24, 0,
      13, 24, 15, 21, 9,  3,  20, 14, 17, 9,  17, 0,  17, 19, 7,  13};
  const uint8_t src2[M * N] = {
      6,  1,  15, 11, 24, 2,  17, 9,  15, 18, 6,  10, 15, 8,  16, 15,
      9,  1,  24, 9,  4,  12, 17, 13, 17, 8,  0,  13, 1,  11, 21, 21,
      18, 2,  16, 6,  20, 17, 11, 14, 2,  15, 17, 6,  22, 3,  24, 3,
      9,  11, 12, 15, 10, 3,  20, 5,  6,  0,  17, 6,  0,  24, 22, 22};
  const int8_t answ[M * N] = {
      -5, 6,  -8,  4,  -1, 12, 2,   12,  -7, -1, 7,   -6, -7, 5,  -6,  -11,
      -9, 18, -20, -4, 16, 10, -10, 6,   -7, 1,  20,  -2, 19, 7,  -10, 2,
      -3, 5,  0,   11, -3, -3, -1,  -10, -1, -9, -14, -3, -2, 4,  0,   -3,
      4,  13, 3,   6,  -1, 0,  0,   9,   11, 9,  0,   -6, 17, -5, -15, -9};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msubu_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSUBU_MM U8");
}

static void test_msubu_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      1,  7,  7,  15, 23, 14, 19, 21, 8,  17, 13, 4,  8,  13, 10, 4,
      0,  19, 4,  5,  20, 22, 7,  19, 10, 9,  20, 11, 20, 18, 11, 23,
      15, 7,  16, 17, 17, 14, 10, 4,  1,  6,  3,  3,  20, 7,  24, 0,
      13, 24, 15, 21, 9,  3,  20, 14, 17, 9,  17, 0,  17, 19, 7,  13};
  const uint8_t src2[M * N] = {
      6,  1,  15, 11, 24, 2,  17, 9,  15, 18, 6,  10, 15, 8,  16, 15,
      9,  1,  24, 9,  4,  12, 17, 13, 17, 8,  0,  13, 1,  11, 21, 21,
      18, 2,  16, 6,  20, 17, 11, 14, 2,  15, 17, 6,  22, 3,  24, 3,
      9,  11, 12, 15, 10, 3,  20, 5,  6,  0,  17, 6,  0,  24, 22, 22};
  const int8_t answ[M * N] = {
      -5, 6,  -8,  4,  -1, 12, 2,   12,  -7, -1, 7,   -6, -7, 5,  -6,  -11,
      -9, 18, -20, -4, 16, 10, -10, 6,   -7, 1,  20,  -2, 19, 7,  -10, 2,
      -3, 5,  0,   11, -3, -3, -1,  -10, -1, -9, -14, -3, -2, 4,  0,   -3,
      4,  13, 3,   6,  -1, 0,  0,   9,   11, 9,  0,   -6, 17, -5, -15, -9};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msubu_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSUBU_B_MM");
}

static void test_msubu_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      4693, 2385, 39,   999,  1843, 3835, 4688, 1277, 2748, 1432, 6045,
      1600, 5145, 2014, 3021, 4008, 2723, 4255, 1185, 5782, 3400, 6306,
      3576, 1903, 5907, 6448, 3168, 5725, 2246, 4118, 5609, 509,  828,
      850,  2355, 6107, 5998, 985,  3377, 3353, 774,  1583, 423,  5406,
      4881, 6407, 1371, 2588, 5014, 2717, 1529, 2258, 3544, 1846, 3124,
      4592, 5683, 3896, 3202, 152,  6488, 3108, 4177, 2278};
  const uint16_t src2[M * N] = {
      1689, 6260, 2224, 657,  4432, 4759, 2810, 1922, 3875, 3895, 5805,
      449,  2249, 1964, 3304, 1374, 1565, 1826, 2781, 642,  5397, 2014,
      5520, 4743, 5782, 5293, 3868, 2506, 793,  4969, 2996, 704,  3786,
      5235, 3940, 2870, 3417, 3750, 2369, 4311, 1024, 2927, 4179, 285,
      63,   407,  2973, 6463, 2049, 420,  1999, 2493, 3386, 3996, 6306,
      5152, 3412, 676,  5409, 2081, 3361, 813,  5767, 2594};
  const int16_t answ[M * N] = {
      3004,  -3875, -2185, 342,   -2589, -924, 1878, -645,  -1127, -2463, 240,
      1151,  2896,  50,    -283,  2634,  1158, 2429, -1596, 5140,  -1997, 4292,
      -1944, -2840, 125,   1155,  -700,  3219, 1453, -851,  2613,  -195,  -2958,
      -4385, -1585, 3237,  2581,  -2765, 1008, -958, -250,  -1344, -3756, 5121,
      4818,  6000,  -1602, -3875, 2965,  2297, -470, -235,  158,   -2150, -3182,
      -560,  2271,  3220,  -2207, -1929, 3127, 2295, -1590, -316};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msubu_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSUBU_MM I16");
}

static void test_msubu_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      4693, 2385, 39,   999,  1843, 3835, 4688, 1277, 2748, 1432, 6045,
      1600, 5145, 2014, 3021, 4008, 2723, 4255, 1185, 5782, 3400, 6306,
      3576, 1903, 5907, 6448, 3168, 5725, 2246, 4118, 5609, 509,  828,
      850,  2355, 6107, 5998, 985,  3377, 3353, 774,  1583, 423,  5406,
      4881, 6407, 1371, 2588, 5014, 2717, 1529, 2258, 3544, 1846, 3124,
      4592, 5683, 3896, 3202, 152,  6488, 3108, 4177, 2278};
  const uint16_t src2[M * N] = {
      1689, 6260, 2224, 657,  4432, 4759, 2810, 1922, 3875, 3895, 5805,
      449,  2249, 1964, 3304, 1374, 1565, 1826, 2781, 642,  5397, 2014,
      5520, 4743, 5782, 5293, 3868, 2506, 793,  4969, 2996, 704,  3786,
      5235, 3940, 2870, 3417, 3750, 2369, 4311, 1024, 2927, 4179, 285,
      63,   407,  2973, 6463, 2049, 420,  1999, 2493, 3386, 3996, 6306,
      5152, 3412, 676,  5409, 2081, 3361, 813,  5767, 2594};
  const int16_t answ[M * N] = {
      3004,  -3875, -2185, 342,   -2589, -924, 1878, -645,  -1127, -2463, 240,
      1151,  2896,  50,    -283,  2634,  1158, 2429, -1596, 5140,  -1997, 4292,
      -1944, -2840, 125,   1155,  -700,  3219, 1453, -851,  2613,  -195,  -2958,
      -4385, -1585, 3237,  2581,  -2765, 1008, -958, -250,  -1344, -3756, 5121,
      4818,  6000,  -1602, -3875, 2965,  2297, -470, -235,  158,   -2150, -3182,
      -560,  2271,  3220,  -2207, -1929, 3127, 2295, -1590, -316};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msubu_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSUBU_H_MM I16");
}

static void test_msubu_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {104928123, 288693747, 49016853,  349789031,
                                105304797, 119534674, 99452302,  1856182,
                                276702077, 16658148,  32171399,  393407555,
                                328809282, 174236902, 425030448, 235891978};
  const uint32_t src2[M * N] = {95095265,  419609867, 149209981, 165335091,
                                165675342, 166245026, 321769386, 301922745,
                                276584054, 356703141, 171794217, 309500992,
                                270550181, 93317383,  213121223, 425917233};
  const int32_t answ[M * N] = {9832858,   -130916120, -100193128, 184453940,
                               -60370545, -46710352,  -222317084, -300066563,
                               118023,    -340044993, -139622818, 83906563,
                               58259101,  80919519,   211909225,  -190025255};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msubu_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSUBU_MM I32");
}

static void test_msubu_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {104928123, 288693747, 49016853,  349789031,
                                105304797, 119534674, 99452302,  1856182,
                                276702077, 16658148,  32171399,  393407555,
                                328809282, 174236902, 425030448, 235891978};
  const uint32_t src2[M * N] = {95095265,  419609867, 149209981, 165335091,
                                165675342, 166245026, 321769386, 301922745,
                                276584054, 356703141, 171794217, 309500992,
                                270550181, 93317383,  213121223, 425917233};
  const int32_t answ[M * N] = {9832858,   -130916120, -100193128, 184453940,
                               -60370545, -46710352,  -222317084, -300066563,
                               118023,    -340044993, -139622818, 83906563,
                               58259101,  80919519,   211909225,  -190025255};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msubu_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSUBU_W_MM");
}

static void test_msubu_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1721459400087184318, 1525873593192543939,
                                636701155420157329, 315570753088324169};
  const uint64_t src2[M * N] = {1726786601773798622, 335104999803916143,
                                540335988563115112, 663439181763442027};
  const int64_t answ[M * N] = {-5327201686614304, 1190768593388627796,
                               96365166857042217, -347868428675117858};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msubu_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSUBU_MM U64");
}

static void test_msubu_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1721459400087184318, 1525873593192543939,
                                636701155420157329, 315570753088324169};
  const uint64_t src2[M * N] = {1726786601773798622, 335104999803916143,
                                540335988563115112, 663439181763442027};
  const int64_t answ[M * N] = {-5327201686614304, 1190768593388627796,
                               96365166857042217, -347868428675117858};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msubu_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSUBU_DW_MM");
}

static void test_msubu_mm() {
  test_msubu_mm_u8();
  test_msubu_b_mm();
  test_msubu_mm_i16();
  test_msubu_h_mm();
  test_msubu_mm_u32();
  test_msubu_w_mm();
  test_msubu_mm_u64();
  test_msubu_dw_mm();
}

static void test_mssubu_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {0};
  const uint8_t src2[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const int8_t answ[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mssubu_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSSUBU_MM U8");
}

static void test_mssubu_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {0};
  const uint8_t src2[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const int8_t answ[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mssubu_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSSUBU_B_MM");
}

static void test_mssubu_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {0};
  const uint16_t src2[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const int16_t answ[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mssubu_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSSUBU_MM U16");
}

static void test_mssubu_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {0};
  const uint16_t src2[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const int16_t answ[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mssubu_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSSUBU_H_MM");
}

static void test_mssubu_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {0};
  const uint32_t src2[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const int32_t answ[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mssubu_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSSUBU_MM U32");
}

static void test_mssubu_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {0};
  const uint32_t src2[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const int32_t answ[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mssubu_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSSUBU_W_MM");
}

static void test_mssubu_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {0};
  const uint64_t src2[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const int64_t answ[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mssubu_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSSUBU_MM U64");
}

static void test_mssubu_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {0};
  const uint64_t src2[M * N] = {9223372036854775809ull, 9223372036854775809ull,
                                9223372036854775809ull, 9223372036854775809ull};
  const int64_t answ[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mssubu_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSSUBU_DW_MM");
}

static void test_mssubu_mm() {
  test_mssubu_mm_u8();
  test_mssubu_b_mm();
  test_mssubu_mm_u16();
  test_mssubu_h_mm();
  test_mssubu_mm_u32();
  test_mssubu_w_mm();
  test_mssubu_mm_u64();
  test_mssubu_dw_mm();
}

static void test_msub_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      -5, 4,  0,  1,  -6, 3,  -11, -2, -9, -12, -1,  10,  4,   -7, -3,  5,
      -1, 3,  9,  -1, 2,  6,  2,   -2, 7,  2,   -10, -4,  -10, 7,  7,   10,
      -4, 0,  -6, -9, -1, -3, 11,  -3, -2, 6,   3,   -12, -12, -1, -10, -12,
      -1, -8, -3, 11, -9, 0,  -11, 10, 1,  -3,  -6,  3,   -2,  0,  7,   2};
  const int8_t src2[M * N] = {
      -1, 0,   -3, 8,   6,   9,   -8, -10, 11,  -4, -4, 4,  10, 9,   -10, -1,
      -3, -10, -5, 11,  9,   -7,  8,  -9,  -8,  1,  -6, -5, 2,  -2,  -3,  0,
      -9, 3,   8,  0,   -7,  -12, -8, 4,   -10, 5,  11, 9,  -9, 1,   6,   -8,
      3,  -9,  4,  -12, -11, 11,  2,  3,   10,  10, -3, -6, -5, -12, -4,  -9};
  const int8_t answ[M * N] = {-4, 4,   3,   -7, -12, -6, -3,  8,  -20, -8,  3,
                              6,  -6,  -16, 7,  6,   2,  13,  14, -12, -7,  13,
                              -6, 7,   15,  1,  -4,  1,  -12, 9,  10,  10,  5,
                              -3, -14, -9,  6,  9,   19, -7,  8,  1,   -8,  -21,
                              -3, -2,  -16, -4, -4,  1,  -7,  23, 2,   -11, -13,
                              7,  -9,  -13, -3, 9,   3,  12,  11, 11};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msub_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSUB_MM I8");
}

static void test_msub_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      -5, 4,  0,  1,  -6, 3,  -11, -2, -9, -12, -1,  10,  4,   -7, -3,  5,
      -1, 3,  9,  -1, 2,  6,  2,   -2, 7,  2,   -10, -4,  -10, 7,  7,   10,
      -4, 0,  -6, -9, -1, -3, 11,  -3, -2, 6,   3,   -12, -12, -1, -10, -12,
      -1, -8, -3, 11, -9, 0,  -11, 10, 1,  -3,  -6,  3,   -2,  0,  7,   2};
  const int8_t src2[M * N] = {
      -1, 0,   -3, 8,   6,   9,   -8, -10, 11,  -4, -4, 4,  10, 9,   -10, -1,
      -3, -10, -5, 11,  9,   -7,  8,  -9,  -8,  1,  -6, -5, 2,  -2,  -3,  0,
      -9, 3,   8,  0,   -7,  -12, -8, 4,   -10, 5,  11, 9,  -9, 1,   6,   -8,
      3,  -9,  4,  -12, -11, 11,  2,  3,   10,  10, -3, -6, -5, -12, -4,  -9};
  const int8_t answ[M * N] = {-4, 4,   3,   -7, -12, -6, -3,  8,  -20, -8,  3,
                              6,  -6,  -16, 7,  6,   2,  13,  14, -12, -7,  13,
                              -6, 7,   15,  1,  -4,  1,  -12, 9,  10,  10,  5,
                              -3, -14, -9,  6,  9,   19, -7,  8,  1,   -8,  -21,
                              -3, -2,  -16, -4, -4,  1,  -7,  23, 2,   -11, -13,
                              7,  -9,  -13, -3, 9,   3,  12,  11, 11};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msub_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSUB_B_MM");
}

static void test_msub_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      367,   -2229, 2132, -1457, 1776,  2766,  605,   -1060, 3273, 2805,  -2894,
      767,   -329,  1704, -1145, 466,   2250,  -1981, -1095, 2582, 2526,  2221,
      -1067, 270,   -334, -2714, 1273,  2715,  -63,   -804,  1493, 1104,  1204,
      1869,  -2606, 816,  1065,  -1403, -2354, -2777, -1753, 1343, -2771, -1143,
      2306,  -437,  2362, 1995,  2033,  149,   -566,  -832,  1299, 3193,  1747,
      -1542, 510,   2088, -791,  335,   -1121, 1741,  2671,  1336};
  const int16_t src2[M * N] = {
      2902, -2923, -837,  -2668, 197,  1789,  -154,  -2327, 905,   -1107, -157,
      -919, 205,   -852,  2289,  -913, 2989,  3088,  285,   -2533, -424,  -1080,
      -443, 2407,  -2164, -2399, 1261, 2407,  809,   134,   1636,  -1991, -2011,
      2090, 3272,  895,   -3252, 1427, -676,  2210,  1305,  835,   1807,  1482,
      1642, -548,  -402,  -1029, 2382, -1983, 2886,  674,   -2528, -2551, -2515,
      -628, 628,   -414,  -2446, 778,  -2996, -1501, -146,  -330};
  const int16_t answ[M * N] = {
      -2535, 694,   2969, 1211,  1579,  977,   759,   1267,  2368, 3912,  -2737,
      1686,  -534,  2556, -3434, 1379,  -739,  -5069, -1380, 5115, 2950,  3301,
      -624,  -2137, 1830, -315,  12,    308,   -872,  -938,  -143, 3095,  3215,
      -221,  -5878, -79,  4317,  -2830, -1678, -4987, -3058, 508,  -4578, -2625,
      664,   111,   2764, 3024,  -349,  2132,  -3452, -1506, 3827, 5744,  4262,
      -914,  -118,  2502, 1655,  -443,  1875,  3242,  2817,  1666};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msub_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSUB_MM I16");
}

static void test_msub_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      367,   -2229, 2132, -1457, 1776,  2766,  605,   -1060, 3273, 2805,  -2894,
      767,   -329,  1704, -1145, 466,   2250,  -1981, -1095, 2582, 2526,  2221,
      -1067, 270,   -334, -2714, 1273,  2715,  -63,   -804,  1493, 1104,  1204,
      1869,  -2606, 816,  1065,  -1403, -2354, -2777, -1753, 1343, -2771, -1143,
      2306,  -437,  2362, 1995,  2033,  149,   -566,  -832,  1299, 3193,  1747,
      -1542, 510,   2088, -791,  335,   -1121, 1741,  2671,  1336};
  const int16_t src2[M * N] = {
      2902, -2923, -837,  -2668, 197,  1789,  -154,  -2327, 905,   -1107, -157,
      -919, 205,   -852,  2289,  -913, 2989,  3088,  285,   -2533, -424,  -1080,
      -443, 2407,  -2164, -2399, 1261, 2407,  809,   134,   1636,  -1991, -2011,
      2090, 3272,  895,   -3252, 1427, -676,  2210,  1305,  835,   1807,  1482,
      1642, -548,  -402,  -1029, 2382, -1983, 2886,  674,   -2528, -2551, -2515,
      -628, 628,   -414,  -2446, 778,  -2996, -1501, -146,  -330};
  const int16_t answ[M * N] = {
      -2535, 694,   2969, 1211,  1579,  977,   759,   1267,  2368, 3912,  -2737,
      1686,  -534,  2556, -3434, 1379,  -739,  -5069, -1380, 5115, 2950,  3301,
      -624,  -2137, 1830, -315,  12,    308,   -872,  -938,  -143, 3095,  3215,
      -221,  -5878, -79,  4317,  -2830, -1678, -4987, -3058, 508,  -4578, -2625,
      664,   111,   2764, 3024,  -349,  2132,  -3452, -1506, 3827, 5744,  4262,
      -914,  -118,  2502, 1655,  -443,  1875,  3242,  2817,  1666};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msub_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSUB_H_MM I16");
}

static void test_msub_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-125130347, 110264437, 178950190,  -158568139,
                               -92784798,  58369040,  -133494946, -127604045,
                               -50489679,  161041763, 4901796,    10495938,
                               202748896,  58404497,  43153685,   92732528};
  const int32_t src2[M * N] = {-70427441,  172792072, -61787062,  -16070013,
                               -120845322, 89104912,  -117206723, 212799671,
                               -144400031, -59476457, 50682218,   -14249299,
                               -124308114, 65349200,  21040859,   148281214};
  const int32_t answ[M * N] = {-54702906, -62527635, 240737252, -142498126,
                               28060524,  -30735872, -16288223, -340403716,
                               93910352,  220518220, -45780422, 24745237,
                               327057010, -6944703,  22112826,  -55548686};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msub_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSUB_MM I32");
}

static void test_msub_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-125130347, 110264437, 178950190,  -158568139,
                               -92784798,  58369040,  -133494946, -127604045,
                               -50489679,  161041763, 4901796,    10495938,
                               202748896,  58404497,  43153685,   92732528};
  const int32_t src2[M * N] = {-70427441,  172792072, -61787062,  -16070013,
                               -120845322, 89104912,  -117206723, 212799671,
                               -144400031, -59476457, 50682218,   -14249299,
                               -124308114, 65349200,  21040859,   148281214};
  const int32_t answ[M * N] = {-54702906, -62527635, 240737252, -142498126,
                               28060524,  -30735872, -16288223, -340403716,
                               93910352,  220518220, -45780422, 24745237,
                               327057010, -6944703,  22112826,  -55548686};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msub_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSUB_W_MM");
}

static void test_msub_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-515731329840470244, 315712491169633524,
                               -518471480186841324, -535821387737238949};
  const int64_t src2[M * N] = {-339175904574132779, -647087140206696310,
                               -7920688885575251, -411088015836397403};
  const int64_t answ[M * N] = {-176555425266337465, 962799631376329834,
                               -510550791301266073, -124733371900841546};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msub_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSUB_MM I64");
}

static void test_msub_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-515731329840470244, 315712491169633524,
                               -518471480186841324, -535821387737238949};
  const int64_t src2[M * N] = {-339175904574132779, -647087140206696310,
                               -7920688885575251, -411088015836397403};
  const int64_t answ[M * N] = {-176555425266337465, 962799631376329834,
                               -510550791301266073, -124733371900841546};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msub_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSUB_DW_MM");
}

static void test_msub_mm() {
  test_msub_mm_i8();
  test_msub_b_mm();
  test_msub_mm_i16();
  test_msub_h_mm();
  test_msub_mm_i32();
  test_msub_w_mm();
  test_msub_mm_i64();
  test_msub_dw_mm();
}

static void test_mssub_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2};
  const int8_t src2[M * N] = {
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127};
  const int8_t answ[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mssub_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSSUB_MM U8");
}

static void test_mssub_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2};
  const int8_t src2[M * N] = {
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127};
  const int8_t answ[M * N] = {
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128, -128, -128,
      -128, -128, -128, -128, -128, -128, -128, -128, -128};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mssub_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSSUB_B_MM");
}

static void test_mssub_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2};
  const int16_t src2[M * N] = {
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767};
  const int16_t answ[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mssub_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSSUB_MM I16");
}

static void test_mssub_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2};
  const int16_t src2[M * N] = {
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767, 32767,
      32767, 32767, 32767, 32767};
  const int16_t answ[M * N] = {
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768,
      -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mssub_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSSUB_H_MM");
}

static void test_mssub_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-2, -2, -2, -2, -2, -2, -2, -2,
                               -2, -2, -2, -2, -2, -2, -2, -2};
  const int32_t src2[M * N] = {2147483647, 2147483647, 2147483647, 2147483647,
                               2147483647, 2147483647, 2147483647, 2147483647,
                               2147483647, 2147483647, 2147483647, 2147483647,
                               2147483647, 2147483647, 2147483647, 2147483647};
  const int32_t answ[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mssub_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSSUB_MM I32");
}

static void test_mssub_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-2, -2, -2, -2, -2, -2, -2, -2,
                               -2, -2, -2, -2, -2, -2, -2, -2};
  const int32_t src2[M * N] = {2147483647, 2147483647, 2147483647, 2147483647,
                               2147483647, 2147483647, 2147483647, 2147483647,
                               2147483647, 2147483647, 2147483647, 2147483647,
                               2147483647, 2147483647, 2147483647, 2147483647};
  const int32_t answ[M * N] = {
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648,
      -2147483648, -2147483648, -2147483648, -2147483648};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mssub_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSSUB_W_MM");
}

static void test_mssub_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-2, -2, -2, -2};
  const int64_t src2[M * N] = {0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFFF,
                               0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFFF};
  const int64_t answ[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mssub_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSSUB_MM I64");
}

static void test_mssub_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-2, -2, -2, -2};
  const int64_t src2[M * N] = {0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFFF,
                               0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFFF};
  const int64_t answ[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mssub_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSSUB_DW_MM");
}

static void test_mssub_mm() {
  test_mssub_mm_u8();
  test_mssub_b_mm();
  test_mssub_mm_i16();
  test_mssub_h_mm();
  test_mssub_mm_i32();
  test_mssub_w_mm();
  test_mssub_mm_i64();
  test_mssub_dw_mm();
}

static void test_mwsub_mm_i8() {
  enum { M = 8, N = 8 };
  const int8_t src1[M * N] = {
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2};
  const int8_t src2[M * N] = {
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127};
  const int16_t answ[M * N] = {
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, N * sizeof(int8_t));
  mint8_t ms2 = mlc_m(src2, N * sizeof(int8_t));
  mint16_t md = mwsub_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, i16_buffer, N * sizeof(int16_t));
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MWSUB_MM I8");
}

static void test_mwsub_b_mm() {
  enum { M = 8, N = 8 };
  const int8_t src1[M * N] = {
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,
      -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2};
  const int8_t src2[M * N] = {
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,
      127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127};
  const int16_t answ[M * N] = {
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129, -129, -129,
      -129, -129, -129, -129, -129, -129, -129, -129, -129};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, N * sizeof(int8_t));
  mint8_t ms2 = mlc_m(src2, N * sizeof(int8_t));
  mint16_t md = mwsub_b_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, i16_buffer, N * sizeof(int16_t));
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MWSUB_B_MM");
}

static void test_mwsub_mm_i16() {
  enum { M = 4, N = 4 };
  const int16_t src1[M * N] = {-2, -2, -2, -2, -2, -2, -2, -2,
                               -2, -2, -2, -2, -2, -2, -2, -2};
  const int16_t src2[M * N] = {32767, 32767, 32767, 32767, 32767, 32767,
                               32767, 32767, 32767, 32767, 32767, 32767,
                               32767, 32767, 32767, 32767};
  const int32_t answ[M * N] = {-32769, -32769, -32769, -32769, -32769, -32769,
                               -32769, -32769, -32769, -32769, -32769, -32769,
                               -32769, -32769, -32769, -32769};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, N * sizeof(int16_t));
  mint16_t ms2 = mlc_m(src2, N * sizeof(int16_t));
  mint32_t md = mwsub_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, i16_buffer, N * sizeof(int32_t));
  EXCEPT_I32_ARRAY_EQ(answ, i16_buffer, M * N, "MWSUB_MM I16");
}

static void test_mwsub_h_mm() {
  enum { M = 4, N = 4 };
  const int16_t src1[M * N] = {-2, -2, -2, -2, -2, -2, -2, -2,
                               -2, -2, -2, -2, -2, -2, -2, -2};
  const int16_t src2[M * N] = {32767, 32767, 32767, 32767, 32767, 32767,
                               32767, 32767, 32767, 32767, 32767, 32767,
                               32767, 32767, 32767, 32767};
  const int32_t answ[M * N] = {-32769, -32769, -32769, -32769, -32769, -32769,
                               -32769, -32769, -32769, -32769, -32769, -32769,
                               -32769, -32769, -32769, -32769};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, N * sizeof(int16_t));
  mint16_t ms2 = mlc_m(src2, N * sizeof(int16_t));
  mint32_t md = mwsub_h_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, i16_buffer, N * sizeof(int32_t));
  EXCEPT_I32_ARRAY_EQ(answ, i16_buffer, M * N, "MWSUB_H_MM");
}

static void test_mwsub_mm_i32() {
  enum { M = 2, N = 2 };
  const int32_t src1[M * N] = {-2, -2, -2, -2};
  const int32_t src2[M * N] = {2147483647, 2147483647, 2147483647, 2147483647};
  const int64_t answ[M * N] = {-2147483649, -2147483649, -2147483649,
                               -2147483649};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, N * sizeof(int32_t));
  mint32_t ms2 = mlc_m(src2, N * sizeof(int32_t));
  mint64_t md = mwsub_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, i32_buffer, N * sizeof(int64_t));
  EXCEPT_I64_ARRAY_EQ(answ, i32_buffer, M * N, "MWSUB_MM I32");
}

static void test_mwsub_w_mm() {
  enum { M = 2, N = 2 };
  const int32_t src1[M * N] = {-2, -2, -2, -2};
  const int32_t src2[M * N] = {2147483647, 2147483647, 2147483647, 2147483647};
  const int64_t answ[M * N] = {-2147483649, -2147483649, -2147483649,
                               -2147483649};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, N * sizeof(int32_t));
  mint32_t ms2 = mlc_m(src2, N * sizeof(int32_t));
  mint64_t md = mwsub_w_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, i32_buffer, N * sizeof(int64_t));
  EXCEPT_I64_ARRAY_EQ(answ, i32_buffer, M * N, "MWSUB_W_MM");
}

static void test_mwsub_mm() {
  test_mwsub_mm_i8();
  test_mwsub_b_mm();
  test_mwsub_mm_i16();
  test_mwsub_h_mm();
  test_mwsub_mm_i32();
  test_mwsub_w_mm();
}

static void test_mmin_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      1,  -11, -11, 3,   11, 4,  -3,  -1, 3,  -1,  8,  9,  4,   1,  8,   7,
      1,  1,   -4,  7,   -9, -4, -11, 9,  3,  4,   0,  10, 7,   11, -12, 4,
      -2, -6,  -5,  -12, 10, -8, 1,   -7, -8, -12, -6, 11, -10, -7, 2,   -10,
      4,  11,  -11, -1,  5,  -6, -1,  -4, -4, -5,  6,  5,  3,   -3, 7,   8};
  const int8_t src2[M * N] = {
      -8, 11, -12, 6,   -6, 9,   10, 4,  -2, -12, -4, -3, 0,   0,  7,  -11,
      -9, 6,  2,   -1,  8,  -12, 0,  9,  1,  0,   9,  5,  -10, 8,  -4, 2,
      -8, -8, -10, -10, -8, 10,  -4, -6, 9,  11,  -9, -6, 4,   6,  9,  7,
      -1, 0,  -5,  4,   9,  -6,  -5, 4,  -6, -9,  11, 8,  -1,  -1, -3, -12};
  const int8_t answ[M * N] = {
      -8, -11, -12, 3,   -6, 4,   -3,  -1, -2, -12, -4, -3, 0,   0,  7,   -11,
      -9, 1,   -4,  -1,  -9, -12, -11, 9,  1,  0,   0,  5,  -10, 8,  -12, 2,
      -8, -8,  -10, -12, -8, -8,  -4,  -7, -8, -12, -9, -6, -10, -7, 2,   -10,
      -1, 0,   -11, -1,  5,  -6,  -5,  -4, -6, -9,  6,  5,  -1,  -3, -3,  -12};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmin_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMIN_MM I8");
}

static void test_mmin_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      1,  -11, -11, 3,   11, 4,  -3,  -1, 3,  -1,  8,  9,  4,   1,  8,   7,
      1,  1,   -4,  7,   -9, -4, -11, 9,  3,  4,   0,  10, 7,   11, -12, 4,
      -2, -6,  -5,  -12, 10, -8, 1,   -7, -8, -12, -6, 11, -10, -7, 2,   -10,
      4,  11,  -11, -1,  5,  -6, -1,  -4, -4, -5,  6,  5,  3,   -3, 7,   8};
  const int8_t src2[M * N] = {
      -8, 11, -12, 6,   -6, 9,   10, 4,  -2, -12, -4, -3, 0,   0,  7,  -11,
      -9, 6,  2,   -1,  8,  -12, 0,  9,  1,  0,   9,  5,  -10, 8,  -4, 2,
      -8, -8, -10, -10, -8, 10,  -4, -6, 9,  11,  -9, -6, 4,   6,  9,  7,
      -1, 0,  -5,  4,   9,  -6,  -5, 4,  -6, -9,  11, 8,  -1,  -1, -3, -12};
  const int8_t answ[M * N] = {
      -8, -11, -12, 3,   -6, 4,   -3,  -1, -2, -12, -4, -3, 0,   0,  7,   -11,
      -9, 1,   -4,  -1,  -9, -12, -11, 9,  1,  0,   0,  5,  -10, 8,  -12, 2,
      -8, -8,  -10, -12, -8, -8,  -4,  -7, -8, -12, -9, -6, -10, -7, 2,   -10,
      -1, 0,   -11, -1,  5,  -6,  -5,  -4, -6, -9,  6,  5,  -1,  -3, -3,  -12};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmin_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMIN_B_MM");
}

static void test_mmin_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -3178, -2033, -1072, 1970, -967,  1056,  3001,  -1387, 2039,  1096,
      -828,  -2422, 522,   1249, -914,  3110,  1383,  888,   83,    -1612,
      -1003, 1880,  -1988, 440,  2678,  2159,  -446,  -2529, 1182,  2137,
      -697,  -2704, -2914, -431, -3171, -1832, -2006, -1322, 255,   -1270,
      18,    -1450, -427,  -196, 1775,  -2372, -2102, 821,   470,   1920,
      -2885, -2695, -2457, 232,  -2746, 2929,  -1071, 2875,  -2746, -2959,
      2154,  -2146, -3116, -622};
  const int16_t src2[M * N] = {
      -985,  -1179, -887,  806,   -1476, -2753, -2494, -836,  -3099, 640,
      3115,  1733,  -3244, -2488, 1150,  3097,  -2152, 1493,  2671,  3060,
      -2258, -2512, 1386,  2625,  1016,  -2930, 3060,  481,   -736,  -770,
      -201,  1151,  -1930, -1435, -2176, 1435,  -1762, -2401, -2128, -842,
      131,   -3197, -2341, -3067, -2696, 1089,  -2062, 2304,  2869,  -2396,
      3064,  2355,  1739,  544,   547,   2793,  -1662, -3262, 2796,  -725,
      170,   -1142, -3159, -1996};
  const int16_t answ[M * N] = {
      -3178, -2033, -1072, 806,   -1476, -2753, -2494, -1387, -3099, 640,
      -828,  -2422, -3244, -2488, -914,  3097,  -2152, 888,   83,    -1612,
      -2258, -2512, -1988, 440,   1016,  -2930, -446,  -2529, -736,  -770,
      -697,  -2704, -2914, -1435, -3171, -1832, -2006, -2401, -2128, -1270,
      18,    -3197, -2341, -3067, -2696, -2372, -2102, 821,   470,   -2396,
      -2885, -2695, -2457, 232,   -2746, 2793,  -1662, -3262, -2746, -2959,
      170,   -2146, -3159, -1996};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmin_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMIN_MM I16");
}

static void test_mmin_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -3178, -2033, -1072, 1970, -967,  1056,  3001,  -1387, 2039,  1096,
      -828,  -2422, 522,   1249, -914,  3110,  1383,  888,   83,    -1612,
      -1003, 1880,  -1988, 440,  2678,  2159,  -446,  -2529, 1182,  2137,
      -697,  -2704, -2914, -431, -3171, -1832, -2006, -1322, 255,   -1270,
      18,    -1450, -427,  -196, 1775,  -2372, -2102, 821,   470,   1920,
      -2885, -2695, -2457, 232,  -2746, 2929,  -1071, 2875,  -2746, -2959,
      2154,  -2146, -3116, -622};
  const int16_t src2[M * N] = {
      -985,  -1179, -887,  806,   -1476, -2753, -2494, -836,  -3099, 640,
      3115,  1733,  -3244, -2488, 1150,  3097,  -2152, 1493,  2671,  3060,
      -2258, -2512, 1386,  2625,  1016,  -2930, 3060,  481,   -736,  -770,
      -201,  1151,  -1930, -1435, -2176, 1435,  -1762, -2401, -2128, -842,
      131,   -3197, -2341, -3067, -2696, 1089,  -2062, 2304,  2869,  -2396,
      3064,  2355,  1739,  544,   547,   2793,  -1662, -3262, 2796,  -725,
      170,   -1142, -3159, -1996};
  const int16_t answ[M * N] = {
      -3178, -2033, -1072, 806,   -1476, -2753, -2494, -1387, -3099, 640,
      -828,  -2422, -3244, -2488, -914,  3097,  -2152, 888,   83,    -1612,
      -2258, -2512, -1988, 440,   1016,  -2930, -446,  -2529, -736,  -770,
      -697,  -2704, -2914, -1435, -3171, -1832, -2006, -2401, -2128, -1270,
      18,    -3197, -2341, -3067, -2696, -2372, -2102, 821,   470,   -2396,
      -2885, -2695, -2457, 232,   -2746, 2793,  -1662, -3262, -2746, -2959,
      170,   -2146, -3159, -1996};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmin_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMIN_H_MM");
}

static void test_mmin_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {41625267,   -144199020, 159786712,  -25168012,
                               -125654681, -47448576,  -120637043, -178225765,
                               93853325,   99054029,   -72905551,  141615249,
                               210593072,  -54113340,  -58606792,  -108681119};
  const int32_t src2[M * N] = {-209106782, 173817229,  24575187,   -4641659,
                               77968517,   68366554,   -192796336, 143595691,
                               209186828,  -115724108, -67346928,  837693,
                               38579027,   110812142,  163301771,  -88376556};
  const int32_t answ[M * N] = {-209106782, -144199020, 24575187,   -25168012,
                               -125654681, -47448576,  -192796336, -178225765,
                               93853325,   -115724108, -72905551,  837693,
                               38579027,   -54113340,  -58606792,  -108681119};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmin_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMIN_MM I32");
}

static void test_mmin_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {41625267,   -144199020, 159786712,  -25168012,
                               -125654681, -47448576,  -120637043, -178225765,
                               93853325,   99054029,   -72905551,  141615249,
                               210593072,  -54113340,  -58606792,  -108681119};
  const int32_t src2[M * N] = {-209106782, 173817229,  24575187,   -4641659,
                               77968517,   68366554,   -192796336, 143595691,
                               209186828,  -115724108, -67346928,  837693,
                               38579027,   110812142,  163301771,  -88376556};
  const int32_t answ[M * N] = {-209106782, -144199020, 24575187,   -25168012,
                               -125654681, -47448576,  -192796336, -178225765,
                               93853325,   -115724108, -72905551,  837693,
                               38579027,   -54113340,  -58606792,  -108681119};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmin_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMIN_W_MM");
}

static void test_mmin_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-79689974157412164, -476366254160291943,
                               -214898548577044191, -788693899504029414};
  const int64_t src2[M * N] = {772164617172224390, -885016501883186882,
                               69185339857508611, 769175156226934116};
  const int64_t answ[M * N] = {-79689974157412164, -885016501883186882,
                               -214898548577044191, -788693899504029414};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mmin_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMIN_MM I64");
}

static void test_mmin_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-79689974157412164, -476366254160291943,
                               -214898548577044191, -788693899504029414};
  const int64_t src2[M * N] = {772164617172224390, -885016501883186882,
                               69185339857508611, 769175156226934116};
  const int64_t answ[M * N] = {-79689974157412164, -885016501883186882,
                               -214898548577044191, -788693899504029414};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mmin_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMIN_DW_MM");
}

static void test_mmin_mm() {
  test_mmin_mm_i8();
  test_mmin_b_mm();
  test_mmin_mm_i16();
  test_mmin_h_mm();
  test_mmin_mm_i32();
  test_mmin_w_mm();
  test_mmin_mm_i64();
  test_mmin_dw_mm();
}

static void test_mminu_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      14, 14, 9,  4,  12, 13, 16, 4,  24, 0,  15, 21, 19, 11, 8,  3,
      13, 19, 3,  21, 14, 6,  9,  9,  19, 24, 9,  23, 0,  10, 13, 21,
      7,  17, 12, 13, 6,  12, 10, 1,  13, 2,  9,  1,  22, 6,  21, 4,
      16, 9,  22, 24, 17, 14, 0,  22, 0,  7,  24, 10, 24, 7,  17, 5};
  const uint8_t src2[M * N] = {
      20, 24, 20, 12, 17, 6,  4,  1,  12, 11, 8, 15, 23, 9, 20, 7,
      5,  16, 13, 13, 21, 3,  11, 0,  8,  5,  0, 5,  20, 6, 22, 14,
      8,  4,  6,  21, 18, 9,  23, 21, 22, 7,  1, 20, 2,  0, 4,  15,
      19, 20, 3,  1,  19, 10, 17, 14, 11, 6,  9, 14, 21, 9, 1,  12};
  const uint8_t answ[M * N] = {14, 14, 9, 4,  12, 6,  4,  1,  12, 0,  8, 15, 19,
                               9,  8,  3, 5,  16, 3,  13, 14, 3,  9,  0, 8,  5,
                               0,  5,  0, 6,  13, 14, 7,  4,  6,  13, 6, 9,  10,
                               1,  13, 2, 1,  1,  2,  0,  4,  4,  16, 9, 3,  1,
                               17, 10, 0, 14, 0,  6,  9,  10, 21, 7,  1, 5};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mminu_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MMINU_MM U8");
}

static void test_mminu_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      14, 14, 9,  4,  12, 13, 16, 4,  24, 0,  15, 21, 19, 11, 8,  3,
      13, 19, 3,  21, 14, 6,  9,  9,  19, 24, 9,  23, 0,  10, 13, 21,
      7,  17, 12, 13, 6,  12, 10, 1,  13, 2,  9,  1,  22, 6,  21, 4,
      16, 9,  22, 24, 17, 14, 0,  22, 0,  7,  24, 10, 24, 7,  17, 5};
  const uint8_t src2[M * N] = {
      20, 24, 20, 12, 17, 6,  4,  1,  12, 11, 8, 15, 23, 9, 20, 7,
      5,  16, 13, 13, 21, 3,  11, 0,  8,  5,  0, 5,  20, 6, 22, 14,
      8,  4,  6,  21, 18, 9,  23, 21, 22, 7,  1, 20, 2,  0, 4,  15,
      19, 20, 3,  1,  19, 10, 17, 14, 11, 6,  9, 14, 21, 9, 1,  12};
  const uint8_t answ[M * N] = {14, 14, 9, 4,  12, 6,  4,  1,  12, 0,  8, 15, 19,
                               9,  8,  3, 5,  16, 3,  13, 14, 3,  9,  0, 8,  5,
                               0,  5,  0, 6,  13, 14, 7,  4,  6,  13, 6, 9,  10,
                               1,  13, 2, 1,  1,  2,  0,  4,  4,  16, 9, 3,  1,
                               17, 10, 0, 14, 0,  6,  9,  10, 21, 7,  1, 5};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mminu_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MMINU_B_MM");
}

static void test_mminu_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      2806, 3301, 4930, 6113, 1683, 2884, 2216, 3236, 4956, 2721, 1128,
      2461, 880,  396,  2912, 4174, 4466, 5096, 3418, 5264, 2961, 5985,
      2813, 4725, 1389, 6289, 642,  3083, 4105, 5468, 170,  1292, 4906,
      3176, 6348, 4716, 406,  4834, 2960, 1985, 5759, 1677, 673,  20,
      5008, 2338, 2380, 3751, 3038, 1628, 51,   5014, 650,  4624, 6430,
      659,  358,  335,  4551, 6495, 952,  970,  4026, 2226};
  const uint16_t src2[M * N] = {
      2345, 6056, 3589, 51,   594,  1997, 1586, 6146, 1159, 4231, 2720,
      2560, 386,  2245, 5663, 5658, 5103, 2563, 2090, 1799, 5824, 4452,
      5288, 3461, 1596, 1981, 5438, 1351, 4691, 5643, 4071, 2120, 795,
      1469, 1676, 4646, 584,  3367, 2858, 5753, 2008, 4646, 3556, 6097,
      4816, 1749, 5760, 3945, 6381, 849,  3727, 647,  3315, 1055, 4572,
      5981, 1043, 5604, 2970, 3732, 3408, 6225, 3526, 4756};
  const uint16_t answ[M * N] = {
      2345, 3301, 3589, 51,   594,  1997, 1586, 3236, 1159, 2721, 1128,
      2461, 386,  396,  2912, 4174, 4466, 2563, 2090, 1799, 2961, 4452,
      2813, 3461, 1389, 1981, 642,  1351, 4105, 5468, 170,  1292, 795,
      1469, 1676, 4646, 406,  3367, 2858, 1985, 2008, 1677, 673,  20,
      4816, 1749, 2380, 3751, 3038, 849,  51,   647,  650,  1055, 4572,
      659,  358,  335,  2970, 3732, 952,  970,  3526, 2226};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mminu_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MMINU_MM U16");
}

static void test_mminu_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      2806, 3301, 4930, 6113, 1683, 2884, 2216, 3236, 4956, 2721, 1128,
      2461, 880,  396,  2912, 4174, 4466, 5096, 3418, 5264, 2961, 5985,
      2813, 4725, 1389, 6289, 642,  3083, 4105, 5468, 170,  1292, 4906,
      3176, 6348, 4716, 406,  4834, 2960, 1985, 5759, 1677, 673,  20,
      5008, 2338, 2380, 3751, 3038, 1628, 51,   5014, 650,  4624, 6430,
      659,  358,  335,  4551, 6495, 952,  970,  4026, 2226};
  const uint16_t src2[M * N] = {
      2345, 6056, 3589, 51,   594,  1997, 1586, 6146, 1159, 4231, 2720,
      2560, 386,  2245, 5663, 5658, 5103, 2563, 2090, 1799, 5824, 4452,
      5288, 3461, 1596, 1981, 5438, 1351, 4691, 5643, 4071, 2120, 795,
      1469, 1676, 4646, 584,  3367, 2858, 5753, 2008, 4646, 3556, 6097,
      4816, 1749, 5760, 3945, 6381, 849,  3727, 647,  3315, 1055, 4572,
      5981, 1043, 5604, 2970, 3732, 3408, 6225, 3526, 4756};
  const uint16_t answ[M * N] = {
      2345, 3301, 3589, 51,   594,  1997, 1586, 3236, 1159, 2721, 1128,
      2461, 386,  396,  2912, 4174, 4466, 2563, 2090, 1799, 2961, 4452,
      2813, 3461, 1389, 1981, 642,  1351, 4105, 5468, 170,  1292, 795,
      1469, 1676, 4646, 406,  3367, 2858, 1985, 2008, 1677, 673,  20,
      4816, 1749, 2380, 3751, 3038, 849,  51,   647,  650,  1055, 4572,
      659,  358,  335,  2970, 3732, 952,  970,  3526, 2226};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mminu_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MMINU_H_MM");
}

static void test_mminu_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {264010136, 116493606, 140112533, 217245072,
                                306862698, 211361876, 306267852, 87975102,
                                293806861, 5846569,   338879270, 44448990,
                                51907200,  39182115,  298199001, 341997565};
  const uint32_t src2[M * N] = {49393853,  233046401, 372113137, 133714208,
                                79390429,  207254591, 190120792, 393787593,
                                306425538, 292798710, 35182847,  282432290,
                                399689453, 107425458, 278550297, 401750129};
  const uint32_t answ[M * N] = {49393853,  116493606, 140112533, 133714208,
                                79390429,  207254591, 190120792, 87975102,
                                293806861, 5846569,   35182847,  44448990,
                                51907200,  39182115,  278550297, 341997565};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mminu_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MMINU_MM U32");
}

static void test_mminu_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {264010136, 116493606, 140112533, 217245072,
                                306862698, 211361876, 306267852, 87975102,
                                293806861, 5846569,   338879270, 44448990,
                                51907200,  39182115,  298199001, 341997565};
  const uint32_t src2[M * N] = {49393853,  233046401, 372113137, 133714208,
                                79390429,  207254591, 190120792, 393787593,
                                306425538, 292798710, 35182847,  282432290,
                                399689453, 107425458, 278550297, 401750129};
  const uint32_t answ[M * N] = {49393853,  116493606, 140112533, 133714208,
                                79390429,  207254591, 190120792, 87975102,
                                293806861, 5846569,   35182847,  44448990,
                                51907200,  39182115,  278550297, 341997565};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mminu_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MMINU_W_MM");
}

static void test_mminu_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1341902494842413904, 1514735068420810471,
                                44683449854445694, 1107223556809643896};
  const uint64_t src2[M * N] = {495217689950732172, 1597471963114688123,
                                1664231042466279246, 1775074577584861797};
  const uint64_t answ[M * N] = {495217689950732172, 1514735068420810471,
                                44683449854445694, 1107223556809643896};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mminu_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MMINU_MM U64");
}

static void test_mminu_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1341902494842413904, 1514735068420810471,
                                44683449854445694, 1107223556809643896};
  const uint64_t src2[M * N] = {495217689950732172, 1597471963114688123,
                                1664231042466279246, 1775074577584861797};
  const uint64_t answ[M * N] = {495217689950732172, 1514735068420810471,
                                44683449854445694, 1107223556809643896};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mminu_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MMINU_DW_MM");
}

static void test_mminu_mm() {
  test_mminu_mm_u8();
  test_mminu_b_mm();
  test_mminu_mm_u16();
  test_mminu_h_mm();
  test_mminu_mm_u32();
  test_mminu_w_mm();
  test_mminu_mm_u64();
  test_mminu_dw_mm();
}

static void test_mmaxu_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      10, 22, 1,  6,  24, 1,  23, 3,  4,  24, 9,  6,  8,  23, 6, 6,
      3,  13, 1,  15, 16, 24, 0,  19, 20, 1,  3,  6,  1,  11, 3, 21,
      16, 14, 19, 3,  23, 22, 0,  0,  8,  23, 3,  2,  15, 24, 2, 12,
      4,  11, 3,  17, 2,  2,  17, 9,  5,  9,  17, 11, 15, 8,  3, 1};
  const uint8_t src2[M * N] = {
      21, 24, 7,  23, 4,  11, 20, 11, 6,  0, 11, 22, 3,  8,  21, 18,
      7,  5,  16, 1,  12, 24, 8,  11, 10, 7, 24, 7,  0,  8,  13, 9,
      2,  21, 1,  21, 15, 16, 23, 4,  16, 2, 24, 19, 12, 24, 0,  8,
      12, 11, 24, 22, 23, 13, 2,  6,  12, 4, 0,  7,  10, 7,  5,  6};
  const uint8_t answ[M * N] = {
      21, 24, 7,  23, 24, 11, 23, 11, 6,  24, 11, 22, 8,  23, 21, 18,
      7,  13, 16, 15, 16, 24, 8,  19, 20, 7,  24, 7,  1,  11, 13, 21,
      16, 21, 19, 21, 23, 22, 23, 4,  16, 23, 24, 19, 15, 24, 2,  12,
      12, 11, 24, 22, 23, 13, 17, 9,  12, 9,  17, 11, 15, 8,  5,  6};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mmaxu_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MMAXU_MM U8");
}

static void test_mmaxu_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      10, 22, 1,  6,  24, 1,  23, 3,  4,  24, 9,  6,  8,  23, 6, 6,
      3,  13, 1,  15, 16, 24, 0,  19, 20, 1,  3,  6,  1,  11, 3, 21,
      16, 14, 19, 3,  23, 22, 0,  0,  8,  23, 3,  2,  15, 24, 2, 12,
      4,  11, 3,  17, 2,  2,  17, 9,  5,  9,  17, 11, 15, 8,  3, 1};
  const uint8_t src2[M * N] = {
      21, 24, 7,  23, 4,  11, 20, 11, 6,  0, 11, 22, 3,  8,  21, 18,
      7,  5,  16, 1,  12, 24, 8,  11, 10, 7, 24, 7,  0,  8,  13, 9,
      2,  21, 1,  21, 15, 16, 23, 4,  16, 2, 24, 19, 12, 24, 0,  8,
      12, 11, 24, 22, 23, 13, 2,  6,  12, 4, 0,  7,  10, 7,  5,  6};
  const uint8_t answ[M * N] = {
      21, 24, 7,  23, 24, 11, 23, 11, 6,  24, 11, 22, 8,  23, 21, 18,
      7,  13, 16, 15, 16, 24, 8,  19, 20, 7,  24, 7,  1,  11, 13, 21,
      16, 21, 19, 21, 23, 22, 23, 4,  16, 23, 24, 19, 15, 24, 2,  12,
      12, 11, 24, 22, 23, 13, 17, 9,  12, 9,  17, 11, 15, 8,  5,  6};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mmaxu_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MMAXU_B_MM");
}

static void test_mmaxu_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      1083, 2471, 2860, 6120, 426,  5504, 2506, 5260, 4427, 1450, 6356,
      3373, 2921, 5103, 2585, 924,  3949, 4295, 6380, 2382, 4317, 2818,
      3667, 1530, 2293, 3453, 2465, 4742, 2914, 1307, 2246, 92,   383,
      3824, 650,  4618, 6354, 2921, 2185, 179,  420,  869,  3823, 3145,
      6200, 4198, 2820, 1790, 3362, 4,    2911, 3659, 1662, 4210, 167,
      2085, 584,  6072, 4742, 2811, 4906, 5573, 1565, 6395};
  const uint16_t src2[M * N] = {
      1774, 5734, 1790, 2324, 1063, 3153, 2660, 5211, 877,  5517, 1744,
      2087, 2514, 6049, 3118, 4540, 5098, 5966, 1499, 4171, 6028, 1613,
      3042, 2791, 3318, 5092, 4220, 2905, 3240, 3618, 3395, 4478, 61,
      6442, 5804, 4151, 5771, 1315, 3701, 5868, 6139, 5206, 2957, 1188,
      4280, 3512, 5875, 3518, 5877, 163,  4827, 2822, 838,  5683, 3700,
      812,  5640, 3988, 4304, 3005, 5371, 3648, 4727, 4136};
  const uint16_t answ[M * N] = {
      1774, 5734, 2860, 6120, 1063, 5504, 2660, 5260, 4427, 5517, 6356,
      3373, 2921, 6049, 3118, 4540, 5098, 5966, 6380, 4171, 6028, 2818,
      3667, 2791, 3318, 5092, 4220, 4742, 3240, 3618, 3395, 4478, 383,
      6442, 5804, 4618, 6354, 2921, 3701, 5868, 6139, 5206, 3823, 3145,
      6200, 4198, 5875, 3518, 5877, 163,  4827, 3659, 1662, 5683, 3700,
      2085, 5640, 6072, 4742, 3005, 5371, 5573, 4727, 6395};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mmaxu_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MMAXU_MM U16");
}

static void test_mmaxu_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      1083, 2471, 2860, 6120, 426,  5504, 2506, 5260, 4427, 1450, 6356,
      3373, 2921, 5103, 2585, 924,  3949, 4295, 6380, 2382, 4317, 2818,
      3667, 1530, 2293, 3453, 2465, 4742, 2914, 1307, 2246, 92,   383,
      3824, 650,  4618, 6354, 2921, 2185, 179,  420,  869,  3823, 3145,
      6200, 4198, 2820, 1790, 3362, 4,    2911, 3659, 1662, 4210, 167,
      2085, 584,  6072, 4742, 2811, 4906, 5573, 1565, 6395};
  const uint16_t src2[M * N] = {
      1774, 5734, 1790, 2324, 1063, 3153, 2660, 5211, 877,  5517, 1744,
      2087, 2514, 6049, 3118, 4540, 5098, 5966, 1499, 4171, 6028, 1613,
      3042, 2791, 3318, 5092, 4220, 2905, 3240, 3618, 3395, 4478, 61,
      6442, 5804, 4151, 5771, 1315, 3701, 5868, 6139, 5206, 2957, 1188,
      4280, 3512, 5875, 3518, 5877, 163,  4827, 2822, 838,  5683, 3700,
      812,  5640, 3988, 4304, 3005, 5371, 3648, 4727, 4136};
  const uint16_t answ[M * N] = {
      1774, 5734, 2860, 6120, 1063, 5504, 2660, 5260, 4427, 5517, 6356,
      3373, 2921, 6049, 3118, 4540, 5098, 5966, 6380, 4171, 6028, 2818,
      3667, 2791, 3318, 5092, 4220, 4742, 3240, 3618, 3395, 4478, 383,
      6442, 5804, 4618, 6354, 2921, 3701, 5868, 6139, 5206, 3823, 3145,
      6200, 4198, 5875, 3518, 5877, 163,  4827, 3659, 1662, 5683, 3700,
      2085, 5640, 6072, 4742, 3005, 5371, 5573, 4727, 6395};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mmaxu_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MMAXU_H_MM");
}

static void test_mmaxu_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {231422959, 374609018, 51126541,  358900079,
                                172193130, 222426135, 101403844, 245847666,
                                379970338, 300992446, 215898290, 4414377,
                                126967544, 415513071, 192223234, 122830545};
  const uint32_t src2[M * N] = {66083092,  22269648,  4746016,   230749072,
                                23061433,  288227119, 116095663, 196177885,
                                372547598, 76797507,  391739994, 302895960,
                                113942273, 214258672, 270537886, 86905965};
  const uint32_t answ[M * N] = {231422959, 374609018, 51126541,  358900079,
                                172193130, 288227119, 116095663, 245847666,
                                379970338, 300992446, 391739994, 302895960,
                                126967544, 415513071, 270537886, 122830545};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mmaxu_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MMAXU_MM U32");
}

static void test_mmaxu_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {231422959, 374609018, 51126541,  358900079,
                                172193130, 222426135, 101403844, 245847666,
                                379970338, 300992446, 215898290, 4414377,
                                126967544, 415513071, 192223234, 122830545};
  const uint32_t src2[M * N] = {66083092,  22269648,  4746016,   230749072,
                                23061433,  288227119, 116095663, 196177885,
                                372547598, 76797507,  391739994, 302895960,
                                113942273, 214258672, 270537886, 86905965};
  const uint32_t answ[M * N] = {231422959, 374609018, 51126541,  358900079,
                                172193130, 288227119, 116095663, 245847666,
                                379970338, 300992446, 391739994, 302895960,
                                126967544, 415513071, 270537886, 122830545};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mmaxu_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MMAXU_W_MM");
}

static void test_mmaxu_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1185483723051622264, 19916796544728724,
                                779426978221002259, 1072049607976413891};
  const uint64_t src2[M * N] = {166056514697130858, 970700692636358833,
                                1174472421112842238, 1350666476445563393};
  const uint64_t answ[M * N] = {1185483723051622264, 970700692636358833,
                                1174472421112842238, 1350666476445563393};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mmaxu_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MMAXU_MM U64");
}

static void test_mmaxu_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1185483723051622264, 19916796544728724,
                                779426978221002259, 1072049607976413891};
  const uint64_t src2[M * N] = {166056514697130858, 970700692636358833,
                                1174472421112842238, 1350666476445563393};
  const uint64_t answ[M * N] = {1185483723051622264, 970700692636358833,
                                1174472421112842238, 1350666476445563393};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mmaxu_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MMAXU_DW_MM");
}

static void test_mmaxu_mm() {
  test_mmaxu_mm_u8();
  test_mmaxu_b_mm();
  test_mmaxu_mm_u16();
  test_mmaxu_h_mm();
  test_mmaxu_mm_u32();
  test_mmaxu_w_mm();
  test_mmaxu_mm_u64();
  test_mmaxu_dw_mm();
}

static void test_mmax_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      7,   -11, 11, -10, 4,  -5, 7,   -12, -7, -9, -2, 2,   2,  -12, -9, -5,
      -11, -6,  -8, -12, 11, 3,  -10, -9,  -7, 3,  8,  -12, 3,  1,   1,  -5,
      10,  3,   0,  6,   -8, -8, 2,   -4,  8,  -2, -8, -12, -1, -10, -7, -1,
      -9,  -5,  4,  4,   11, -1, 10,  -4,  6,  4,  6,  6,   5,  -6,  -5, 7};
  const int8_t src2[M * N] = {
      -4,  0,  -1,  -10, 6,  -5, 5,  -12, 10, -7, 10,  -11, 9,   -4, 4,   -1,
      6,   7,  -10, 4,   -4, -8, 5,  -11, -2, 9,  -12, 1,   -10, -5, -10, 10,
      -4,  11, 7,   7,   10, 7,  -7, -10, -5, 1,  -1,  -1,  -6,  -1, 5,   -1,
      -10, 6,  -12, 1,   11, -7, 4,  1,   5,  4,  10,  -7,  0,   8,  4,   -5};
  const int8_t answ[M * N] = {
      7,  0,  11, -10, 6,  -5, 7,  -12, 10, -7, 10, 2,  9,  -4, 4, -1,
      6,  7,  -8, 4,   11, 3,  5,  -9,  -2, 9,  8,  1,  3,  1,  1, 10,
      10, 11, 7,  7,   10, 7,  2,  -4,  8,  1,  -1, -1, -1, -1, 5, -1,
      -9, 6,  4,  4,   11, -1, 10, 1,   6,  4,  10, 6,  5,  8,  4, 7};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmax_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMAX_MM I8");
}

static void test_mmax_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      7,   -11, 11, -10, 4,  -5, 7,   -12, -7, -9, -2, 2,   2,  -12, -9, -5,
      -11, -6,  -8, -12, 11, 3,  -10, -9,  -7, 3,  8,  -12, 3,  1,   1,  -5,
      10,  3,   0,  6,   -8, -8, 2,   -4,  8,  -2, -8, -12, -1, -10, -7, -1,
      -9,  -5,  4,  4,   11, -1, 10,  -4,  6,  4,  6,  6,   5,  -6,  -5, 7};
  const int8_t src2[M * N] = {
      -4,  0,  -1,  -10, 6,  -5, 5,  -12, 10, -7, 10,  -11, 9,   -4, 4,   -1,
      6,   7,  -10, 4,   -4, -8, 5,  -11, -2, 9,  -12, 1,   -10, -5, -10, 10,
      -4,  11, 7,   7,   10, 7,  -7, -10, -5, 1,  -1,  -1,  -6,  -1, 5,   -1,
      -10, 6,  -12, 1,   11, -7, 4,  1,   5,  4,  10,  -7,  0,   8,  4,   -5};
  const int8_t answ[M * N] = {
      7,  0,  11, -10, 6,  -5, 7,  -12, 10, -7, 10, 2,  9,  -4, 4, -1,
      6,  7,  -8, 4,   11, 3,  5,  -9,  -2, 9,  8,  1,  3,  1,  1, 10,
      10, 11, 7,  7,   10, 7,  2,  -4,  8,  1,  -1, -1, -1, -1, 5, -1,
      -9, 6,  4,  4,   11, -1, 10, 1,   6,  4,  10, 6,  5,  8,  4, 7};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmax_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMAX_B_MM");
}

static void test_mmax_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      664,   -3074, -3034, 132,   205,   2502,  2701,  -1542, 1943,  1440,
      2932,  186,   -359,  -2791, -1005, 1064,  -2255, 1132,  2368,  -699,
      1437,  -913,  815,   -2945, -1857, 2946,  1281,  -522,  2275,  -2443,
      3235,  3273,  2056,  -2258, 2906,  1127,  2947,  -1074, -980,  1356,
      -511,  -1416, -1871, -1326, 2979,  -956,  -2584, -1153, -2537, 3087,
      -168,  1664,  -206,  422,   1276,  -1395, 2831,  603,   -1241, 391,
      -1240, 1906,  2859,  1244};
  const int16_t src2[M * N] = {
      2651,  -2297, -2900, -1969, -2084, -3203, -176,  -340,  1991, -1000,
      67,    -1717, -2601, -1266, 2705,  -1966, -3185, -2730, 2559, -2175,
      -2538, -1053, -3263, -413,  2377,  1323,  1767,  803,   688,  -2139,
      486,   162,   1559,  -1184, 2470,  562,   -1484, 339,   -366, -167,
      -3233, -1328, 1144,  1004,  -2481, -1449, 1898,  -1499, 259,  -2332,
      2738,  -249,  -857,  -2137, 2757,  1183,  -1472, -2190, -75,  1730,
      -453,  -3055, -1910, -790};
  const int16_t answ[M * N] = {
      2651,  -2297, -2900, 132,   205,  2502,  2701, -340,  1991,  1440, 2932,
      186,   -359,  -1266, 2705,  1064, -2255, 1132, 2559,  -699,  1437, -913,
      815,   -413,  2377,  2946,  1767, 803,   2275, -2139, 3235,  3273, 2056,
      -1184, 2906,  1127,  2947,  339,  -366,  1356, -511,  -1328, 1144, 1004,
      2979,  -956,  1898,  -1153, 259,  3087,  2738, 1664,  -206,  422,  2757,
      1183,  2831,  603,   -75,   1730, -453,  1906, 2859,  1244};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmax_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMAX_MM I16");
}

static void test_mmax_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      664,   -3074, -3034, 132,   205,   2502,  2701,  -1542, 1943,  1440,
      2932,  186,   -359,  -2791, -1005, 1064,  -2255, 1132,  2368,  -699,
      1437,  -913,  815,   -2945, -1857, 2946,  1281,  -522,  2275,  -2443,
      3235,  3273,  2056,  -2258, 2906,  1127,  2947,  -1074, -980,  1356,
      -511,  -1416, -1871, -1326, 2979,  -956,  -2584, -1153, -2537, 3087,
      -168,  1664,  -206,  422,   1276,  -1395, 2831,  603,   -1241, 391,
      -1240, 1906,  2859,  1244};
  const int16_t src2[M * N] = {
      2651,  -2297, -2900, -1969, -2084, -3203, -176,  -340,  1991, -1000,
      67,    -1717, -2601, -1266, 2705,  -1966, -3185, -2730, 2559, -2175,
      -2538, -1053, -3263, -413,  2377,  1323,  1767,  803,   688,  -2139,
      486,   162,   1559,  -1184, 2470,  562,   -1484, 339,   -366, -167,
      -3233, -1328, 1144,  1004,  -2481, -1449, 1898,  -1499, 259,  -2332,
      2738,  -249,  -857,  -2137, 2757,  1183,  -1472, -2190, -75,  1730,
      -453,  -3055, -1910, -790};
  const int16_t answ[M * N] = {
      2651,  -2297, -2900, 132,   205,  2502,  2701, -340,  1991,  1440, 2932,
      186,   -359,  -1266, 2705,  1064, -2255, 1132, 2559,  -699,  1437, -913,
      815,   -413,  2377,  2946,  1767, 803,   2275, -2139, 3235,  3273, 2056,
      -1184, 2906,  1127,  2947,  339,  -366,  1356, -511,  -1328, 1144, 1004,
      2979,  -956,  1898,  -1153, 259,  3087,  2738, 1664,  -206,  422,  2757,
      1183,  2831,  603,   -75,   1730, -453,  1906, 2859,  1244};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmax_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMAX_H_MM");
}

static void test_mmax_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-130215949, -120366164, 209784561,  -20599385,
                               -2561725,   16871440,   -177005336, 157919704,
                               -62772510,  -104158794, 151928303,  -121557746,
                               88708152,   1036745,    -73918473,  116453587};
  const int32_t src2[M * N] = {-189944504, 47422306,   173134827, -15298065,
                               176776497,  171469212,  -76318947, -151942322,
                               -85298246,  -154028170, 93334689,  -208535252,
                               138094629,  114651020,  102484455, -80317320};
  const int32_t answ[M * N] = {-130215949, 47422306,   209784561, -15298065,
                               176776497,  171469212,  -76318947, 157919704,
                               -62772510,  -104158794, 151928303, -121557746,
                               138094629,  114651020,  102484455, 116453587};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmax_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMAX_MM I32");
}

static void test_mmax_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-130215949, -120366164, 209784561,  -20599385,
                               -2561725,   16871440,   -177005336, 157919704,
                               -62772510,  -104158794, 151928303,  -121557746,
                               88708152,   1036745,    -73918473,  116453587};
  const int32_t src2[M * N] = {-189944504, 47422306,   173134827, -15298065,
                               176776497,  171469212,  -76318947, -151942322,
                               -85298246,  -154028170, 93334689,  -208535252,
                               138094629,  114651020,  102484455, -80317320};
  const int32_t answ[M * N] = {-130215949, 47422306,   209784561, -15298065,
                               176776497,  171469212,  -76318947, 157919704,
                               -62772510,  -104158794, 151928303, -121557746,
                               138094629,  114651020,  102484455, 116453587};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmax_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMAX_W_MM");
}

static void test_mmax_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-888938352595102522, -476953976983084285,
                               766753981305140215, -531823446331321099};
  const int64_t src2[M * N] = {-469716102576308759, -346643061430341315,
                               -28992998092372506, -520655072864742672};
  const int64_t answ[M * N] = {-469716102576308759, -346643061430341315,
                               766753981305140215, -520655072864742672};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mmax_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMAX_MM I64");
}

static void test_mmax_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-888938352595102522, -476953976983084285,
                               766753981305140215, -531823446331321099};
  const int64_t src2[M * N] = {-469716102576308759, -346643061430341315,
                               -28992998092372506, -520655072864742672};
  const int64_t answ[M * N] = {-469716102576308759, -346643061430341315,
                               766753981305140215, -520655072864742672};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mmax_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMAX_DW_MM");
}

static void test_mmax_mm() {
  test_mmax_mm_i8();
  test_mmax_b_mm();
  test_mmax_mm_i16();
  test_mmax_h_mm();
  test_mmax_mm_i32();
  test_mmax_w_mm();
  test_mmax_mm_i64();
  test_mmax_dw_mm();
}

static void test_mand_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      16, 12, 10, 0,  10, 10, 12, 21, 7,  13, 5,  2,  6,  20, 1,  15,
      17, 15, 18, 2,  6,  2,  19, 22, 14, 7,  19, 4,  9,  12, 22, 21,
      0,  7,  17, 21, 8,  9,  1,  23, 6,  16, 22, 16, 21, 4,  2,  22,
      11, 12, 22, 17, 22, 12, 11, 15, 0,  14, 20, 5,  18, 16, 21, 18};
  const uint8_t src2[M * N] = {
      18, 15, 20, 14, 24, 14, 2,  1,  16, 12, 19, 17, 2, 9,  4,  18,
      17, 14, 23, 8,  4,  24, 16, 8,  9,  22, 7,  9,  8, 18, 5,  18,
      3,  20, 12, 1,  8,  13, 3,  13, 9,  2,  11, 5,  9, 18, 10, 1,
      22, 1,  8,  1,  16, 9,  7,  6,  8,  18, 5,  8,  4, 8,  12, 6};
  const uint8_t answ[M * N] = {
      16, 12, 0, 0, 8, 10, 0, 1, 0,  12, 1, 0, 2, 0, 0, 2, 17, 14, 18, 0, 4, 0,
      16, 0,  8, 6, 3, 0,  8, 0, 4,  16, 0, 4, 0, 1, 8, 9, 1,  5,  0,  0, 2, 0,
      1,  0,  2, 0, 2, 0,  0, 1, 16, 8,  3, 6, 0, 2, 4, 0, 0,  0,  4,  2};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mand_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MAND_MM U8");
}

static void test_mand_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      -11, -6,  11,  0,  -5, -4,  7,  -4,  1, -6,  4,  0,   10, 5,   -9,  -7,
      -11, -5,  10,  -3, -1, -1,  -1, 7,   0, 10,  5,  5,   7,  -7,  -10, -1,
      -4,  8,   -2,  -7, 3,  4,   3,  7,   4, -10, -7, -9,  -7, -11, 0,   9,
      9,   -12, -10, -2, 10, -11, 10, -11, 0, 8,   9,  -10, -7, 5,   7,   -10};
  const int8_t src2[M * N] = {
      2,  0,   7,   7,  2,  10,  10, -5, -5, -9, -3,  -11, 3,   -10, 11,  -11,
      -1, 8,   -9,  8,  -6, -10, 2,  0,  1,  -5, -12, 0,   -12, 11,  -4,  1,
      -9, -12, -11, -3, 9,  2,   -3, 11, -8, -3, -8,  -6,  2,   1,   -10, -10,
      6,  -1,  -6,  7,  -2, 0,   7,  -5, 2,  7,  -7,  -3,  -3,  -7,  0,   -9};
  const int8_t answ[M * N] = {
      0,   0,   3,   0,  2,  8,   2, -8,  1, -14, 4,  0,   2,  4, 3,   -15,
      -11, 8,   2,   8,  -6, -10, 2, 0,   0, 10,  4,  0,   4,  9, -12, 1,
      -12, 0,   -12, -7, 1,  0,   1, 3,   0, -12, -8, -14, 0,  1, 0,   0,
      0,   -12, -14, 6,  10, 0,   2, -15, 0, 0,   9,  -12, -7, 1, 0,   -10};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mand_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MAND_MM I8");
}

static void test_mand_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      4909, 3631, 1584, 5923, 112,  5616, 2963, 895,  1684, 1927, 4114,
      2905, 1976, 5592, 761,  4665, 5854, 738,  282,  3559, 3964, 2945,
      5351, 6079, 408,  5962, 301,  6216, 905,  3918, 5174, 4983, 160,
      3962, 2892, 474,  3117, 3965, 2046, 3630, 2664, 2273, 2253, 1041,
      6428, 1473, 1390, 3414, 917,  3987, 3520, 2857, 1855, 5824, 4680,
      567,  1276, 3996, 141,  1056, 3180, 2376, 1477, 2482};
  const uint16_t src2[M * N] = {
      2092, 2550, 2812, 6010, 2139, 5133, 224,  3138, 363,  471,  3518,
      3057, 5394, 1347, 2857, 3533, 1193, 3906, 4117, 5846, 5326, 2359,
      2164, 5695, 3069, 3638, 5826, 1089, 2189, 5479, 512,  4086, 5484,
      643,  1177, 652,  5655, 1824, 5119, 4914, 1587, 6027, 4249, 6255,
      2691, 1027, 3425, 4528, 4194, 1862, 1966, 206,  6534, 279,  2214,
      596,  3561, 2973, 5263, 271,  324,  3009, 1698, 1040};
  const uint16_t answ[M * N] = {
      44,   2086, 560,  5922, 80,   5120, 128,  66,   0,    391,  18,
      2897, 1296, 1344, 553,  9,    1160, 578,  16,   1222, 1100, 2305,
      100,  5695, 408,  1538, 0,    64,   137,  1350, 0,    886,  32,
      514,  8,    136,  1029, 1824, 1022, 546,  544,  129,  137,  1,
      2048, 1025, 1376, 272,  0,    1794, 1408, 8,    262,  0,    0,
      532,  1256, 2972, 141,  0,    68,   2368, 1152, 16};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mand_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MAND_MM U16");
}

static void test_mand_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      3073,  -311,  -705, 1365,  -2257, -3043, -1991, -2780, -492,  2113,
      1162,  -795,  827,  -1780, 2479,  -3065, -1201, 530,   2677,  -1404,
      523,   303,   3083, 185,   -3099, -1887, -1048, -2822, 2588,  1098,
      2964,  -1822, -30,  -169,  -1969, 27,    2289,  -468,  1080,  -2268,
      -1851, -1964, 34,   -2983, -222,  1415,  -2967, 305,   -2575, -2954,
      212,   -848,  1526, -1064, -631,  2407,  -2022, -2600, 1535,  -758,
      3091,  -3197, -117, -1562};
  const int16_t src2[M * N] = {
      -324,  -1619, -1618, -1092, 2051, 1295,  -1033, 2146, 1166,  -2783,
      -2112, 2185,  620,   -750,  -339, 89,    2649,  -513, -3224, -526,
      319,   1559,  -1755, -1171, 1779, -1461, 297,   1456, 47,    330,
      -421,  -3016, -619,  -1389, 1717, -3172, -1200, 1084, -1443, -2736,
      -1885, 1592,  -237,  1540,  1534, -446,  1452,  -196, 2600,  953,
      923,   422,   12,    3094,  1753, -989,  -3125, 983,  148,   -2988,
      -1411, -986,  -691,  -3234};
  const int16_t answ[M * N] = {
      3072,  -1911, -1746, 276,   3,     1037, -1999, 32,    1028,  1,     1152,
      2177,  552,   -1792, 2221,  1,     2633, 18,    608,   -1920, 11,    7,
      2049,  41,    737,   -2047, 296,   1200, 12,    74,    2576,  -4064, -640,
      -1517, 5,     24,    2128,  1068,  24,   -2816, -1919, 16,    2,     1024,
      1314,  1026,  1064,  304,   32,    48,   144,   160,   4,     2064,  1161,
      2083,  -4086, 464,   148,   -3072, 2065, -4094, -759,  -3770};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mand_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MAND_MM I16");
}

static void test_mand_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {1253, 268,  2585, 2435, 4935, 2662, 2330, 313,
                                5458, 4796, 2480, 4715, 1616, 4078, 3123, 2444};
  const uint32_t src2[M * N] = {757,  944,  2686, 3410, 2619, 610, 5424, 6076,
                                5947, 3475, 4893, 6124, 2492, 571, 4977, 216};
  const uint32_t answ[M * N] = {229,  256, 2584, 2306, 515, 610, 272, 312,
                                5394, 144, 272,  4712, 16,  554, 49,  136};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mand_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MAND_MM U32");
}

static void test_mand_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {170110439,  156002916, 6758560,    98009563,
                               163375899,  42124172,  -109945876, 119117538,
                               -209241968, 19513656,  134384066,  -158074358,
                               16416289,   123197499, -195381014, 209983507};
  const int32_t src2[M * N] = {75696662,  -104770213, -145501407, -42231268,
                               -91458289, 173986126,  -133672041, 44996430,
                               -94638072, -68775054,  112936750,  -103735477,
                               -53791845, 125336455,  103323780,  136789014};
  const int32_t answ[M * N] = {198662,     155205696, 4390944,    89358360,
                               143417611,  33734924,  -134196348, 34117186,
                               -234672128, 18907440,  131330,     -258926070,
                               13251073,   122705923, 67672192,   134486034};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mand_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MAND_MM I32");
}

static void test_mand_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {1029513490390203805, 1287649054194168321,
                                1812379475916795153, 1323277260508975930};
  const uint64_t src2[M * N] = {923770284492336557, 546177917061275525,
                                773370903329922548, 1268357709146725249};
  const uint64_t answ[M * N] = {883127741781257613, 113753179809124865,
                                586189803022322960, 1159703877680960256};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mand_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MAND_MM U64");
}

static void test_mand_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-443949526672155440, -715060784313987829,
                               -586444165191415703, 790647071882455223};
  const int64_t src2[M * N] = {30275554730322709, -404831430300165004,
                               -43898777805173649, 196562746155578228};
  const int64_t answ[M * N] = {18724961724139536, -1008357711458137088,
                               -629369238745233303, 195994830940250164};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mand_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MAND_MM I64");
}

static void test_mand_mm() {
  test_mand_mm_u8();
  test_mand_mm_i8();
  test_mand_mm_u16();
  test_mand_mm_i16();
  test_mand_mm_u32();
  test_mand_mm_i32();
  test_mand_mm_u64();
  test_mand_mm_i64();
}

static void test_mor_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      18, 3,  23, 1,  17, 10, 19, 23, 16, 16, 16, 13, 11, 15, 9,  20,
      14, 9,  23, 13, 1,  4,  5,  13, 16, 1,  8,  13, 24, 8,  9,  9,
      6,  7,  9,  13, 24, 8,  21, 12, 17, 5,  0,  7,  21, 20, 4,  8,
      12, 21, 14, 16, 23, 9,  19, 10, 8,  14, 10, 17, 9,  20, 21, 0};
  const uint8_t src2[M * N] = {
      11, 20, 23, 4,  18, 20, 18, 21, 21, 21, 1,  4,  13, 2,  11, 0,
      9,  14, 5,  23, 6,  12, 4,  8,  12, 5,  12, 22, 12, 19, 24, 16,
      11, 0,  2,  14, 3,  17, 13, 21, 24, 11, 9,  7,  7,  4,  1,  8,
      4,  24, 13, 15, 24, 13, 20, 20, 5,  4,  24, 3,  23, 9,  13, 8};
  const uint8_t answ[M * N] = {
      27, 23, 23, 5,  19, 30, 19, 23, 21, 21, 17, 13, 15, 15, 11, 20,
      15, 15, 23, 31, 7,  12, 5,  13, 28, 5,  12, 31, 28, 27, 25, 25,
      15, 7,  11, 15, 27, 25, 29, 29, 25, 15, 9,  7,  23, 20, 5,  8,
      12, 29, 15, 31, 31, 13, 23, 30, 13, 14, 26, 19, 31, 29, 29, 8};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mor_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MOR_MM U8");
}

static void test_mor_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      8,  1,  -1,  -7, 7,  -4, 9,  3,   -2, -4,  9,   9,  4, -6, 7,   6,
      7,  -7, 5,   -1, 3,  -6, 0,  -11, -2, -11, -5,  -7, 7, 3,  5,   -1,
      -7, -7, -10, -6, -1, -7, 4,  7,   -2, -6,  7,   -6, 4, -4, 9,   -8,
      -8, 2,  1,   2,  1,  10, -4, -8,  -7, -1,  -10, -9, 3, 1,  -11, -9};
  const int8_t src2[M * N] = {
      -8, -9, 7,  8,   3,  4,   5,   10,  8,  0,   2,   -1,  1,  -8, -6,  1,
      10, -3, -3, -12, 2,  5,   -11, -6,  0,  10,  8,   -10, 10, 10, -11, -10,
      -7, -2, -7, -11, -2, -2,  7,   -7,  0,  -11, -11, 11,  11, 3,  -2,  -3,
      -4, -1, -5, -2,  -2, -12, -11, -11, -8, -9,  -8,  1,   6,  -8, 8,   3};
  const int8_t answ[M * N] = {
      -8, -9, -1, -7, 7,  -4, 13,  11, -2, -4, 11, -1, 5,  -6, -1,  7,
      15, -3, -3, -1, 3,  -1, -11, -1, -2, -1, -5, -1, 15, 11, -11, -1,
      -7, -1, -1, -1, -1, -1, 7,   -1, -2, -1, -9, -5, 15, -1, -1,  -3,
      -4, -1, -5, -2, -1, -2, -3,  -3, -7, -1, -2, -9, 7,  -7, -3,  -9};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mor_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MOR_MM I8");
}

static void test_mor_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      4615, 6288, 2422, 1421, 3163, 5888, 5737, 5788, 5903, 3812, 2789,
      5873, 714,  3006, 5967, 1441, 1329, 584,  176,  5212, 1702, 3094,
      2602, 798,  1500, 2269, 713,  3852, 532,  933,  3918, 1985, 3604,
      912,  1960, 2380, 5454, 3308, 348,  6381, 5846, 1288, 1860, 519,
      6054, 3523, 6430, 2800, 1475, 4736, 652,  5436, 4121, 4686, 1600,
      4723, 4805, 5140, 2543, 6380, 4658, 6041, 1384, 5401};
  const uint16_t src2[M * N] = {
      5286, 5700, 1303, 3781, 6531, 4365, 4731, 981,  85,   5801, 2662,
      2226, 3570, 2347, 1070, 2981, 6360, 1656, 5633, 6084, 409,  5423,
      2057, 4672, 3557, 5695, 5370, 4194, 521,  3420, 1154, 6486, 3953,
      1629, 2588, 1268, 3429, 6223, 4131, 5135, 3413, 148,  4222, 5301,
      5748, 2209, 793,  4772, 1374, 883,  2385, 940,  2461, 2481, 5218,
      2237, 91,   5765, 649,  3175, 1021, 560,  5505, 5617};
  const uint16_t answ[M * N] = {
      5799, 7892, 3447, 4045, 7643, 5901, 5755, 6109, 5983, 7917, 2791,
      7923, 4090, 3007, 5999, 4005, 7673, 1656, 5809, 6108, 1983, 7487,
      2603, 4958, 3581, 7935, 5883, 8046, 541,  4093, 4046, 8151, 3957,
      2013, 4028, 3580, 7535, 7407, 4479, 7407, 8151, 1436, 6014, 5815,
      6134, 3555, 6943, 6900, 1503, 5107, 3037, 6076, 6557, 7167, 5730,
      6911, 4831, 5781, 3055, 7407, 5119, 6073, 5609, 5625};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mor_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MOR_MM U16");
}

static void test_mor_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      421,   -1173, 885,   -2863, -953,  -1754, -3158, -594,  -705,  -2723,
      -331,  -2626, 377,   1548,  2155,  -819,  84,    -1013, -1261, 1005,
      2294,  1951,  2028,  -2681, 292,   2508,  48,    610,   2,     2651,
      -1622, 828,   -2561, -2205, 2205,  -1164, -3250, 2047,  2556,  -2873,
      -2479, -2635, 992,   -106,  2290,  -1600, -2090, 3189,  -1974, -1898,
      -202,  653,   -2801, -1894, -2430, 2908,  2997,  -2755, -2467, -2494,
      -17,   1823,  -2200, 1256};
  const int16_t src2[M * N] = {
      -3076, -2057, 2887,  2762,  -2803, 280,   405,   -961,  -2368, -2498,
      289,   -2771, 962,   -411,  -2430, -725,  -2650, 857,   -2591, -1124,
      1172,  283,   959,   -2885, -1693, -2352, 1941,  261,   312,   -3270,
      -2210, 411,   -1805, -2779, -114,  2633,  -1116, -2873, 647,   -2927,
      849,   99,    -2002, 473,   -2563, -369,  2676,  -1642, -2197, -1241,
      3275,  1793,  -2542, 2626,  -2375, 2979,  -680,  -58,   -2339, 208,
      3196,  250,   -1894, 1159};
  const int16_t answ[M * N] = {
      -3075, -1,    2935,  -293,  -689,  -1730, -3137, -577,  -1,    -2177,
      -75,   -2625, 1019,  -403,  -277,  -529,  -2570, -165,  -13,   -1027,
      3318,  1951,  2047,  -2625, -1689, -36,   1973,  871,   314,   -1157,
      -2,    959,   -513,  -2201, -97,   -1155, -1042, -2049, 3071,  -2857,
      -2223, -2569, -1042, -33,   -513,  -49,   -10,   -521,  -149,  -1097,
      -1,    1933,  -2273, -1318, -2373, 3071,  -3,    -1,    -2339, -2350,
      -1,    2047,  -6,    1263};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mor_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MOR_MM I16");
}

static void test_mor_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {165598846, 212885983, 210014968, 273472862,
                                400024116, 215691639, 235187829, 78991858,
                                252278529, 368515938, 7404532,   12355912,
                                137714959, 380570773, 127467926, 309102200};
  const uint32_t src2[M * N] = {137344682, 119026535, 288001151, 131179769,
                                63826616,  362278514, 237211598, 274316653,
                                131673700, 187567113, 11524859,  55569895,
                                353035926, 174381041, 351943520, 256873332};
  const uint32_t answ[M * N] = {167769854, 263746559, 497983231, 400424447,
                                400550588, 501219191, 237481983, 352189951,
                                265912165, 536813419, 16776191,  67104239,
                                490733471, 519036917, 402340854, 527406972};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mor_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MOR_MM U32");
}

static void test_mor_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {104281840, -204053983, -104322749, 165686989,
                               44721863,  42906178,   -170978879, -179387582,
                               63822330,  41435753,   -74075797,  153350502,
                               151534294, 117848195,  105868377,  206203242};
  const int32_t src2[M * N] = {28352535,  136273675, -191357988, -120866438,
                               -32286822, 43121772,  154107828,  -8466260,
                               74317441,  53353834,  -170831428, -114158866,
                               179787786, -83458541, 153153068,  -57233840};
  const int32_t answ[M * N] = {129480439, -69238997, -36160545, -101990401,
                               -21268513, 44039790,  -34635787, -8465426,
                               133038075, 58613611,  -2756097,  -114035730,
                               197098206, -16335213, 258993789, -52498566};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mor_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MOR_MM I32");
}

static void test_mor_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {558905724212920993, 1380024887024326790,
                                197823010276954633, 1345671003491864603};
  const uint64_t src2[M * N] = {1589633706568729239, 826425112586021575,
                                831857207647186004, 403198148345342984};
  const uint64_t answ[M * N] = {1715770232421008055, 1981264234464344775,
                                846641527856627293, 1710517617677909019};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mor_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MOR_MM U64");
}

static void test_mor_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {134880616256258904, 374834722990205359,
                               -331547951068204671, -58754433777009356};
  const int64_t src2[M * N] = {261004467520321043, -554944602868880516,
                               624859584911258937, -861627682570569537};
  const int64_t answ[M * N] = {279072813235500891, -180145136213496833,
                               -292739475489802823, -58578443163533889};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mor_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MOR_MM I64");
}

static void test_mor_mm() {
  test_mor_mm_u8();
  test_mor_mm_i8();
  test_mor_mm_u16();
  test_mor_mm_i16();
  test_mor_mm_u32();
  test_mor_mm_i32();
  test_mor_mm_u64();
  test_mor_mm_i64();
}

static void test_mxor_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      1,  19, 13, 18, 16, 9,  16, 14, 3,  23, 1,  16, 21, 18, 19, 8,
      19, 14, 11, 12, 13, 4,  5,  10, 21, 0,  23, 4,  4,  13, 9,  6,
      1,  6,  16, 6,  17, 10, 6,  5,  16, 6,  2,  21, 2,  3,  3,  13,
      5,  5,  10, 19, 7,  2,  10, 9,  15, 13, 7,  6,  24, 3,  17, 17};
  const uint8_t src2[M * N] = {
      22, 9,  16, 16, 13, 0,  20, 5,  14, 15, 2,  14, 24, 8,  11, 21,
      11, 12, 7,  9,  6,  20, 0,  20, 12, 21, 15, 7,  17, 21, 15, 8,
      6,  2,  12, 16, 24, 4,  19, 21, 5,  8,  7,  5,  22, 16, 12, 19,
      12, 2,  11, 23, 0,  23, 13, 8,  9,  15, 20, 16, 22, 9,  4,  22};
  const uint8_t answ[M * N] = {
      23, 26, 29, 2,  29, 9,  4,  11, 13, 24, 3,  30, 13, 26, 24, 29,
      24, 2,  12, 5,  11, 16, 5,  30, 25, 21, 24, 3,  21, 24, 6,  14,
      7,  4,  28, 22, 9,  14, 21, 16, 21, 14, 5,  16, 20, 19, 15, 30,
      9,  7,  1,  4,  7,  21, 7,  1,  6,  2,  19, 22, 14, 10, 21, 7};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mxor_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MXOR_MM U8");
}

static void test_mxor_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      -1, -7,  -8,  3,  -1,  1, -3, 6,  7,  -1, -1, 3,  -4, 9,  -12, -11,
      -9, -5,  -12, 7,  -8,  5, 7,  6,  8,  -9, -8, 7,  5,  5,  8,   -2,
      11, -11, -6,  -2, 4,   1, -9, 0,  10, 4,  -2, -6, -1, 0,  -12, 9,
      9,  -6,  4,   5,  -11, 8, 3,  -8, 3,  6,  -9, -4, -5, -4, -4,  -4};
  const int8_t src2[M * N] = {
      9,  6,  8, 11, 7,  5,   -5, -10, -5, -6, 10,  -4, -8, 5,  -6, -1,
      7,  1,  5, -7, -6, 7,   3,  -10, 3,  -4, -9,  -3, -1, -6, 10, -3,
      2,  -5, 0, -6, 6,  -10, 7,  -4,  0,  -7, -12, -7, 4,  -6, -2, 5,
      -3, 8,  8, 4,  0,  -10, -3, -12, 2,  -3, -7,  2,  -1, 3,  -5, -9};
  const int8_t answ[M * N] = {
      -10, -1,  -16, 8,  -8,  4,  6,   -16, -4, 5,  -11, -1, 4,  12, 14, 10,
      -16, -6,  -15, -2, 2,   2,  4,   -16, 11, 11, 15,  -6, -6, -1, 2,  3,
      9,   14,  -6,  4,  2,   -9, -16, -4,  10, -3, 10,  3,  -5, -6, 10, 12,
      -12, -14, 12,  1,  -11, -2, -2,  12,  1,  -5, 14,  -2, 4,  -1, 7,  11};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mxor_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MXOR_MM I8");
}

static void test_mxor_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      629,  3232, 6362, 3561, 1146, 5491, 969,  3043, 2863, 6286, 4708,
      1609, 4962, 1450, 870,  6253, 3955, 3258, 101,  1870, 6395, 4279,
      5467, 672,  5900, 1391, 6444, 5075, 1077, 4902, 5645, 1030, 2720,
      1794, 3022, 3728, 3775, 715,  2586, 4553, 2665, 4289, 2474, 3167,
      6128, 6375, 1859, 2877, 2616, 5297, 5547, 2564, 2534, 3557, 6524,
      284,  5045, 4546, 4579, 1794, 3920, 1750, 6535, 627};
  const uint16_t src2[M * N] = {
      1273, 6150, 5291, 3448, 3765, 1903, 6032, 5369, 4693, 6109, 4917,
      4107, 1862, 6223, 359,  1827, 262,  1082, 2279, 5044, 2424, 4476,
      5287, 2902, 5239, 97,   2850, 1898, 6539, 1059, 4122, 132,  4018,
      995,  5813, 1520, 1691, 2747, 1070, 5441, 3840, 3107, 4548, 2949,
      2790, 3513, 3899, 3630, 2848, 3556, 2411, 5217, 2292, 5379, 2052,
      5388, 3073, 3265, 2185, 5769, 795,  2513, 1920, 1426};
  const uint16_t answ[M * N] = {
      1676, 5286, 3185, 145,  2767, 4636, 5209, 7962, 6522, 3923, 337,
      5698, 5156, 7653, 513,  8014, 3701, 2176, 2178, 5370, 4483, 459,
      508,  2550, 891,  1294, 4622, 5305, 7614, 5893, 1559, 1154, 1298,
      1249, 7547, 2912, 2084, 2160, 3636, 1160, 1385, 7394, 6254, 2010,
      7446, 5470, 2168, 1299, 280,  6485, 7360, 7781, 274,  6374, 4472,
      5136, 8116, 7427, 6506, 4491, 3147, 3847, 7687, 2017};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mxor_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MXOR_MM U16");
}

static void test_mxor_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      -838,  3076,  452,   2638,  36,    -2455, 2983,  -1848, 2459,  -573,
      -2505, -3018, 1204,  -1637, -2707, -333,  47,    -2537, 2369,  2169,
      -2096, 673,   -54,   3011,  -2549, -2287, -1200, -1114, -288,  1687,
      2973,  -1291, -2147, 1580,  -358,  -1733, 3117,  -2434, -2144, 3273,
      -1088, 2323,  -1052, -1030, -2044, 298,   2957,  -482,  -3041, -1963,
      2769,  -496,  -1549, 1788,  1886,  2764,  2318,  -2585, 1378,  254,
      -2982, -266,  -2271, -1368};
  const int16_t src2[M * N] = {
      1138,  -1072, -2059, 2582,  -2949, 2442,  2788,  -1375, -1663, 173,
      -2896, 1566,  1809,  -1659, 144,   1489,  -1205, -972,  3131,  -2948,
      -783,  2836,  2924,  1735,  2756,  -2642, -638,  -215,  2612,  -952,
      3160,  2341,  -1824, 906,   391,   901,   2792,  3163,  1259,  -674,
      2713,  -2630, -2672, -687,  -6,    2701,  1311,  81,    -2931, 731,
      483,   2150,  26,    -3197, -1921, -2925, -1374, 829,   1049,  2791,
      -2244, -2371, 271,   -2746};
  const int16_t answ[M * N] = {
      -1848, -2092, -2511, 88,    -2977, -29,   323,   617,   -4070, -658,
      647,   -3544, 933,   30,    -2563, -1182, -1180, 2595,  1402,  -1019,
      2849,  2485,  -2906, 3332,  -817,  703,   1746,  1167,  -2860, -1313,
      1989,  -3120, 3965,  1446,  -227,  -1346, 1733,  -1499, -3253, -3689,
      -3751, -855,  3700,  1707,  2046,  2983,  3730,  -433,  146,   -1394,
      2866,  -2442, -1559, -2689, -223,  -417,  -3156, -2342, 379,   2585,
      870,   2123,  -2514, 4078};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mxor_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MXOR_MM I16");
}

static void test_mxor_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {401099513, 354567296, 207764350, 164888402,
                                31570918,  256458499, 388647267, 99682578,
                                71139593,  365242101, 123997763, 216863466,
                                114346672, 330252826, 405623348, 63484021};
  const uint32_t src2[M * N] = {365185634, 22244807,  247935991, 368069873,
                                298407713, 350239296, 339455723, 405831760,
                                224735273, 107247360, 184819033, 69691843,
                                15909947,  144689911, 291736649, 221746814};
  const uint32_t answ[M * N] = {36438171,  342960455, 44370057,  472101795,
                                271117511, 464061763, 51505032,  499222850,
                                156807456, 329339381, 207622938, 147487529,
                                102895243, 456165613, 156163709, 251602443};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mxor_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MXOR_MM U32");
}

static void test_mxor_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {144630861, 72857718, -118549720, 48079892,
                               70158249,  33874503, -50223859,  -93878630,
                               -71833427, 7221542,  88984551,   208476995,
                               190919947, 60997554, 49665369,   -62395030};
  const int32_t src2[M * N] = {-59092121,  142550555, 141198744,  195088303,
                               -174752094, 74636591,  -176723782, -92135393,
                               -172649639, 172426787, 158959008,  -195456570,
                               -88990043,  204691978, 26062089,   -148513040};
  const int32_t answ[M * N] = {-186337494, 203988589, -259680592, 159214523,
                               -239339253, 108412776, 142003639,  15050373,
                               235043828,  170473221, 204754503,  -130774395,
                               -237818962, 261219768, 58226768,   190985114};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mxor_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MXOR_MM I32");
}

static void test_mxor_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {-531840691167898586, -425326518053255426,
                                -915831912105737483, 887345274554720638};
  const uint64_t src2[M * N] = {-282125413448120063, 727049753386834870,
                                363176959426517684, -162537732826738489};
  const uint64_t answ[M * N] = {327414616529722663, -1148963060794679992,
                                -702548075708557247, -1013601181937208903};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mxor_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MXOR_MM U64");
}

static void test_mxor_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {640632674313670124, 798285614749485697,
                               1320464842106765954, 247512414740866170};
  const int64_t src2[M * N] = {1498739391941140770, 262384555056131616,
                               644952248298984948, 447650077975143560};
  const int64_t answ[M * N] = {2030960208900058318, 626063936652436641,
                               1918655899448760182, 385348473526059250};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mxor_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MXOR_MM I64");
}

static void test_mxor_mm() {
  test_mxor_mm_u8();
  test_mxor_mm_i8();
  test_mxor_mm_u16();
  test_mxor_mm_i16();
  test_mxor_mm_u32();
  test_mxor_mm_i32();
  test_mxor_mm_u64();
  test_mxor_mm_i64();
}

static void test_msll_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      0,  0,  0,  -1, -1, 0,  -1, 0,  -1, -1, -1, 0,  -1, 0,  -1, -1,
      0,  0,  -1, 0,  0,  -1, -1, -1, -1, -1, -1, -1, 0,  0,  -1, -1,
      -1, -1, 0,  0,  0,  -1, 0,  -1, 0,  -1, 0,  -1, -1, -1, 0,  -1,
      0,  -1, -1, -1, -1, -1, 0,  -1, -1, -1, -1, 0,  -1, 0,  0,  0};
  const int8_t src2[M * N] = {1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0,
                              0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0,
                              1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0,
                              1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0};
  const int8_t answ[M * N] = {
      0,  0,  0,  -1, -2, 0,  -1, 0,  -1, -1, -2, 0,  -2, 0,  -2, -1,
      0,  0,  -1, 0,  0,  -1, -1, -1, -2, -1, -2, -2, 0,  0,  -2, -1,
      -2, -2, 0,  0,  0,  -2, 0,  -2, 0,  -1, 0,  -1, -1, -1, 0,  -1,
      0,  -2, -2, -2, -1, -2, 0,  -1, -2, -2, -2, 0,  -2, 0,  0,  0};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msll_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSLL_MM I8");
}

static void test_msll_b_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      0,  0,  0,  -1, -1, 0,  -1, 0,  -1, -1, -1, 0,  -1, 0,  -1, -1,
      0,  0,  -1, 0,  0,  -1, -1, -1, -1, -1, -1, -1, 0,  0,  -1, -1,
      -1, -1, 0,  0,  0,  -1, 0,  -1, 0,  -1, 0,  -1, -1, -1, 0,  -1,
      0,  -1, -1, -1, -1, -1, 0,  -1, -1, -1, -1, 0,  -1, 0,  0,  0};
  const int8_t src2[M * N] = {1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0,
                              0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0,
                              1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0,
                              1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0};
  const int8_t answ[M * N] = {
      0,  0,  0,  -1, -2, 0,  -1, 0,  -1, -1, -2, 0,  -2, 0,  -2, -1,
      0,  0,  -1, 0,  0,  -1, -1, -1, -2, -1, -2, -2, 0,  0,  -2, -1,
      -2, -2, 0,  0,  0,  -2, 0,  -2, 0,  -1, 0,  -1, -1, -1, 0,  -1,
      0,  -2, -2, -2, -1, -2, 0,  -1, -2, -2, -2, 0,  -2, 0,  0,  0};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msll_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSLL_B_MM");
}

static void test_msll_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      313,  -307, -290, 294,  47,   192,  190, -281, 297,  232,  -220,
      247,  -31,  262,  35,   -75,  -3,   266, -229, -220, 19,   -266,
      -226, -38,  283,  -188, 205,  -108, 0,   274,  289,  -47,  46,
      -313, -326, -62,  113,  260,  -259, 133, 184,  -303, -121, 25,
      59,   -319, -298, -134, -296, -214, 168, 71,   274,  -129, 88,
      323,  -139, -256, 110,  -79,  257,  10,  151,  31};
  const int16_t src2[M * N] = {0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
                               0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1,
                               1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1,
                               1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1};
  const int16_t answ[M * N] = {
      313,  -614, -580, 294,  94,   384,  380, -281, 297,  464,  -220,
      494,  -62,  262,  35,   -150, -3,   266, -229, -220, 19,   -266,
      -452, -76,  283,  -188, 205,  -216, 0,   548,  578,  -94,  92,
      -626, -326, -62,  226,  260,  -518, 133, 368,  -606, -242, 25,
      118,  -638, -596, -268, -592, -428, 336, 142,  274,  -258, 88,
      323,  -278, -256, 220,  -158, 514,  10,  151,  62};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msll_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSLL_MM I16");
}

static void test_msll_h_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      313,  -307, -290, 294,  47,   192,  190, -281, 297,  232,  -220,
      247,  -31,  262,  35,   -75,  -3,   266, -229, -220, 19,   -266,
      -226, -38,  283,  -188, 205,  -108, 0,   274,  289,  -47,  46,
      -313, -326, -62,  113,  260,  -259, 133, 184,  -303, -121, 25,
      59,   -319, -298, -134, -296, -214, 168, 71,   274,  -129, 88,
      323,  -139, -256, 110,  -79,  257,  10,  151,  31};
  const int16_t src2[M * N] = {0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
                               0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1,
                               1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1,
                               1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1};
  const int16_t answ[M * N] = {
      313,  -614, -580, 294,  94,   384,  380, -281, 297,  464,  -220,
      494,  -62,  262,  35,   -150, -3,   266, -229, -220, 19,   -266,
      -452, -76,  283,  -188, 205,  -216, 0,   548,  578,  -94,  92,
      -626, -326, -62,  226,  260,  -518, 133, 368,  -606, -242, 25,
      118,  -638, -596, -268, -592, -428, 336, 142,  274,  -258, 88,
      323,  -278, -256, 220,  -158, 514,  10,  151,  62};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msll_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSLL_H_MM I16");
}

static void test_msll_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-20394446, 19448926,  -15247387, 16737269,
                               -12757892, 14018200,  -12089174, -12201656,
                               -3180972,  18162650,  12004797,  5085594,
                               -17933391, -14704926, -3399679,  -16494258};
  const int32_t src2[M * N] = {0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0};
  const int32_t answ[M * N] = {-20394446, 38897852,  -15247387, 33474538,
                               -12757892, 14018200,  -24178348, -24403312,
                               -6361944,  18162650,  24009594,  10171188,
                               -17933391, -29409852, -6799358,  -16494258};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msll_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSLL_MM I32");
}

static void test_msll_w_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {-20394446, 19448926,  -15247387, 16737269,
                               -12757892, 14018200,  -12089174, -12201656,
                               -3180972,  18162650,  12004797,  5085594,
                               -17933391, -14704926, -3399679,  -16494258};
  const int32_t src2[M * N] = {0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0};
  const int32_t answ[M * N] = {-20394446, 38897852,  -15247387, 33474538,
                               -12757892, 14018200,  -24178348, -24403312,
                               -6361944,  18162650,  24009594,  10171188,
                               -17933391, -29409852, -6799358,  -16494258};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msll_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSLL_W_MM");
}

static void test_msll_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-75636344694223969, -5957598251044401,
                               19257260156462169, 31457021164404570};
  const int64_t src2[M * N] = {1, 0, 0, 1};
  const int64_t answ[M * N] = {-151272689388447938, -5957598251044401,
                               19257260156462169, 62914042328809140};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msll_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSLL_MM I64");
}

static void test_msll_dw_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {-75636344694223969, -5957598251044401,
                               19257260156462169, 31457021164404570};
  const int64_t src2[M * N] = {1, 0, 0, 1};
  const int64_t answ[M * N] = {-151272689388447938, -5957598251044401,
                               19257260156462169, 62914042328809140};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msll_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSLL_DW_MM");
}

static void test_msll_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1,
                               1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0,
                               1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1,
                               1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};
  const uint8_t src2[M * N] = {0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0,
                               1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0,
                               1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1,
                               0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0};
  const uint8_t answ[M * N] = {1, 0, 1, 2, 1, 0, 0, 0, 2, 0, 1, 0, 1, 2, 2, 1,
                               2, 0, 2, 0, 1, 0, 0, 1, 1, 0, 2, 0, 1, 2, 0, 0,
                               2, 1, 1, 0, 1, 0, 2, 1, 2, 0, 0, 1, 0, 2, 0, 2,
                               1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msll_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSLL_MM U8");
}

static void test_msll_b_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1,
                               1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0,
                               1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1,
                               1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};
  const uint8_t src2[M * N] = {0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0,
                               1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0,
                               1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1,
                               0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0};
  const uint8_t answ[M * N] = {1, 0, 1, 2, 1, 0, 0, 0, 2, 0, 1, 0, 1, 2, 2, 1,
                               2, 0, 2, 0, 1, 0, 0, 1, 1, 0, 2, 0, 1, 2, 0, 0,
                               2, 1, 1, 0, 1, 0, 2, 1, 2, 0, 0, 1, 0, 2, 0, 2,
                               1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msll_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSLL_B_MM");
}

static void test_msll_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      53,  234, 409, 605, 390, 319, 425, 410, 524, 600, 163, 331, 431,
      125, 122, 489, 363, 514, 457, 289, 627, 400, 81,  55,  223, 428,
      264, 608, 397, 571, 635, 600, 581, 154, 43,  62,  553, 444, 444,
      358, 423, 115, 487, 140, 62,  633, 483, 238, 496, 202, 281, 482,
      598, 1,   340, 265, 231, 258, 436, 630, 293, 402, 582, 7};
  const uint16_t src2[M * N] = {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1,
                                1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1,
                                1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
                                1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0};
  const uint16_t answ[M * N] = {
      106, 234, 409, 1210, 780, 638,  850,  820,  1048, 600, 163,  331, 431,
      125, 122, 978, 726,  514, 914,  578,  627,  400,  162, 55,   223, 428,
      528, 608, 794, 1142, 635, 1200, 1162, 154,  86,   62,  1106, 888, 444,
      716, 423, 115, 487,  140, 62,   1266, 483,  238,  992, 404,  562, 482,
      598, 2,   680, 265,  462, 516,  436,  1260, 293,  804, 1164, 7};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msll_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSLL_MM U16");
}

static void test_msll_h_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      53,  234, 409, 605, 390, 319, 425, 410, 524, 600, 163, 331, 431,
      125, 122, 489, 363, 514, 457, 289, 627, 400, 81,  55,  223, 428,
      264, 608, 397, 571, 635, 600, 581, 154, 43,  62,  553, 444, 444,
      358, 423, 115, 487, 140, 62,  633, 483, 238, 496, 202, 281, 482,
      598, 1,   340, 265, 231, 258, 436, 630, 293, 402, 582, 7};
  const uint16_t src2[M * N] = {1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1,
                                1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1,
                                1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,
                                1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0};
  const uint16_t answ[M * N] = {
      106, 234, 409, 1210, 780, 638,  850,  820,  1048, 600, 163,  331, 431,
      125, 122, 978, 726,  514, 914,  578,  627,  400,  162, 55,   223, 428,
      528, 608, 794, 1142, 635, 1200, 1162, 154,  86,   62,  1106, 888, 444,
      716, 423, 115, 487,  140, 62,   1266, 483,  238,  992, 404,  562, 482,
      598, 2,   680, 265,  462, 516,  436,  1260, 293,  804, 1164, 7};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msll_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSLL_H_MM");
}

static void test_msll_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {26757936, 29920127, 13210151, 24737200,
                                23080283, 8348709,  37523407, 29375877,
                                31506984, 36690716, 28265727, 42319672,
                                4375734,  32025357, 41864778, 31127499};
  const uint32_t src2[M * N] = {1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0};
  const uint32_t answ[M * N] = {53515872, 29920127, 26420302, 49474400,
                                23080283, 8348709,  37523407, 29375877,
                                31506984, 73381432, 28265727, 84639344,
                                8751468,  64050714, 83729556, 31127499};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msll_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSLL_MM U32");
}

static void test_msll_w_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {26757936, 29920127, 13210151, 24737200,
                                23080283, 8348709,  37523407, 29375877,
                                31506984, 36690716, 28265727, 42319672,
                                4375734,  32025357, 41864778, 31127499};
  const uint32_t src2[M * N] = {1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0};
  const uint32_t answ[M * N] = {53515872, 29920127, 26420302, 49474400,
                                23080283, 8348709,  37523407, 29375877,
                                31506984, 73381432, 28265727, 84639344,
                                8751468,  64050714, 83729556, 31127499};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msll_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSLL_W_MM");
}

static void test_msll_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {12772890849754140, 179941759429937258,
                                71211193374103089, 141734895515075829};
  const uint64_t src2[M * N] = {0, 1, 0, 1};
  const uint64_t answ[M * N] = {12772890849754140, 359883518859874516,
                                71211193374103089, 283469791030151658};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msll_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSLL_MM U64");
}

static void test_msll_dw_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {12772890849754140, 179941759429937258,
                                71211193374103089, 141734895515075829};
  const uint64_t src2[M * N] = {0, 1, 0, 1};
  const uint64_t answ[M * N] = {12772890849754140, 359883518859874516,
                                71211193374103089, 283469791030151658};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msll_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSLL_DW_MM");
}

static void test_msll_mm() {
  test_msll_mm_i8();
  test_msll_b_mm_i8();
  test_msll_mm_i16();
  test_msll_h_mm_i16();
  test_msll_mm_i32();
  test_msll_w_mm_i32();
  test_msll_mm_i64();
  test_msll_dw_mm_i64();
  test_msll_mm_u8();
  test_msll_b_mm_u8();
  test_msll_mm_u16();
  test_msll_h_mm_u16();
  test_msll_mm_u32();
  test_msll_w_mm_u32();
  test_msll_mm_u64();
  test_msll_dw_mm_u64();
}

static void test_msrl_mm_i8() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {0b00001000, 0b11110111, 0b11111111, 0b11111001};
  const int8_t src2[M * N] = {0b00000000, 0b00000000, 0b00000010, 0b00000001};
  const int8_t answ[M * N] = {0b00001000, 0b11110111, 0b00111111, 0b01111100};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msrl_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSRL_MM I8");
}

static void test_msrl_b_mm_i8() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {0b00001000, 0b11110111, 0b11111111, 0b11111001};
  const int8_t src2[M * N] = {0b00000000, 0b00000000, 0b00000010, 0b00000001};
  const int8_t answ[M * N] = {0b00001000, 0b11110111, 0b00111111, 0b01111100};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msrl_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSRL_B_MM");
}

static void test_msrl_mm_i16() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {0b1111111111111111, 0b1111111111111000,
                               0b1111111111111011, 0b0111111111110111};
  const int16_t src2[M * N] = {0b0000000000000001, 0b0000000000000001,
                               0b0000000000000001, 0b0000000000000001};
  const int16_t answ[M * N] = {0b0111111111111111, 0b0111111111111100,
                               0b0111111111111101, 0b0011111111111011};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msrl_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSRL_MM I16");
}

static void test_msrl_h_mm_i16() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {0b1111111111111111, 0b1111111111111000,
                               0b1111111111111011, 0b0111111111110111};
  const int16_t src2[M * N] = {0b0000000000000001, 0b0000000000000001,
                               0b0000000000000001, 0b0000000000000001};
  const int16_t answ[M * N] = {0b0111111111111111, 0b0111111111111100,
                               0b0111111111111101, 0b0011111111111011};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msrl_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSRL_H_MM I16");
}

static void test_msrl_mm_i32() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {
      0b00000000000000000000011000000001, 0b00000000000000000000011111110111,
      0b11111111111111111110010000010101, 0b11111111111111111101111101100010};
  const int32_t src2[M * N] = {
      0b00000000000000000000000000000001, 0b00000000000000000000000000000010,
      0b00000000000000000000000000000001, 0b00000000000000000000000000000000};
  const int32_t answ[M * N] = {
      0b00000000000000000000001100000000, 0b00000000000000000000000111111101,
      0b01111111111111111111001000001010, 0b11111111111111111101111101100010};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msrl_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSRL_MM I32");
}

static void test_msrl_w_mm_i32() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {
      0b00000000000000000000011000000001, 0b00000000000000000000011111110111,
      0b11111111111111111110010000010101, 0b11111111111111111101111101100010};
  const int32_t src2[M * N] = {
      0b00000000000000000000000000000001, 0b00000000000000000000000000000010,
      0b00000000000000000000000000000001, 0b00000000000000000000000000000000};
  const int32_t answ[M * N] = {
      0b00000000000000000000001100000000, 0b00000000000000000000000111111101,
      0b01111111111111111111001000001010, 0b11111111111111111101111101100010};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msrl_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSRL_W_MM");
}

static void test_msrl_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {
      0b1111111111111111111111111111111111101010111111110110001011000101,
      0b1111111111111111111111111111111111011011010010110101000110010111,
      0b0000000000000000000000000000000000111101111011011110110001100111,
      0b0000000000000000000000000000000000000001010011110111010010111000};
  const int64_t src2[M * N] = {
      0b0000000000000000000000000000000000000000000000000000000000000000,
      0b0000000000000000000000000000000000000000000000000000000000000001,
      0b0000000000000000000000000000000000000000000000000000000000000010,
      0b0000000000000000000000000000000000000000000000000000000000000010};
  const int64_t answ[M * N] = {
      0b1111111111111111111111111111111111101010111111110110001011000101,
      0b0111111111111111111111111111111111101101101001011010100011001011,
      0b0000000000000000000000000000000000001111011110110111101100011001,
      0b0000000000000000000000000000000000000000010100111101110100101110};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msrl_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSRL_MM I64");
}

static void test_msrl_dw_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {
      0b1111111111111111111111111111111111101010111111110110001011000101,
      0b1111111111111111111111111111111111011011010010110101000110010111,
      0b0000000000000000000000000000000000111101111011011110110001100111,
      0b0000000000000000000000000000000000000001010011110111010010111000};
  const int64_t src2[M * N] = {
      0b0000000000000000000000000000000000000000000000000000000000000000,
      0b0000000000000000000000000000000000000000000000000000000000000001,
      0b0000000000000000000000000000000000000000000000000000000000000010,
      0b0000000000000000000000000000000000000000000000000000000000000010};
  const int64_t answ[M * N] = {
      0b1111111111111111111111111111111111101010111111110110001011000101,
      0b0111111111111111111111111111111111101101101001011010100011001011,
      0b0000000000000000000000000000000000001111011110110111101100011001,
      0b0000000000000000000000000000000000000000010100111101110100101110};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msrl_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSRL_DW_MM");
}

static void test_msrl_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
                               1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1,
                               1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1,
                               1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1};
  const uint8_t src2[M * N] = {1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1,
                               0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0,
                               0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0,
                               1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0};
  const uint8_t answ[M * N] = {0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                               1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,
                               1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
                               0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msrl_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSRL_MM U8");
}

static void test_msrl_b_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
                               1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1,
                               1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1,
                               1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1};
  const uint8_t src2[M * N] = {1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1,
                               0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0,
                               0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0,
                               1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0};
  const uint8_t answ[M * N] = {0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                               1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,
                               1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
                               0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msrl_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSRL_B_MM");
}

static void test_msrl_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      526, 119, 450, 352, 421, 553, 200, 324, 196, 585, 628, 218, 198,
      167, 632, 35,  592, 408, 405, 462, 106, 600, 152, 625, 607, 472,
      14,  457, 421, 240, 295, 227, 637, 629, 412, 576, 554, 584, 506,
      262, 602, 454, 341, 116, 186, 248, 610, 94,  6,   85,  602, 324,
      334, 511, 277, 272, 118, 345, 306, 298, 379, 364, 190, 266};
  const uint16_t src2[M * N] = {0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1,
                                1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1,
                                0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1,
                                0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0};
  const uint16_t answ[M * N] = {
      526, 119, 225, 352, 421, 276, 200, 162, 196, 585, 314, 218, 198,
      83,  632, 17,  296, 204, 405, 231, 106, 600, 76,  312, 607, 472,
      7,   228, 210, 120, 295, 113, 637, 629, 412, 576, 554, 292, 506,
      262, 301, 454, 170, 116, 186, 248, 305, 47,  6,   42,  602, 162,
      167, 511, 138, 272, 118, 172, 153, 298, 379, 182, 95,  266};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msrl_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSRL_MM U16");
}

static void test_msrl_h_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      526, 119, 450, 352, 421, 553, 200, 324, 196, 585, 628, 218, 198,
      167, 632, 35,  592, 408, 405, 462, 106, 600, 152, 625, 607, 472,
      14,  457, 421, 240, 295, 227, 637, 629, 412, 576, 554, 584, 506,
      262, 602, 454, 341, 116, 186, 248, 610, 94,  6,   85,  602, 324,
      334, 511, 277, 272, 118, 345, 306, 298, 379, 364, 190, 266};
  const uint16_t src2[M * N] = {0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1,
                                1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1,
                                0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1,
                                0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0};
  const uint16_t answ[M * N] = {
      526, 119, 225, 352, 421, 276, 200, 162, 196, 585, 314, 218, 198,
      83,  632, 17,  296, 204, 405, 231, 106, 600, 76,  312, 607, 472,
      7,   228, 210, 120, 295, 113, 637, 629, 412, 576, 554, 292, 506,
      262, 301, 454, 170, 116, 186, 248, 305, 47,  6,   42,  602, 162,
      167, 511, 138, 272, 118, 172, 153, 298, 379, 182, 95,  266};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msrl_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSRL_H_MM");
}

static void test_msrl_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {27520832, 39877121, 27579306, 38897456,
                                14281607, 16504074, 9691320,  31808511,
                                22084310, 24126792, 8956199,  7357356,
                                8112085,  2816855,  36111602, 35531701};
  const uint32_t src2[M * N] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0};
  const uint32_t answ[M * N] = {27520832, 19938560, 13789653, 38897456,
                                7140803,  8252037,  9691320,  31808511,
                                11042155, 24126792, 8956199,  7357356,
                                4056042,  2816855,  18055801, 35531701};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msrl_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSRL_MM U32");
}

static void test_msrl_w_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {27520832, 39877121, 27579306, 38897456,
                                14281607, 16504074, 9691320,  31808511,
                                22084310, 24126792, 8956199,  7357356,
                                8112085,  2816855,  36111602, 35531701};
  const uint32_t src2[M * N] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0};
  const uint32_t answ[M * N] = {27520832, 19938560, 13789653, 38897456,
                                7140803,  8252037,  9691320,  31808511,
                                11042155, 24126792, 8956199,  7357356,
                                4056042,  2816855,  18055801, 35531701};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msrl_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSRL_W_MM");
}

static void test_msrl_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {45258697050173273, 77001006242231314,
                                82236756365941946, 152681560177250957};
  const uint64_t src2[M * N] = {0, 0, 0, 1};
  const uint64_t answ[M * N] = {45258697050173273, 77001006242231314,
                                82236756365941946, 76340780088625478};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msrl_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSRL_MM U64");
}

static void test_msrl_dw_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {45258697050173273, 77001006242231314,
                                82236756365941946, 152681560177250957};
  const uint64_t src2[M * N] = {0, 0, 0, 1};
  const uint64_t answ[M * N] = {45258697050173273, 77001006242231314,
                                82236756365941946, 76340780088625478};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msrl_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSRL_DW_MM");
}

static void test_msrl_mm() {
  test_msrl_mm_i8();
  test_msrl_b_mm_i8();
  test_msrl_mm_i16();
  test_msrl_h_mm_i16();
  test_msrl_mm_i32();
  test_msrl_w_mm_i32();
  test_msrl_mm_i64();
  test_msrl_dw_mm_i64();
  test_msrl_mm_u8();
  test_msrl_b_mm_u8();
  test_msrl_mm_u16();
  test_msrl_h_mm_u16();
  test_msrl_mm_u32();
  test_msrl_w_mm_u32();
  test_msrl_mm_u64();
  test_msrl_dw_mm_u64();
}

static void test_msra_mm_i8() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {0b00001000, 0b11110111, 0b11111111, 0b11111001};
  const int8_t src2[M * N] = {0b00000000, 0b00000000, 0b00000010, 0b00000001};
  const int8_t answ[M * N] = {0b00001000, 0b11110111, 0b11111111, 0b11111100};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msra_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSRA_MM I8");
}

static void test_msra_b_mm_i8() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {0b00001000, 0b11110111, 0b11111111, 0b11111001};
  const int8_t src2[M * N] = {0b00000000, 0b00000000, 0b00000010, 0b00000001};
  const int8_t answ[M * N] = {0b00001000, 0b11110111, 0b11111111, 0b11111100};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msra_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSRA_B_MM");
}

static void test_msra_mm_i16() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {0b1111111111111111, 0b1111111111111000,
                               0b1111111111111011, 0b0111111111110111};
  const int16_t src2[M * N] = {0b0000000000000001, 0b0000000000000001,
                               0b0000000000000001, 0b0000000000000001};
  const int16_t answ[M * N] = {0b1111111111111111, 0b1111111111111100,
                               0b1111111111111101, 0b0011111111111011};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msra_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSRA_MM I16");
}

static void test_msra_h_mm_i16() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {0b1111111111111111, 0b1111111111111000,
                               0b1111111111111011, 0b0111111111110111};
  const int16_t src2[M * N] = {0b0000000000000001, 0b0000000000000001,
                               0b0000000000000001, 0b0000000000000001};
  const int16_t answ[M * N] = {0b1111111111111111, 0b1111111111111100,
                               0b1111111111111101, 0b0011111111111011};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msra_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSRA_H_MM I16");
}

static void test_msra_mm_i32() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {
      0b00000000000000000000011000000001, 0b00000000000000000000011111110111,
      0b11111111111111111110010000010101, 0b11111111111111111101111101100010};
  const int32_t src2[M * N] = {
      0b00000000000000000000000000000001, 0b00000000000000000000000000000010,
      0b00000000000000000000000000000001, 0b00000000000000000000000000000000};
  const int32_t answ[M * N] = {
      0b00000000000000000000001100000000, 0b00000000000000000000000111111101,
      0b11111111111111111111001000001010, 0b11111111111111111101111101100010};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msra_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSRA_MM I32");
}

static void test_msra_w_mm_i32() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {
      0b00000000000000000000011000000001, 0b00000000000000000000011111110111,
      0b11111111111111111110010000010101, 0b11111111111111111101111101100010};
  const int32_t src2[M * N] = {
      0b00000000000000000000000000000001, 0b00000000000000000000000000000010,
      0b00000000000000000000000000000001, 0b00000000000000000000000000000000};
  const int32_t answ[M * N] = {
      0b00000000000000000000001100000000, 0b00000000000000000000000111111101,
      0b11111111111111111111001000001010, 0b11111111111111111101111101100010};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msra_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSRA_W_MM");
}

static void test_msra_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {
      0b1111111111111111111111111111111111101010111111110110001011000101,
      0b1111111111111111111111111111111111011011010010110101000110010111,
      0b0000000000000000000000000000000000111101111011011110110001100111,
      0b0000000000000000000000000000000000000001010011110111010010111000};
  const int64_t src2[M * N] = {
      0b0000000000000000000000000000000000000000000000000000000000000000,
      0b0000000000000000000000000000000000000000000000000000000000000001,
      0b0000000000000000000000000000000000000000000000000000000000000010,
      0b0000000000000000000000000000000000000000000000000000000000000010};
  const int64_t answ[M * N] = {
      0b1111111111111111111111111111111111101010111111110110001011000101,
      0b1111111111111111111111111111111111101101101001011010100011001011,
      0b0000000000000000000000000000000000001111011110110111101100011001,
      0b0000000000000000000000000000000000000000010100111101110100101110};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msra_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSRA_MM I64");
}

static void test_msra_dw_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {
      0b1111111111111111111111111111111111101010111111110110001011000101,
      0b1111111111111111111111111111111111011011010010110101000110010111,
      0b0000000000000000000000000000000000111101111011011110110001100111,
      0b0000000000000000000000000000000000000001010011110111010010111000};
  const int64_t src2[M * N] = {
      0b0000000000000000000000000000000000000000000000000000000000000000,
      0b0000000000000000000000000000000000000000000000000000000000000001,
      0b0000000000000000000000000000000000000000000000000000000000000010,
      0b0000000000000000000000000000000000000000000000000000000000000010};
  const int64_t answ[M * N] = {
      0b1111111111111111111111111111111111101010111111110110001011000101,
      0b1111111111111111111111111111111111101101101001011010100011001011,
      0b0000000000000000000000000000000000001111011110110111101100011001,
      0b0000000000000000000000000000000000000000010100111101110100101110};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msra_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSRA_DW_MM");
}

static void test_msra_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
                               1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1,
                               1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1,
                               1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1};
  const uint8_t src2[M * N] = {1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1,
                               0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0,
                               0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0,
                               1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0};
  const uint8_t answ[M * N] = {0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                               1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,
                               1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
                               0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msra_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSRA_MM U8");
}

static void test_msra_b_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,
                               1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1,
                               1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1,
                               1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1};
  const uint8_t src2[M * N] = {1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1,
                               0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0,
                               0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0,
                               1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0};
  const uint8_t answ[M * N] = {0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                               1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1,
                               1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1,
                               0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msra_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSRA_B_MM");
}

static void test_msra_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      526, 119, 450, 352, 421, 553, 200, 324, 196, 585, 628, 218, 198,
      167, 632, 35,  592, 408, 405, 462, 106, 600, 152, 625, 607, 472,
      14,  457, 421, 240, 295, 227, 637, 629, 412, 576, 554, 584, 506,
      262, 602, 454, 341, 116, 186, 248, 610, 94,  6,   85,  602, 324,
      334, 511, 277, 272, 118, 345, 306, 298, 379, 364, 190, 266};
  const uint16_t src2[M * N] = {0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1,
                                1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1,
                                0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1,
                                0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0};
  const uint16_t answ[M * N] = {
      526, 119, 225, 352, 421, 276, 200, 162, 196, 585, 314, 218, 198,
      83,  632, 17,  296, 204, 405, 231, 106, 600, 76,  312, 607, 472,
      7,   228, 210, 120, 295, 113, 637, 629, 412, 576, 554, 292, 506,
      262, 301, 454, 170, 116, 186, 248, 305, 47,  6,   42,  602, 162,
      167, 511, 138, 272, 118, 172, 153, 298, 379, 182, 95,  266};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msra_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSRA_MM U16");
}

static void test_msra_h_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      526, 119, 450, 352, 421, 553, 200, 324, 196, 585, 628, 218, 198,
      167, 632, 35,  592, 408, 405, 462, 106, 600, 152, 625, 607, 472,
      14,  457, 421, 240, 295, 227, 637, 629, 412, 576, 554, 584, 506,
      262, 602, 454, 341, 116, 186, 248, 610, 94,  6,   85,  602, 324,
      334, 511, 277, 272, 118, 345, 306, 298, 379, 364, 190, 266};
  const uint16_t src2[M * N] = {0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1,
                                1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1,
                                0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1,
                                0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0};
  const uint16_t answ[M * N] = {
      526, 119, 225, 352, 421, 276, 200, 162, 196, 585, 314, 218, 198,
      83,  632, 17,  296, 204, 405, 231, 106, 600, 76,  312, 607, 472,
      7,   228, 210, 120, 295, 113, 637, 629, 412, 576, 554, 292, 506,
      262, 301, 454, 170, 116, 186, 248, 305, 47,  6,   42,  602, 162,
      167, 511, 138, 272, 118, 172, 153, 298, 379, 182, 95,  266};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msra_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSRA_H_MM");
}

static void test_msra_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {27520832, 39877121, 27579306, 38897456,
                                14281607, 16504074, 9691320,  31808511,
                                22084310, 24126792, 8956199,  7357356,
                                8112085,  2816855,  36111602, 35531701};
  const uint32_t src2[M * N] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0};
  const uint32_t answ[M * N] = {27520832, 19938560, 13789653, 38897456,
                                7140803,  8252037,  9691320,  31808511,
                                11042155, 24126792, 8956199,  7357356,
                                4056042,  2816855,  18055801, 35531701};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msra_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSRA_MM U32");
}

static void test_msra_w_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {27520832, 39877121, 27579306, 38897456,
                                14281607, 16504074, 9691320,  31808511,
                                22084310, 24126792, 8956199,  7357356,
                                8112085,  2816855,  36111602, 35531701};
  const uint32_t src2[M * N] = {0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0};
  const uint32_t answ[M * N] = {27520832, 19938560, 13789653, 38897456,
                                7140803,  8252037,  9691320,  31808511,
                                11042155, 24126792, 8956199,  7357356,
                                4056042,  2816855,  18055801, 35531701};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msra_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSRA_W_MM");
}

static void test_msra_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {45258697050173273, 77001006242231314,
                                82236756365941946, 152681560177250957};
  const uint64_t src2[M * N] = {0, 0, 0, 1};
  const uint64_t answ[M * N] = {45258697050173273, 77001006242231314,
                                82236756365941946, 76340780088625478};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msra_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSRA_MM U64");
}

static void test_msra_dw_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {45258697050173273, 77001006242231314,
                                82236756365941946, 152681560177250957};
  const uint64_t src2[M * N] = {0, 0, 0, 1};
  const uint64_t answ[M * N] = {45258697050173273, 77001006242231314,
                                82236756365941946, 76340780088625478};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msra_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSRA_DW_MM");
}

static void test_msra_mm() {
  test_msra_mm_i8();
  test_msra_b_mm_i8();
  test_msra_mm_i16();
  test_msra_h_mm_i16();
  test_msra_mm_i32();
  test_msra_w_mm_i32();
  test_msra_mm_i64();
  test_msra_dw_mm_i64();
  test_msra_mm_u8();
  test_msra_b_mm_u8();
  test_msra_mm_u16();
  test_msra_h_mm_u16();
  test_msra_mm_u32();
  test_msra_w_mm_u32();
  test_msra_mm_u64();
  test_msra_dw_mm_u64();
}

static void test_mmul_mm_i8() {
  const int8_t src1[] = {
      111,  74,   36,   -72, -121, -124, -23,  36,   42,  42,  -117, -100,
      109,  49,   -44,  -39, -108, 104,  -48,  101,  81,  120, -58,  -115,
      71,   19,   -102, -77, -74,  -18,  13,   44,   -21, 42,  62,   99,
      72,   -73,  38,   41,  96,   72,   -59,  -100, 119, -90, -5,   87,
      -100, -102, 48,   -1,  126,  -118, -102, -22,  101, 56,  124,  31,
      -85,  60,   -115, 23,  29,   106,  -31,  36,   62,  -49, -91,  12,
      4,    -122, 74,   -76, 77,   64,   9,    -127};
  const int8_t src2[] = {-54, 45,  -107, -20, 11,   53,   33,   21,   -9,   -2,
                         -8,  -90, -56,  121, -75,  35,   100,  -112, -103, -57,
                         -48, -44, -80,  87,  -75,  -107, -102, 0,    -44,  -51,
                         80,  -33, -106, 107, 85,   -111, 40,   -49,  -97,  117,
                         99,  -35, -86,  -90, 45,   91,   -73,  -97,  68,   41,
                         -53, -34, 45,   -41, -120, -90,  124,  -41,  -100, 121,
                         21,  21,  -30,  73,  -26,  -17,  26,   -7,   -71,  -46,
                         42,  -94, -119, -65, -91,  47,   100,  97,   -12,  5};
  const int8_t answ[] = {
      -106, 2,   -12,  -96,  -51, 84,   9,    -12,  -122, -84,  -88,  40,
      40,   41,  -28,  -85,  -48, -128, 80,   -125, -48,  96,   32,   -21,
      51,   15,  -92,  0,    -72, -106, 16,   84,   -78,  -114, -106, 19,
      64,   -7,  -102, -67,  32,  40,   -46,  40,   -21,  2,    109,  9,
      112,  -86, 16,   34,   38,  -26,  -48,  -68,  -20,  8,    -112, -89,
      7,    -20, 122,  -113, 14,  -10,  -38,  4,    -50,  -50,  18,   -104,
      36,   -6,  -78,  12,   20,  64,   -108, -123};
  const size_t M = 5;
  const size_t N = 16;
  const size_t stride = N * sizeof(int8_t);
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmul_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMUL_MM I8");
}

static void test_mmul_b_mm() {
  const int8_t src1[] = {
      111,  74,   36,   -72, -121, -124, -23,  36,   42,  42,  -117, -100,
      109,  49,   -44,  -39, -108, 104,  -48,  101,  81,  120, -58,  -115,
      71,   19,   -102, -77, -74,  -18,  13,   44,   -21, 42,  62,   99,
      72,   -73,  38,   41,  96,   72,   -59,  -100, 119, -90, -5,   87,
      -100, -102, 48,   -1,  126,  -118, -102, -22,  101, 56,  124,  31,
      -85,  60,   -115, 23,  29,   106,  -31,  36,   62,  -49, -91,  12,
      4,    -122, 74,   -76, 77,   64,   9,    -127};
  const int8_t src2[] = {-54, 45,  -107, -20, 11,   53,   33,   21,   -9,   -2,
                         -8,  -90, -56,  121, -75,  35,   100,  -112, -103, -57,
                         -48, -44, -80,  87,  -75,  -107, -102, 0,    -44,  -51,
                         80,  -33, -106, 107, 85,   -111, 40,   -49,  -97,  117,
                         99,  -35, -86,  -90, 45,   91,   -73,  -97,  68,   41,
                         -53, -34, 45,   -41, -120, -90,  124,  -41,  -100, 121,
                         21,  21,  -30,  73,  -26,  -17,  26,   -7,   -71,  -46,
                         42,  -94, -119, -65, -91,  47,   100,  97,   -12,  5};
  const int8_t answ[] = {
      -106, 2,   -12,  -96,  -51, 84,   9,    -12,  -122, -84,  -88,  40,
      40,   41,  -28,  -85,  -48, -128, 80,   -125, -48,  96,   32,   -21,
      51,   15,  -92,  0,    -72, -106, 16,   84,   -78,  -114, -106, 19,
      64,   -7,  -102, -67,  32,  40,   -46,  40,   -21,  2,    109,  9,
      112,  -86, 16,   34,   38,  -26,  -48,  -68,  -20,  8,    -112, -89,
      7,    -20, 122,  -113, 14,  -10,  -38,  4,    -50,  -50,  18,   -104,
      36,   -6,  -78,  12,   20,  64,   -108, -123};
  const size_t M = 5;
  const size_t N = 16;
  const size_t stride = N * sizeof(int8_t);
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmul_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMUL_B_MM");
}

static void test_mmul_mm_i16() {
  enum { M = 4, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[] = {-5902,  475,    20032,  457,   3932,   -29934, 11950,
                          2585,   -12594, -28837, 22098, -7916,  -17630, 9787,
                          -26824, -10431, 22422,  28301, -16926, -3301,  27054,
                          -2693,  3171,   2125,   31609, -13366, 21463,  19079,
                          2190,   -1,     -12370, -15122};
  const int16_t src2[] = {1618,   32016, 12839,  -14307, -23068, 5225,   -10898,
                          19280,  19174, 11471,  29950,  -19985, -10665, -11767,
                          28750,  14579, -23237, 32112,  29760,  -14764, -27210,
                          -30176, 8173,  30292,  30446,  -26749, 29335,  -14402,
                          -818,   -9817, 20889,  -14192};
  const int16_t answ[] = {
      0b0100100110000100, 0b0000110010110000, 0b0110101111000000,
      0b0011101111000101, 0b1111100111110000, 0b0111001001100010,
      0b1101010011000100, 0b0111101011010000, 0b0101100100010100,
      0b1000111010010101, 0b1100110101011100, 0b1111010110101100,
      0b0000010010001110, 0b1011111000010011, 0b1001001100010000,
      0b1000101010110011, 0b1101110110010010, 0b0011011010110000,
      0b1110000010000000, 0b1010011011011100, 0b0110011110110100,
      0b1111110101100000, 0b0111010010100111, 0b0011011101000100,
      0b1001000001111110, 0b0110111001011110, 0b0011000111010001,
      0b0100000100110010, 0b1010101001000100, 0b0010011001011001,
      0b0010110011111110, 0b1011010111100000};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmul_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMUL_MM I16");
}

static void test_mmul_h_mm() {
  enum { M = 4, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[] = {-5902,  475,    20032,  457,   3932,   -29934, 11950,
                          2585,   -12594, -28837, 22098, -7916,  -17630, 9787,
                          -26824, -10431, 22422,  28301, -16926, -3301,  27054,
                          -2693,  3171,   2125,   31609, -13366, 21463,  19079,
                          2190,   -1,     -12370, -15122};
  const int16_t src2[] = {1618,   32016, 12839,  -14307, -23068, 5225,   -10898,
                          19280,  19174, 11471,  29950,  -19985, -10665, -11767,
                          28750,  14579, -23237, 32112,  29760,  -14764, -27210,
                          -30176, 8173,  30292,  30446,  -26749, 29335,  -14402,
                          -818,   -9817, 20889,  -14192};
  const int16_t answ[] = {
      0b0100100110000100, 0b0000110010110000, 0b0110101111000000,
      0b0011101111000101, 0b1111100111110000, 0b0111001001100010,
      0b1101010011000100, 0b0111101011010000, 0b0101100100010100,
      0b1000111010010101, 0b1100110101011100, 0b1111010110101100,
      0b0000010010001110, 0b1011111000010011, 0b1001001100010000,
      0b1000101010110011, 0b1101110110010010, 0b0011011010110000,
      0b1110000010000000, 0b1010011011011100, 0b0110011110110100,
      0b1111110101100000, 0b0111010010100111, 0b0011011101000100,
      0b1001000001111110, 0b0110111001011110, 0b0011000111010001,
      0b0100000100110010, 0b1010101001000100, 0b0010011001011001,
      0b0010110011111110, 0b1011010111100000};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmul_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMUL_H_MM");
}

static void test_mmul_mm_i32() {
  enum { M = 5, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[] = {1233436256,  1274488063,  -1780058273, 1135628978,
                          -950815679,  1671959166,  1666808812,  776934449,
                          1234692602,  -1526993931, -1399929402, 760500162,
                          -1387010718, 189025654,   730688401,   692056148,
                          2145584747,  -1212261150, 619640527,   -1699508573};
  const int32_t src2[] = {1510444861, 1001848163,  1325478368, -1732913065,
                          -517488933, -1503842313, 1204301170, 763102971,
                          166057080,  657407816,   1500977977, -2095285952,
                          -182832949, 31379264,    837633032,  -1720048366,
                          -881848507, -1558943035, 26524537,   -99008218};
  const int32_t answ[] = {
      0b10011111100110001111110011100000, 0b10110010011011010101000110011101,
      0b00001110111000001010001000100000, 0b11101110100011000100101001111110,
      0b00111011010010100111000110011011, 0b01101110010101001111100110010010,
      0b00111101000000011010101100011000, 0b10100110101111011111001000001011,
      0b01100011100110101011010100110000, 0b00001010111001101010011111101000,
      0b00111111101011111110101100010110, 0b00101101111111101010001010000000,
      0b01000010011111010100010010110110, 0b10101110000010011100011110000000,
      0b01000011001110101110000010001000, 0b11100000010000110000100111101000,
      0b01101101011000001111111111010111, 0b01011111100110110000110111101010,
      0b10000001111001111101110011010111, 0b10101001110010011000111100110010};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmul_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMUL_MM I32");
}

static void test_mmul_w_mm() {
  enum { M = 5, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[] = {1233436256,  1274488063,  -1780058273, 1135628978,
                          -950815679,  1671959166,  1666808812,  776934449,
                          1234692602,  -1526993931, -1399929402, 760500162,
                          -1387010718, 189025654,   730688401,   692056148,
                          2145584747,  -1212261150, 619640527,   -1699508573};
  const int32_t src2[] = {1510444861, 1001848163,  1325478368, -1732913065,
                          -517488933, -1503842313, 1204301170, 763102971,
                          166057080,  657407816,   1500977977, -2095285952,
                          -182832949, 31379264,    837633032,  -1720048366,
                          -881848507, -1558943035, 26524537,   -99008218};
  const int32_t answ[] = {
      0b10011111100110001111110011100000, 0b10110010011011010101000110011101,
      0b00001110111000001010001000100000, 0b11101110100011000100101001111110,
      0b00111011010010100111000110011011, 0b01101110010101001111100110010010,
      0b00111101000000011010101100011000, 0b10100110101111011111001000001011,
      0b01100011100110101011010100110000, 0b00001010111001101010011111101000,
      0b00111111101011111110101100010110, 0b00101101111111101010001010000000,
      0b01000010011111010100010010110110, 0b10101110000010011100011110000000,
      0b01000011001110101110000010001000, 0b11100000010000110000100111101000,
      0b01101101011000001111111111010111, 0b01011111100110110000110111101010,
      0b10000001111001111101110011010111, 0b10101001110010011000111100110010};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmul_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMUL_W_MM");
}

static void test_mmul_mm_i64() {
  const size_t M = 1;
  const size_t N = 1;
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[] = {
      0b0111111111111111111111111111111111111111111111111111111111111111};
  const int64_t src2[] = {2};
  const int64_t answ[] = {
      0b1111111111111111111111111111111111111111111111111111111111111110};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mmul_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMUL_MM I64");
}

static void test_mmul_dw_mm() {
  const size_t M = 1;
  const size_t N = 1;
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[] = {
      0b0111111111111111111111111111111111111111111111111111111111111111};
  const int64_t src2[] = {2};
  const int64_t answ[] = {
      0b1111111111111111111111111111111111111111111111111111111111111110};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mmul_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMUL_DW_MM");
}

static void test_mmul_mm() {
  test_mmul_mm_i8();
  test_mmul_b_mm();
  test_mmul_mm_i16();
  test_mmul_h_mm();
  test_mmul_mm_i32();
  test_mmul_w_mm();
  test_mmul_mm_i64();
  test_mmul_dw_mm();
}

static void test_mmulh_mm_i8() {
  const int8_t src1[] = {
      78,  52,  70,  7,   -58, 55,  44,  13, 34,  69,  84,  -96, 54,  98,
      -71, 35,  -93, 12,  -22, -67, 60,  99, 38,  46,  62,  61,  -53, -99,
      66,  -69, 7,   -79, 83,  67,  28,  37, -1,  -84, 62,  -96, -19, -83,
      4,   -99, 32,  63,  57,  -58, 30,  21, -72, -23, -67, 90,  63,  -1,
      -56, 28,  3,   10,  -72, -14, 67,  54, -22, 1,   -16, -6,  55,  -39,
      8,   -21, 7,   -74, -16, 32,  -82, 1,  -27, 24};
  const int8_t src2[] = {
      -92, -40, -71, -31, -2,  -81, 32,  -25, 38,  31,  -29, -60, 0,   34,
      11,  -10, -52, -58, -31, -17, 73,  -81, -76, -7,  -66, -88, -11, -50,
      -72, 69,  -40, -77, -87, -56, 57,  47,  -62, -54, 97,  84,  -34, 84,
      1,   94,  -29, -60, -1,  -95, -52, -52, -39, -28, -24, -57, 11,  8,
      -48, -92, -35, 14,  -99, 69,  94,  -80, 0,   -53, -15, 21,  75,  74,
      2,   -48, -93, 96,  10,  54,  65,  -2,  -75, 82};
  const int8_t answ[] = {
      0b11100011, 0b11110111, 0b11101100, 0b11111111, 0b00000000, 0b11101110,
      0b00000101, 0b11111110, 0b00000101, 0b00001000, 0b11110110, 0b00010110,
      0b00000000, 0b00001101, 0b11111100, 0b11111110, 0b00010010, 0b11111101,
      0b00000010, 0b00000100, 0b00010001, 0b11100000, 0b11110100, 0b11111110,
      0b11110000, 0b11101011, 0b00000010, 0b00010011, 0b11101101, 0b11101101,
      0b11111110, 0b00010111, 0b11100011, 0b11110001, 0b00000110, 0b00000110,
      0b00000000, 0b00010001, 0b00010111, 0b11100000, 0b00000010, 0b11100100,
      0b00000000, 0b11011011, 0b11111100, 0b11110001, 0b11111111, 0b00010101,
      0b11111001, 0b11111011, 0b00001010, 0b00000010, 0b00000110, 0b11101011,
      0b00000010, 0b11111111, 0b00001010, 0b11110101, 0b11111111, 0b00000000,
      0b00011011, 0b11111100, 0b00011000, 0b11101111, 0b00000000, 0b11111111,
      0b00000000, 0b11111111, 0b00010000, 0b11110100, 0b00000000, 0b00000011,
      0b11111101, 0b11100100, 0b11111111, 0b00000110, 0b11101011, 0b11111111,
      0b00000111, 0b00000111};
  const size_t M = 5;
  const size_t N = 16;
  const size_t stride = N * sizeof(int8_t);
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmulh_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMULH_MM I8");
}

static void test_mmulh_b_mm() {
  const int8_t src1[] = {
      78,  52,  70,  7,   -58, 55,  44,  13, 34,  69,  84,  -96, 54,  98,
      -71, 35,  -93, 12,  -22, -67, 60,  99, 38,  46,  62,  61,  -53, -99,
      66,  -69, 7,   -79, 83,  67,  28,  37, -1,  -84, 62,  -96, -19, -83,
      4,   -99, 32,  63,  57,  -58, 30,  21, -72, -23, -67, 90,  63,  -1,
      -56, 28,  3,   10,  -72, -14, 67,  54, -22, 1,   -16, -6,  55,  -39,
      8,   -21, 7,   -74, -16, 32,  -82, 1,  -27, 24};
  const int8_t src2[] = {
      -92, -40, -71, -31, -2,  -81, 32,  -25, 38,  31,  -29, -60, 0,   34,
      11,  -10, -52, -58, -31, -17, 73,  -81, -76, -7,  -66, -88, -11, -50,
      -72, 69,  -40, -77, -87, -56, 57,  47,  -62, -54, 97,  84,  -34, 84,
      1,   94,  -29, -60, -1,  -95, -52, -52, -39, -28, -24, -57, 11,  8,
      -48, -92, -35, 14,  -99, 69,  94,  -80, 0,   -53, -15, 21,  75,  74,
      2,   -48, -93, 96,  10,  54,  65,  -2,  -75, 82};
  const int8_t answ[] = {
      0b11100011, 0b11110111, 0b11101100, 0b11111111, 0b00000000, 0b11101110,
      0b00000101, 0b11111110, 0b00000101, 0b00001000, 0b11110110, 0b00010110,
      0b00000000, 0b00001101, 0b11111100, 0b11111110, 0b00010010, 0b11111101,
      0b00000010, 0b00000100, 0b00010001, 0b11100000, 0b11110100, 0b11111110,
      0b11110000, 0b11101011, 0b00000010, 0b00010011, 0b11101101, 0b11101101,
      0b11111110, 0b00010111, 0b11100011, 0b11110001, 0b00000110, 0b00000110,
      0b00000000, 0b00010001, 0b00010111, 0b11100000, 0b00000010, 0b11100100,
      0b00000000, 0b11011011, 0b11111100, 0b11110001, 0b11111111, 0b00010101,
      0b11111001, 0b11111011, 0b00001010, 0b00000010, 0b00000110, 0b11101011,
      0b00000010, 0b11111111, 0b00001010, 0b11110101, 0b11111111, 0b00000000,
      0b00011011, 0b11111100, 0b00011000, 0b11101111, 0b00000000, 0b11111111,
      0b00000000, 0b11111111, 0b00010000, 0b11110100, 0b00000000, 0b00000011,
      0b11111101, 0b11100100, 0b11111111, 0b00000110, 0b11101011, 0b11111111,
      0b00000111, 0b00000111};
  const size_t M = 5;
  const size_t N = 16;
  const size_t stride = N * sizeof(int8_t);
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmulh_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMULH_B_MM");
}

static void test_mmulh_mm_i16() {
  enum { M = 4, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[] = {
      11250,  22150,  2251,  12909,  -30246, 32388,  1526,   -29028,
      9864,   -24657, 21612, -10020, 8121,   -24224, 6392,   -1325,
      -12874, -27400, 25592, -20141, 13907,  3045,   -14471, -12370,
      9058,   -15692, 20696, 6998,   -3212,  17796,  31326,  26919};
  const int16_t src2[] = {15471, 22523, 11719,  -29632, 2956,   -8034, -1065,
                          4555,  -2719, 21642,  5013,   23090,  1294,  -10139,
                          4386,  2174,  18127,  9145,   22257,  2459,  17300,
                          1459,  -1963, -17806, -11131, -27921, -8440, 11457,
                          17303, 21852, 29579,  -29601};
  const int16_t answ[] = {
      0b0000101001011111, 0b0001110110111100, 0b0000000110010010,
      0b1110100100110011, 0b1111101010101011, 0b1111000001111101,
      0b1111111111100111, 0b1111100000011110, 0b1111111001100110,
      0b1110000000110001, 0b0000011001110101, 0b1111001000110101,
      0b0000000010100000, 0b0000111010100011, 0b0000000110101011,
      0b1111111111010100, 0b1111001000010111, 0b1111000100010000,
      0b0010000111110011, 0b1111110100001100, 0b0000111001010111,
      0b0000000001000011, 0b0000000110110001, 0b0000110100100000,
      0b1111100111111101, 0b0001101000011101, 0b1111010110010110,
      0b0000010011000111, 0b1111110010101111, 0b0001011100101101,
      0b0011011100111010, 0b1101000010000001};

  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmulh_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMULH_MM I16");
}

static void test_mmulh_h_mm() {
  enum { M = 4, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[] = {
      11250,  22150,  2251,  12909,  -30246, 32388,  1526,   -29028,
      9864,   -24657, 21612, -10020, 8121,   -24224, 6392,   -1325,
      -12874, -27400, 25592, -20141, 13907,  3045,   -14471, -12370,
      9058,   -15692, 20696, 6998,   -3212,  17796,  31326,  26919};
  const int16_t src2[] = {15471, 22523, 11719,  -29632, 2956,   -8034, -1065,
                          4555,  -2719, 21642,  5013,   23090,  1294,  -10139,
                          4386,  2174,  18127,  9145,   22257,  2459,  17300,
                          1459,  -1963, -17806, -11131, -27921, -8440, 11457,
                          17303, 21852, 29579,  -29601};
  const int16_t answ[] = {
      0b0000101001011111, 0b0001110110111100, 0b0000000110010010,
      0b1110100100110011, 0b1111101010101011, 0b1111000001111101,
      0b1111111111100111, 0b1111100000011110, 0b1111111001100110,
      0b1110000000110001, 0b0000011001110101, 0b1111001000110101,
      0b0000000010100000, 0b0000111010100011, 0b0000000110101011,
      0b1111111111010100, 0b1111001000010111, 0b1111000100010000,
      0b0010000111110011, 0b1111110100001100, 0b0000111001010111,
      0b0000000001000011, 0b0000000110110001, 0b0000110100100000,
      0b1111100111111101, 0b0001101000011101, 0b1111010110010110,
      0b0000010011000111, 0b1111110010101111, 0b0001011100101101,
      0b0011011100111010, 0b1101000010000001};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmulh_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMULH_H_MM");
}

static void test_mmulh_mm_i32() {
  enum { M = 5, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[] = {-1864187291, 44583579,    143522824,  -541181720,
                          -511255337,  1992571033,  2019553228, 414468700,
                          1143057586,  -1900987662, 2041881726, -517526418,
                          -1110304650, -648262133,  2004722094, -1852474879,
                          2090151511,  2012822785,  279661019,  1562895275};
  const int32_t src2[] = {1644675682,  415568863,   -695797429, 1188293154,
                          -37381,      -1066542573, -563026474, 1741107815,
                          1464853175,  -991207022,  -739078845, -440318919,
                          -2011471844, 312303164,   6822316,    1711153974,
                          1165513769,  -482726958,  1678327018, -101761353};
  const int32_t answ[] = {
      0b11010101011100110111000000111111, 0b00000000010000011101001010110100,
      0b11111110100111010011011101001101, 0b11110111000100110100111111010111,
      0b00000000000000000001000101100001, 0b11100010100000011110100010010001,
      0b11110000001110000101100000110010, 0b00001010000000111100001011101101,
      0b00010111001111001011010001101011, 0b00011010001001100100011110110000,
      0b11101011000011101000111100000001, 0b00000011001010011001010010100000,
      0b00011110111111100111000011011000, 0b11111101001100001011110011011111,
      0b00000000001100001001011100000101, 0b11010100000000100101110001000001,
      0b00100001110011101100010001100000, 0b11110010100001000000011100010111,
      0b00000110100000111000001011010110, 0b11111101110010101111011111010110};

  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmulh_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMULH_MM I32");
}

static void test_mmulh_w_mm() {
  enum { M = 5, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[] = {-1864187291, 44583579,    143522824,  -541181720,
                          -511255337,  1992571033,  2019553228, 414468700,
                          1143057586,  -1900987662, 2041881726, -517526418,
                          -1110304650, -648262133,  2004722094, -1852474879,
                          2090151511,  2012822785,  279661019,  1562895275};
  const int32_t src2[] = {1644675682,  415568863,   -695797429, 1188293154,
                          -37381,      -1066542573, -563026474, 1741107815,
                          1464853175,  -991207022,  -739078845, -440318919,
                          -2011471844, 312303164,   6822316,    1711153974,
                          1165513769,  -482726958,  1678327018, -101761353};
  const int32_t answ[] = {
      0b11010101011100110111000000111111, 0b00000000010000011101001010110100,
      0b11111110100111010011011101001101, 0b11110111000100110100111111010111,
      0b00000000000000000001000101100001, 0b11100010100000011110100010010001,
      0b11110000001110000101100000110010, 0b00001010000000111100001011101101,
      0b00010111001111001011010001101011, 0b00011010001001100100011110110000,
      0b11101011000011101000111100000001, 0b00000011001010011001010010100000,
      0b00011110111111100111000011011000, 0b11111101001100001011110011011111,
      0b00000000001100001001011100000101, 0b11010100000000100101110001000001,
      0b00100001110011101100010001100000, 0b11110010100001000000011100010111,
      0b00000110100000111000001011010110, 0b11111101110010101111011111010110};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmulh_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMULH_W_MM");
}

static void test_mmulh_mm_i64() {
  const size_t M = 1;
  const size_t N = 1;
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[] = {
      0b0111111111111111111111111111111111111111111111111111111111111111};
  const int64_t src2[] = {4};
  const int64_t answ[] = {
      0b0000000000000000000000000000000000000000000000000000000000000001};

  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mmulh_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMULH_MM I64");
}

static void test_mmulh_dw_mm() {
  const size_t M = 1;
  const size_t N = 1;
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[] = {
      0b0111111111111111111111111111111111111111111111111111111111111111};
  const int64_t src2[] = {4};
  const int64_t answ[] = {
      0b0000000000000000000000000000000000000000000000000000000000000001};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = mmulh_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMULH_DW_MM");
}

static void test_mmulh_mm() {
  test_mmulh_mm_i8();
  test_mmulh_b_mm();
  test_mmulh_mm_i16();
  test_mmulh_h_mm();
  test_mmulh_mm_i32();
  test_mmulh_w_mm();
  test_mmulh_mm_i64();
  test_mmulh_dw_mm();
}

static void test_mmulhu_mm_u8() {
  const uint8_t src1[] = {
      218, 219, 9,   166, 47,  113, 225, 53,  90,  48,  73,  171, 187, 75,
      45,  159, 234, 18,  62,  68,  39,  223, 64,  85,  20,  138, 77,  62,
      123, 227, 115, 76,  23,  162, 59,  121, 120, 182, 156, 76,  108, 97,
      30,  142, 12,  172, 95,  222, 185, 227, 156, 112, 173, 70,  57,  153,
      211, 109, 174, 126, 250, 44,  132, 202, 173, 124, 22,  250, 179, 25,
      17,  213, 127, 110, 131, 29,  93,  111, 214, 15};
  const uint8_t src2[] = {
      41,  233, 234, 147, 165, 60,  171, 120, 57,  45,  130, 68,  95,  151,
      44,  178, 82,  13,  131, 98,  203, 59,  18,  142, 108, 61,  222, 28,
      44,  135, 17,  238, 72,  121, 47,  130, 26,  195, 169, 120, 152, 150,
      199, 130, 240, 74,  101, 168, 143, 50,  212, 113, 59,  220, 34,  228,
      47,  43,  98,  153, 194, 170, 153, 35,  150, 12,  221, 174, 113, 167,
      157, 239, 122, 161, 243, 134, 101, 205, 25,  110};
  const uint8_t answ[] = {
      0b00100010, 0b11000111, 0b00001000, 0b01011111, 0b00011110, 0b00011010,
      0b10010110, 0b00011000, 0b00010100, 0b00001000, 0b00100101, 0b00101101,
      0b01000101, 0b00101100, 0b00000111, 0b01101110, 0b01001010, 0b00000000,
      0b00011111, 0b00011010, 0b00011110, 0b00110011, 0b00000100, 0b00101111,
      0b00001000, 0b00100000, 0b01000010, 0b00000110, 0b00010101, 0b01110111,
      0b00000111, 0b01000110, 0b00000110, 0b01001100, 0b00001010, 0b00111101,
      0b00001100, 0b10001010, 0b01100110, 0b00100011, 0b01000000, 0b00111000,
      0b00010111, 0b01001000, 0b00001011, 0b00110001, 0b00100101, 0b10010001,
      0b01100111, 0b00101100, 0b10000001, 0b00110001, 0b00100111, 0b00111100,
      0b00000111, 0b10001000, 0b00100110, 0b00010010, 0b01000010, 0b01001011,
      0b10111101, 0b00011101, 0b01001110, 0b00011011, 0b01100101, 0b00000101,
      0b00010010, 0b10101001, 0b01001111, 0b00010000, 0b00001010, 0b11000110,
      0b00111100, 0b01000101, 0b01111100, 0b00001111, 0b00100100, 0b01011000,
      0b00010100, 0b00000110};
  const size_t M = 5;
  const size_t N = 16;
  const size_t stride = N * sizeof(uint8_t);
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mmulhu_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MMULHU_MM U8");
}

static void test_mmulhu_b_mm() {
  const uint8_t src1[] = {
      218, 219, 9,   166, 47,  113, 225, 53,  90,  48,  73,  171, 187, 75,
      45,  159, 234, 18,  62,  68,  39,  223, 64,  85,  20,  138, 77,  62,
      123, 227, 115, 76,  23,  162, 59,  121, 120, 182, 156, 76,  108, 97,
      30,  142, 12,  172, 95,  222, 185, 227, 156, 112, 173, 70,  57,  153,
      211, 109, 174, 126, 250, 44,  132, 202, 173, 124, 22,  250, 179, 25,
      17,  213, 127, 110, 131, 29,  93,  111, 214, 15};
  const uint8_t src2[] = {
      41,  233, 234, 147, 165, 60,  171, 120, 57,  45,  130, 68,  95,  151,
      44,  178, 82,  13,  131, 98,  203, 59,  18,  142, 108, 61,  222, 28,
      44,  135, 17,  238, 72,  121, 47,  130, 26,  195, 169, 120, 152, 150,
      199, 130, 240, 74,  101, 168, 143, 50,  212, 113, 59,  220, 34,  228,
      47,  43,  98,  153, 194, 170, 153, 35,  150, 12,  221, 174, 113, 167,
      157, 239, 122, 161, 243, 134, 101, 205, 25,  110};
  const uint8_t answ[] = {
      0b00100010, 0b11000111, 0b00001000, 0b01011111, 0b00011110, 0b00011010,
      0b10010110, 0b00011000, 0b00010100, 0b00001000, 0b00100101, 0b00101101,
      0b01000101, 0b00101100, 0b00000111, 0b01101110, 0b01001010, 0b00000000,
      0b00011111, 0b00011010, 0b00011110, 0b00110011, 0b00000100, 0b00101111,
      0b00001000, 0b00100000, 0b01000010, 0b00000110, 0b00010101, 0b01110111,
      0b00000111, 0b01000110, 0b00000110, 0b01001100, 0b00001010, 0b00111101,
      0b00001100, 0b10001010, 0b01100110, 0b00100011, 0b01000000, 0b00111000,
      0b00010111, 0b01001000, 0b00001011, 0b00110001, 0b00100101, 0b10010001,
      0b01100111, 0b00101100, 0b10000001, 0b00110001, 0b00100111, 0b00111100,
      0b00000111, 0b10001000, 0b00100110, 0b00010010, 0b01000010, 0b01001011,
      0b10111101, 0b00011101, 0b01001110, 0b00011011, 0b01100101, 0b00000101,
      0b00010010, 0b10101001, 0b01001111, 0b00010000, 0b00001010, 0b11000110,
      0b00111100, 0b01000101, 0b01111100, 0b00001111, 0b00100100, 0b01011000,
      0b00010100, 0b00000110};
  const size_t M = 5;
  const size_t N = 16;
  const size_t stride = N * sizeof(uint8_t);
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = mmulhu_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MMULHU_B_MM");
}

static void test_mmulhu_mm_u16() {
  enum { M = 4, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[] = {30758, 62393, 62484, 60446, 7705,  1850,  21253,
                           42579, 43216, 46744, 44386, 60631, 4239,  53960,
                           28678, 26611, 26276, 286,   57133, 42063, 59641,
                           33884, 33149, 29777, 1605,  3263,  12685, 58911,
                           46617, 17989, 19605, 42204};
  const uint16_t src2[] = {23573, 39120, 31815, 28135, 49280, 46536, 9477,
                           8750,  24696, 56688, 65397, 5005,  54921, 48071,
                           62288, 5782,  32016, 60452, 55872, 15557, 16440,
                           56870, 28274, 32010, 59005, 58429, 50422, 33614,
                           34340, 59682, 35837, 2521};
  const uint16_t answ[] = {
      0b0010101100110111, 0b1001000101111011, 0b0111011001111101,
      0b0110010101011101, 0b0001011010100001, 0b0000010100100001,
      0b0000110000000001, 0b0001011000110100, 0b0011111110011101,
      0b1001110111110001, 0b1010110100000011, 0b0001001000010110,
      0b0000110111100000, 0b1001101010011011, 0b0110101001111000,
      0b0000100100101011, 0b0011001000100100, 0b0000000100000111,
      0b1011111001000100, 0b0010011100000000, 0b0011101001110001,
      0b0111001011011011, 0b0011011111011101, 0b0011100011010000,
      0b0000010110100101, 0b0000101101011101, 0b0010011000011111,
      0b0111011000000111, 0b0101111101101010, 0b0011111111111110,
      0b0010100111100000, 0b0000011001010111};

  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mmulhu_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MMULHU_MM U16");
}

static void test_mmulhu_h_mm() {
  enum { M = 4, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[] = {30758, 62393, 62484, 60446, 7705,  1850,  21253,
                           42579, 43216, 46744, 44386, 60631, 4239,  53960,
                           28678, 26611, 26276, 286,   57133, 42063, 59641,
                           33884, 33149, 29777, 1605,  3263,  12685, 58911,
                           46617, 17989, 19605, 42204};
  const uint16_t src2[] = {23573, 39120, 31815, 28135, 49280, 46536, 9477,
                           8750,  24696, 56688, 65397, 5005,  54921, 48071,
                           62288, 5782,  32016, 60452, 55872, 15557, 16440,
                           56870, 28274, 32010, 59005, 58429, 50422, 33614,
                           34340, 59682, 35837, 2521};
  const uint16_t answ[] = {
      0b0010101100110111, 0b1001000101111011, 0b0111011001111101,
      0b0110010101011101, 0b0001011010100001, 0b0000010100100001,
      0b0000110000000001, 0b0001011000110100, 0b0011111110011101,
      0b1001110111110001, 0b1010110100000011, 0b0001001000010110,
      0b0000110111100000, 0b1001101010011011, 0b0110101001111000,
      0b0000100100101011, 0b0011001000100100, 0b0000000100000111,
      0b1011111001000100, 0b0010011100000000, 0b0011101001110001,
      0b0111001011011011, 0b0011011111011101, 0b0011100011010000,
      0b0000010110100101, 0b0000101101011101, 0b0010011000011111,
      0b0111011000000111, 0b0101111101101010, 0b0011111111111110,
      0b0010100111100000, 0b0000011001010111};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = mmulhu_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MMULHU_H_MM");
}

static void test_mmulhu_mm_u32() {
  enum { M = 5, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[] = {2172948444, 359704118,  1395972006, 2973813094,
                           2627025149, 1024097518, 1585699157, 279560401,
                           1264164351, 513761432,  135947367,  1100995243,
                           2072505173, 3639156404, 3495280324, 920348256,
                           1539165040, 1097253775, 2690046313, 1538064200};
  const uint32_t src2[] = {3676752209, 2810261183, 1818098602, 2029977825,
                           754658238,  2592221485, 1446412455, 2579399226,
                           981211306,  3563678362, 2744399798, 3600055577,
                           1318098192, 1325016133, 197231042,  3179621507,
                           3911313836, 156625336,  3014748854, 1815934928};
  const uint32_t answ[] = {
      0b01101110111000000000011010011000, 0b00001110000001110100111000011011,
      0b00100011001110001101011011111000, 0b01010011110001101110111010001100,
      0b00011011100000110100011011011011, 0b00100100110101110101100001001100,
      0b00011111110101000110101001010001, 0b00001010000000011101101010110011,
      0b00010001001101101101010001110110, 0b00011001011010001001100000011100,
      0b00000101001011010111111011110011, 0b00110111000000011011000101000110,
      0b00100101111010010010111000010110, 0b01000010111010101111100110111110,
      0b00001001100100010010100101110000, 0b00101000100111001000010000011010,
      0b01010011100010111110010101011101, 0b00000010011000101000111110110100,
      0b01110000100010111101100011100110, 0b00100110110000101101000011111100};

  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mmulhu_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MMULHU_MM U32");
}

static void test_mmulhu_w_mm() {
  enum { M = 5, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[] = {2172948444, 359704118,  1395972006, 2973813094,
                           2627025149, 1024097518, 1585699157, 279560401,
                           1264164351, 513761432,  135947367,  1100995243,
                           2072505173, 3639156404, 3495280324, 920348256,
                           1539165040, 1097253775, 2690046313, 1538064200};
  const uint32_t src2[] = {3676752209, 2810261183, 1818098602, 2029977825,
                           754658238,  2592221485, 1446412455, 2579399226,
                           981211306,  3563678362, 2744399798, 3600055577,
                           1318098192, 1325016133, 197231042,  3179621507,
                           3911313836, 156625336,  3014748854, 1815934928};
  const uint32_t answ[] = {
      0b01101110111000000000011010011000, 0b00001110000001110100111000011011,
      0b00100011001110001101011011111000, 0b01010011110001101110111010001100,
      0b00011011100000110100011011011011, 0b00100100110101110101100001001100,
      0b00011111110101000110101001010001, 0b00001010000000011101101010110011,
      0b00010001001101101101010001110110, 0b00011001011010001001100000011100,
      0b00000101001011010111111011110011, 0b00110111000000011011000101000110,
      0b00100101111010010010111000010110, 0b01000010111010101111100110111110,
      0b00001001100100010010100101110000, 0b00101000100111001000010000011010,
      0b01010011100010111110010101011101, 0b00000010011000101000111110110100,
      0b01110000100010111101100011100110, 0b00100110110000101101000011111100};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = mmulhu_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MMULHU_W_MM");
}

static void test_mmulhu_mm_u64() {
  const size_t M = 1;
  const size_t N = 1;
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[] = {
      0b1111111111111111111111111111111111111111111111111111111111111111};
  const uint64_t src2[] = {4};
  const uint64_t answ[] = {0b11};

  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mmulhu_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MMULHU_MM U64");
}

static void test_mmulhu_dw_mm() {
  const size_t M = 1;
  const size_t N = 1;
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[] = {
      0b1111111111111111111111111111111111111111111111111111111111111111};
  const uint64_t src2[] = {4};
  const uint64_t answ[] = {0b11};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mmulhu_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MMULHU_DW_MM");
}

static void test_mmulhu_mm() {
  test_mmulhu_mm_u8();
  test_mmulhu_b_mm();
  test_mmulhu_mm_u16();
  test_mmulhu_h_mm();
  test_mmulhu_mm_u32();
  test_mmulhu_w_mm();
  test_mmulhu_mm_u64();
  test_mmulhu_dw_mm();
}

static void test_mmulhsu_mm_u8i8() {
  const int8_t src1[] = {-119, -45, 30,  66, -1,   35,  -33,  -48,
                         -75,  -81, -78, 94, -100, -16, -123, 62};
  const uint8_t src2[] = {71, 170, 59,  87,  175, 158, 104, 165,
                          71, 60,  188, 221, 213, 133, 162, 38};
  const int8_t answ[] = {0b11011110, 0b11100010, 0b00000110, 0b00010110,
                         0b11111111, 0b00010101, 0b11110010, 0b11100001,
                         0b11101011, 0b11101101, 0b11000110, 0b01010001,
                         0b10101100, 0b11110111, 0b10110010, 0b00001001};
  const size_t M = 2;
  const size_t N = 8;
  const size_t stride = N * sizeof(uint8_t);
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmulhsu_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMULHSU_MM U8I8");
}

static void test_mmulhsu_b_mm() {
  const int8_t src1[] = {-119, -45, 30,  66, -1,   35,  -33,  -48,
                         -75,  -81, -78, 94, -100, -16, -123, 62};
  const uint8_t src2[] = {71, 170, 59,  87,  175, 158, 104, 165,
                          71, 60,  188, 221, 213, 133, 162, 38};
  const int8_t answ[] = {0b11011110, 0b11100010, 0b00000110, 0b00010110,
                         0b11111111, 0b00010101, 0b11110010, 0b11100001,
                         0b11101011, 0b11101101, 0b11000110, 0b01010001,
                         0b10101100, 0b11110111, 0b10110010, 0b00001001};
  const size_t M = 2;
  const size_t N = 8;
  const size_t stride = N * sizeof(uint8_t);
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = mmulhsu_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MMULHSU_B_MM");
}

static void test_mmulhsu_mm_u16i16() {
  const size_t M = 2;
  const size_t N = 8;
  const size_t stride = N * sizeof(uint16_t);
  const int16_t src1[] = {-23927, -27930, -17071, -10024, -8550, -20789,
                          -27779, -7397,  -1849,  -9510,  22406, 4447,
                          -15129, 22404,  -13497, 26261};
  const uint16_t src2[] = {27991, 51391, 28406, 5930,  54367, 50554,
                           722,   61530, 28493, 56015, 46403, 53864,
                           9045,  63484, 28683, 30193};
  const int16_t answ[] = {
      0b1101100000010100, 0b1010101001110010, 0b1110001100011000,
      0b1111110001110100, 0b1110010001001011, 0b1100000101011011,
      0b1111111011001101, 0b1110010011011111, 0b1111110011011100,
      0b1110000000111111, 0b0011110111111000, 0b0000111001000110,
      0b1111011111010111, 0b0101010011000110, 0b1110100011101100,
      0b0010111101000010};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmulhsu_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMULHSU_MM U16I16");
}

static void test_mmulhsu_h_mm() {
  const size_t M = 2;
  const size_t N = 8;
  const size_t stride = N * sizeof(uint16_t);
  const int16_t src1[] = {-23927, -27930, -17071, -10024, -8550, -20789,
                          -27779, -7397,  -1849,  -9510,  22406, 4447,
                          -15129, 22404,  -13497, 26261};
  const uint16_t src2[] = {27991, 51391, 28406, 5930,  54367, 50554,
                           722,   61530, 28493, 56015, 46403, 53864,
                           9045,  63484, 28683, 30193};
  const int16_t answ[] = {
      0b1101100000010100, 0b1010101001110010, 0b1110001100011000,
      0b1111110001110100, 0b1110010001001011, 0b1100000101011011,
      0b1111111011001101, 0b1110010011011111, 0b1111110011011100,
      0b1110000000111111, 0b0011110111111000, 0b0000111001000110,
      0b1111011111010111, 0b0101010011000110, 0b1110100011101100,
      0b0010111101000010};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = mmulhsu_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MMULHSU_H_MM");
}

static void test_mmulhsu_mm_u32i32() {
  const size_t M = 3;
  const size_t N = 4;
  const size_t stride = N * sizeof(uint32_t);
  const int32_t src1[] = {339215551, -1941713488, -2057274773, 1140599006,
                          654007477, -1965774859, -799119959,  1377821961,
                          813335216, 130319061,   1473989864,  -2085806316};
  const uint32_t src2[] = {2839631618, 3369629408, 792889355,  3177381946,
                           2345233770, 2096172162, 3088374241, 1618641259,
                           868284847,  984913835,  89281062,   2726419517};
  const int32_t answ[] = {
      0b00001101010111100010010000111010, 0b10100101001100110001110000101001,
      0b11101001010111001101100000101111, 0b00110010010010110111010010111111,
      0b00010101010010010010011101011011, 0b11000110110100001010110111010011,
      0b11011101101111111111011111100111, 0b00011110111100110100001010011010,
      0b00001001110011001111001100110011, 0b00000001110010000000000001101010,
      0b00000001110100111000100011110000, 0b10110001000101000111110011110010};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmulhsu_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMULHSU_MM U32I32");
}

static void test_mmulhsu_w_mm() {
  const size_t M = 3;
  const size_t N = 4;
  const size_t stride = N * sizeof(uint32_t);
  const int32_t src1[] = {339215551, -1941713488, -2057274773, 1140599006,
                          654007477, -1965774859, -799119959,  1377821961,
                          813335216, 130319061,   1473989864,  -2085806316};
  const uint32_t src2[] = {2839631618, 3369629408, 792889355,  3177381946,
                           2345233770, 2096172162, 3088374241, 1618641259,
                           868284847,  984913835,  89281062,   2726419517};
  const int32_t answ[] = {
      0b00001101010111100010010000111010, 0b10100101001100110001110000101001,
      0b11101001010111001101100000101111, 0b00110010010010110111010010111111,
      0b00010101010010010010011101011011, 0b11000110110100001010110111010011,
      0b11011101101111111111011111100111, 0b00011110111100110100001010011010,
      0b00001001110011001111001100110011, 0b00000001110010000000000001101010,
      0b00000001110100111000100011110000, 0b10110001000101000111110011110010};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = mmulhsu_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MMULHSU_W_MM");
}

static void test_mmulhsu_mm_u64i64() {
  const size_t M = 1;
  const size_t N = 1;
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[] = {
      0b0101011010000000100111011011011000000010011011100100011101111001};
  const uint64_t src2[] = {4};
  const uint64_t answ[] = {
      0b0000000000000000000000000000000000000000000000000000000000000001};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mmulhu_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMULHU_MM U64I64");
}

static void test_mmulhsu_dw_mm() {
  const size_t M = 1;
  const size_t N = 1;
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[] = {
      0b0101011010000000100111011011011000000010011011100100011101111001};
  const uint64_t src2[] = {4};
  const uint64_t answ[] = {
      0b0000000000000000000000000000000000000000000000000000000000000001};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = mmulhu_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MMULHU_DW_MM");
}

static void test_mmulhsu_mm() {
  test_mmulhsu_mm_u8i8();
  test_mmulhsu_b_mm();
  test_mmulhsu_mm_u16i16();
  test_mmulhsu_h_mm();
  test_mmulhsu_mm_u32i32();
  test_mmulhsu_w_mm();
  test_mmulhsu_mm_u64i64();
  test_mmulhsu_dw_mm();
}

static void test_msmul_mm_i8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      99,  -15, -82, -84,  104,  6,  38,   -115, 103, -111, 4,    -66,  -107,
      64,  110, 7,   -20,  -44,  24, 1,    -25,  -6,  18,   -60,  1,    -125,
      92,  -6,  10,  -121, -105, 22, 42,   13,   60,  69,   -52,  -63,  120,
      14,  59,  7,   70,   -80,  12, 4,    -50,  -11, 112,  -119, -104, -37,
      -71, 11,  -52, 106,  52,   12, -114, -2,   -78, -30,  99,   -80};
  const int8_t src2[M * N] = {
      83,  -50,  7,    -82,  -119, 33,  61,  93,   105,  103,  116, -58, 117,
      -45, -27,  -109, 46,   -92,  84,  -96, 75,   -105, 92,   -66, -38, 65,
      40,  -102, 17,   -118, -115, -21, -99, 94,   -45,  -123, 29,  -99, -102,
      11,  -4,   -62,  -75,  -18,  -29, 111, -128, -109, -110, 61,  90,  -30,
      -1,  -44,  -73,  -20,  0,    62,  -4,  45,   101,  8,    124, -80};
  const int8_t answ[M * N] = {
      127,  127,  -128, 127,  -128, 127,  127,  -128, 127,  -128, 127,
      127,  -128, -128, -128, -128, -128, 127,  127,  -96,  -128, 127,
      127,  127,  -38,  -128, 127,  127,  127,  127,  127,  -128, -128,
      127,  -128, -128, -128, 127,  -128, 127,  -128, -128, -128, 127,
      -128, 127,  127,  127,  -128, -128, -128, 127,  71,   -128, 127,
      -128, 0,    127,  127,  -90,  -128, -128, 127,  127};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msmul_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSMUL_MM I8");
}

static void test_msmul_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int8_t);
  const int8_t src1[M * N] = {
      99,  -15, -82, -84,  104,  6,  38,   -115, 103, -111, 4,    -66,  -107,
      64,  110, 7,   -20,  -44,  24, 1,    -25,  -6,  18,   -60,  1,    -125,
      92,  -6,  10,  -121, -105, 22, 42,   13,   60,  69,   -52,  -63,  120,
      14,  59,  7,   70,   -80,  12, 4,    -50,  -11, 112,  -119, -104, -37,
      -71, 11,  -52, 106,  52,   12, -114, -2,   -78, -30,  99,   -80};
  const int8_t src2[M * N] = {
      83,  -50,  7,    -82,  -119, 33,  61,  93,   105,  103,  116, -58, 117,
      -45, -27,  -109, 46,   -92,  84,  -96, 75,   -105, 92,   -66, -38, 65,
      40,  -102, 17,   -118, -115, -21, -99, 94,   -45,  -123, 29,  -99, -102,
      11,  -4,   -62,  -75,  -18,  -29, 111, -128, -109, -110, 61,  90,  -30,
      -1,  -44,  -73,  -20,  0,    62,  -4,  45,   101,  8,    124, -80};
  const int8_t answ[M * N] = {
      127,  127,  -128, 127,  -128, 127,  127,  -128, 127,  -128, 127,
      127,  -128, -128, -128, -128, -128, 127,  127,  -96,  -128, 127,
      127,  127,  -38,  -128, 127,  127,  127,  127,  127,  -128, -128,
      127,  -128, -128, -128, 127,  -128, 127,  -128, -128, -128, 127,
      -128, 127,  127,  127,  -128, -128, -128, 127,  71,   -128, 127,
      -128, 0,    127,  127,  -90,  -128, -128, 127,  127};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  mint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msmul_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSMUL_B_MM");
}

static void test_msmul_mm_i16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      29301,  2451,   737,    29180,  -11209, -5695,  4889,   1306,
      6075,   -25329, 7485,   17906,  -28018, -2861,  -10838, 17617,
      -11135, 11232,  23672,  15185,  -1191,  -32254, 9962,   30758,
      14418,  31452,  -15443, -2632,  -29542, -16936, -14962, -13953,
      17833,  -2111,  -8963,  -29889, -7219,  -19902, -6563,  -2916,
      1166,   -21414, 8739,   -6807,  3573,   17192,  19035,  3537,
      -6977,  3885,   9626,   149,    -3842,  5714,   -21446, 12424,
      -8906,  27318,  -739,   -32459, 5208,   -20207, -14436, -24733};
  const int16_t src2[M * N] = {
      3938,   -27486, 21421,  7346,   -6679,  -5522,  12804, -12499,
      -31775, 29512,  15832,  16968,  -7350,  -17987, 4123,  20432,
      23686,  -3350,  22087,  -14151, -23946, -595,   7524,  -30674,
      30175,  31038,  11024,  -18106, -3535,  -15476, -4363, -9108,
      7765,   7576,   3870,   -23725, -30707, 16041,  18629, 21148,
      1702,   28442,  9038,   -20916, 21137,  26221,  23278, 16486,
      -11277, 12265,  -29544, -29359, 4640,   24803,  -55,   12044,
      15810,  -23821, -15527, -17612, -8119,  -1488,  -3137, 12883};
  const int16_t answ[M * N] = {
      32767,  -32768, 32767,  32767,  32767,  32767,  32767,  -32768,
      -32768, -32768, 32767,  32767,  32767,  32767,  -32768, 32767,
      -32768, -32768, 32767,  -32768, 32767,  32767,  32767,  -32768,
      32767,  32767,  -32768, 32767,  32767,  32767,  32767,  32767,
      32767,  -32768, -32768, 32767,  32767,  -32768, -32768, -32768,
      32767,  -32768, 32767,  32767,  32767,  32767,  32767,  32767,
      32767,  32767,  -32768, -32768, -32768, 32767,  32767,  32767,
      -32768, -32768, 32767,  32767,  -32768, 32767,  32767,  -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msmul_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSMUL_MM I16");
}

static void test_msmul_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(int16_t);
  const int16_t src1[M * N] = {
      29301,  2451,   737,    29180,  -11209, -5695,  4889,   1306,
      6075,   -25329, 7485,   17906,  -28018, -2861,  -10838, 17617,
      -11135, 11232,  23672,  15185,  -1191,  -32254, 9962,   30758,
      14418,  31452,  -15443, -2632,  -29542, -16936, -14962, -13953,
      17833,  -2111,  -8963,  -29889, -7219,  -19902, -6563,  -2916,
      1166,   -21414, 8739,   -6807,  3573,   17192,  19035,  3537,
      -6977,  3885,   9626,   149,    -3842,  5714,   -21446, 12424,
      -8906,  27318,  -739,   -32459, 5208,   -20207, -14436, -24733};
  const int16_t src2[M * N] = {
      3938,   -27486, 21421,  7346,   -6679,  -5522,  12804, -12499,
      -31775, 29512,  15832,  16968,  -7350,  -17987, 4123,  20432,
      23686,  -3350,  22087,  -14151, -23946, -595,   7524,  -30674,
      30175,  31038,  11024,  -18106, -3535,  -15476, -4363, -9108,
      7765,   7576,   3870,   -23725, -30707, 16041,  18629, 21148,
      1702,   28442,  9038,   -20916, 21137,  26221,  23278, 16486,
      -11277, 12265,  -29544, -29359, 4640,   24803,  -55,   12044,
      15810,  -23821, -15527, -17612, -8119,  -1488,  -3137, 12883};
  const int16_t answ[M * N] = {
      32767,  -32768, 32767,  32767,  32767,  32767,  32767,  -32768,
      -32768, -32768, 32767,  32767,  32767,  32767,  -32768, 32767,
      -32768, -32768, 32767,  -32768, 32767,  32767,  32767,  -32768,
      32767,  32767,  -32768, 32767,  32767,  32767,  32767,  32767,
      32767,  -32768, -32768, 32767,  32767,  -32768, -32768, -32768,
      32767,  -32768, 32767,  32767,  32767,  32767,  32767,  32767,
      32767,  32767,  -32768, -32768, -32768, 32767,  32767,  32767,
      -32768, -32768, 32767,  32767,  -32768, 32767,  32767,  -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  mint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msmul_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSMUL_H_MM");
}

static void test_msmul_mm_i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {13739579,  -16390010, -14431378, 18988454,
                               -13063943, 15094868,  11534564,  -11802916,
                               16074729,  -17143476, -1665191,  -3054550,
                               -216659,   9267650,   6939835,   -634831};
  const int32_t src2[M * N] = {17816117,  -16383194, -6374753,  -10006198,
                               14802459,  12395176,  7869564,   -19657823,
                               -8851554,  -10217987, 11781097,  -5944804,
                               -11506121, 14720868,  -13678583, -3759959};
  const int32_t answ[M * N] = {
      2147483647, 2147483647, 2147483647,  -2147483648, -2147483648, 2147483647,
      2147483647, 2147483647, -2147483648, 2147483647,  -2147483648, 2147483647,
      2147483647, 2147483647, -2147483648, 2147483647};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msmul_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSMUL_MM I32");
}

static void test_msmul_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(int32_t);
  const int32_t src1[M * N] = {13739579,  -16390010, -14431378, 18988454,
                               -13063943, 15094868,  11534564,  -11802916,
                               16074729,  -17143476, -1665191,  -3054550,
                               -216659,   9267650,   6939835,   -634831};
  const int32_t src2[M * N] = {17816117,  -16383194, -6374753,  -10006198,
                               14802459,  12395176,  7869564,   -19657823,
                               -8851554,  -10217987, 11781097,  -5944804,
                               -11506121, 14720868,  -13678583, -3759959};
  const int32_t answ[M * N] = {
      2147483647, 2147483647, 2147483647,  -2147483648, -2147483648, 2147483647,
      2147483647, 2147483647, -2147483648, 2147483647,  -2147483648, 2147483647,
      2147483647, 2147483647, -2147483648, 2147483647};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  mint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msmul_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSMUL_W_MM");
}

static void test_msmul_mm_i64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  const int64_t src2[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  const int64_t answ[M * N] = {0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFFF,
                               0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFFF};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msmul_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSMUL_MM I64");
}

static void test_msmul_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(int64_t);
  const int64_t src1[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  const int64_t src2[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000};
  const int64_t answ[M * N] = {0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFFF,
                               0x7FFFFFFFFFFFFFFF, 0x7FFFFFFFFFFFFFFF};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  mint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msmul_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSMUL_DW_MM");
}

static void test_msmul_mm() {
  test_msmul_mm_i8();
  test_msmul_b_mm();
  test_msmul_mm_i16();
  test_msmul_h_mm();
  test_msmul_mm_i32();
  test_msmul_w_mm();
  test_msmul_mm_i64();
  test_msmul_dw_mm();
}

static void test_msmulu_mm_u8() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t src2[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t answ[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msmulu_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSMULU_MM U8");
}

static void test_msmulu_b_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint8_t);
  const uint8_t src1[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t src2[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  const uint8_t answ[M * N] = {
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  muint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  muint8_t md = msmulu_b_mm(ms1, ms2);
  msc_m(md, u8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, u8_buffer, M * N, "MSMULU_B_MM");
}

static void test_msmulu_mm_u16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const uint16_t src2[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const uint16_t answ[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msmulu_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSMULU_MM U16");
}

static void test_msmulu_h_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const uint16_t src1[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const uint16_t src2[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  const uint16_t answ[M * N] = {
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535,
      65535, 65535, 65535, 65535};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  muint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  muint16_t md = msmulu_h_mm(ms1, ms2);
  msc_m(md, u16_buffer, stride);
  EXCEPT_U16_ARRAY_EQ(answ, u16_buffer, M * N, "MSMULU_H_MM");
}

static void test_msmulu_mm_u32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t src2[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t answ[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msmulu_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSMULU_MM U32");
}

static void test_msmulu_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const uint32_t src1[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t src2[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  const uint32_t answ[M * N] = {4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295,
                                4294967295, 4294967295, 4294967295, 4294967295};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  muint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  muint32_t md = msmulu_w_mm(ms1, ms2);
  msc_m(md, u32_buffer, stride);
  EXCEPT_U32_ARRAY_EQ(answ, u32_buffer, M * N, "MSMULU_W_MM");
}

static void test_msmulu_mm_u64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const uint64_t src2[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const uint64_t answ[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msmulu_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSMULU_MM U64");
}

static void test_msmulu_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const uint64_t src1[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const uint64_t src2[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  const uint64_t answ[M * N] = {0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF,
                                0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  muint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  muint64_t md = msmulu_dw_mm(ms1, ms2);
  msc_m(md, u64_buffer, stride);
  EXCEPT_U64_ARRAY_EQ(answ, u64_buffer, M * N, "MSMULU_DW_MM");
}

static void test_msmulu_mm() {
  test_msmulu_mm_u8();
  test_msmulu_b_mm();
  test_msmulu_mm_u16();
  test_msmulu_h_mm();
  test_msmulu_mm_u32();
  test_msmulu_w_mm();
  test_msmulu_mm_u64();
  test_msmulu_dw_mm();
}

static void test_msmulsu_mm_u8i8() {
  enum { M = 2, N = 16 };
  const size_t stride = N * sizeof(uint8_t);
  const int8_t src1[M * N] = {119, 80,  -118, 64,  -57, -115, 102,  -127,
                              -76, -83, 43,   117, -4,  41,   -59,  -42,
                              14,  -90, 92,   37,  11,  104,  -49,  35,
                              48,  -97, -71,  -9,  -77, -97,  -113, 20};
  const uint8_t src2[M * N] = {3,   240, 85,  24,  244, 18,  250, 230,
                               141, 153, 154, 149, 156, 120, 63,  167,
                               28,  16,  42,  101, 153, 63,  181, 174,
                               169, 183, 134, 164, 44,  60,  37,  38};
  const int8_t answ[M * N] = {127,  127,  -128, 127,  -128, -128, 127,  -128,
                              -128, -128, 127,  127,  -128, 127,  -128, -128,
                              127,  -128, 127,  127,  127,  127,  -128, 127,
                              127,  -128, -128, -128, -128, -128, -128, 127};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msmulsu_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_U8_ARRAY_EQ(answ, i8_buffer, M * N, "MSMULSU_MM U8I8");
}

static void test_msmulsu_b_mm() {
  enum { M = 2, N = 16 };
  const size_t stride = N * sizeof(uint8_t);
  const int8_t src1[M * N] = {119, 80,  -118, 64,  -57, -115, 102,  -127,
                              -76, -83, 43,   117, -4,  41,   -59,  -42,
                              14,  -90, 92,   37,  11,  104,  -49,  35,
                              48,  -97, -71,  -9,  -77, -97,  -113, 20};
  const uint8_t src2[M * N] = {3,   240, 85,  24,  244, 18,  250, 230,
                               141, 153, 154, 149, 156, 120, 63,  167,
                               28,  16,  42,  101, 153, 63,  181, 174,
                               169, 183, 134, 164, 44,  60,  37,  38};
  const int8_t answ[M * N] = {127,  127,  -128, 127,  -128, -128, 127,  -128,
                              -128, -128, 127,  127,  -128, 127,  -128, -128,
                              127,  -128, 127,  127,  127,  127,  -128, 127,
                              127,  -128, -128, -128, -128, -128, -128, 127};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, stride);
  muint8_t ms2 = mlc_m(src2, stride);
  mint8_t md = msmulsu_b_mm(ms1, ms2);
  msc_m(md, i8_buffer, stride);
  EXCEPT_I8_ARRAY_EQ(answ, i8_buffer, M * N, "MSMULSU_B_MM");
}

static void test_msmulsu_mm_u16i16() {
  enum { M = 3, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const int16_t src1[M * N] = {12570, -4182,  -12948, -6352,  -16061, -6522,
                               21739, -6619,  17381,  -14151, 16962,  -20551,
                               -5469, -13500, 7955,   -20216, 32108,  -31408,
                               -6174, 23767,  -29594, -8618,  -19535, -26600};
  const uint16_t src2[M * N] = {44384, 58678, 3553,  60908, 47270, 63079,
                                60860, 17808, 44454, 53379, 59179, 36968,
                                23005, 24397, 2231,  21756, 32019, 37014,
                                12897, 45225, 41995, 47049, 8203,  57241};
  const int16_t answ[M * N] = {32767,  -32768, -32768, -32768, -32768, -32768,
                               32767,  -32768, 32767,  -32768, 32767,  -32768,
                               -32768, -32768, 32767,  -32768, 32767,  -32768,
                               -32768, 32767,  -32768, -32768, -32768, -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msmulsu_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSMULSU_MM U16I16");
}

static void test_msmulsu_h_mm() {
  enum { M = 3, N = 8 };
  const size_t stride = N * sizeof(uint16_t);
  const int16_t src1[M * N] = {12570, -4182,  -12948, -6352,  -16061, -6522,
                               21739, -6619,  17381,  -14151, 16962,  -20551,
                               -5469, -13500, 7955,   -20216, 32108,  -31408,
                               -6174, 23767,  -29594, -8618,  -19535, -26600};
  const uint16_t src2[M * N] = {44384, 58678, 3553,  60908, 47270, 63079,
                                60860, 17808, 44454, 53379, 59179, 36968,
                                23005, 24397, 2231,  21756, 32019, 37014,
                                12897, 45225, 41995, 47049, 8203,  57241};
  const int16_t answ[M * N] = {32767,  -32768, -32768, -32768, -32768, -32768,
                               32767,  -32768, 32767,  -32768, 32767,  -32768,
                               -32768, -32768, 32767,  -32768, 32767,  -32768,
                               -32768, 32767,  -32768, -32768, -32768, -32768};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, stride);
  muint16_t ms2 = mlc_m(src2, stride);
  mint16_t md = msmulsu_h_mm(ms1, ms2);
  msc_m(md, i16_buffer, stride);
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MSMULSU_H_MM");
}

static void test_msmulsu_mm_u32i32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const int32_t src1[M * N] = {525950382,  35933534,    -2082280113, 212601511,
                               2130135820, 885633054,   410308700,   1745774321,
                               1667970820, -2082882220, -135817237,  836449302,
                               1825651948, 1843995390,  -478014602,  693390629};
  const uint32_t src2[M * N] = {762462384,  2566111694, 3986252303, 2873400204,
                                2192248108, 2704940799, 3322736292, 2125716816,
                                3992748658, 2035863641, 3096972725, 3108907365,
                                1045945482, 909580421,  799901707,  519090295};
  const int32_t answ[M * N] = {
      2147483647, 2147483647, -2147483648, 2147483647,  2147483647,  2147483647,
      2147483647, 2147483647, 2147483647,  -2147483648, -2147483648, 2147483647,
      2147483647, 2147483647, -2147483648, 2147483647};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msmulsu_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSMULSU_MM U32I32");
}

static void test_msmulsu_w_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(uint32_t);
  const int32_t src1[M * N] = {525950382,  35933534,    -2082280113, 212601511,
                               2130135820, 885633054,   410308700,   1745774321,
                               1667970820, -2082882220, -135817237,  836449302,
                               1825651948, 1843995390,  -478014602,  693390629};
  const uint32_t src2[M * N] = {762462384,  2566111694, 3986252303, 2873400204,
                                2192248108, 2704940799, 3322736292, 2125716816,
                                3992748658, 2035863641, 3096972725, 3108907365,
                                1045945482, 909580421,  799901707,  519090295};
  const int32_t answ[M * N] = {
      2147483647, 2147483647, -2147483648, 2147483647,  2147483647,  2147483647,
      2147483647, 2147483647, 2147483647,  -2147483648, -2147483648, 2147483647,
      2147483647, 2147483647, -2147483648, 2147483647};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, stride);
  muint32_t ms2 = mlc_m(src2, stride);
  mint32_t md = msmulsu_w_mm(ms1, ms2);
  msc_m(md, i32_buffer, stride);
  EXCEPT_I32_ARRAY_EQ(answ, i32_buffer, M * N, "MSMULSU_W_MM");
}

static void test_msmulsu_mm_u64i64() {
  enum { M = 5, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const int64_t src1[M * N] = {-557083716674211123,  -2205221404755972203,
                               8746798442008181958,  -3294148451662967088,
                               -2713815140279497021, -4321929023793918143,
                               8352848781433507242,  -1558240372368333550,
                               -8913847676019468474, 5989545924917948690};
  const uint64_t src2[M * N] = {
      481396561439124149ull,   2605661888422107903ull,  16522193339830260486ull,
      12340647094999714009ull, 12696871045608379226ull, 7640334777117278173ull,
      10686427431294166339ull, 14741961379003308057ull, 379264457081233260ull,
      1173009046292533656ull};
  const int64_t answ[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x7FFFFFFFFFFFFFFF, 0x8000000000000000,
                               0x8000000000000000, 0x8000000000000000,
                               0x7FFFFFFFFFFFFFFF, 0x8000000000000000,
                               0x8000000000000000, 0x7FFFFFFFFFFFFFFF};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msmulsu_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSMULSU_MM U64I64");
}

static void test_msmulsu_dw_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(uint64_t);
  const int64_t src1[M * N] = {-557083716674211123ll, -2205221404755972203ll,
                               8746798442008181958ll, -3294148451662967088ll};
  const uint64_t src2[M * N] = {481396561439124149ull, 2605661888422107903ull,
                                16522193339830260486ull,
                                12340647094999714009ull};
  const int64_t answ[M * N] = {0x8000000000000000, 0x8000000000000000,
                               0x7FFFFFFFFFFFFFFF, 0x8000000000000000};
  SET_MBA0_I64();
  msettilem(M);
  msettilen(N);
  mint64_t ms1 = mlc_m(src1, stride);
  muint64_t ms2 = mlc_m(src2, stride);
  mint64_t md = msmulsu_dw_mm(ms1, ms2);
  msc_m(md, i64_buffer, stride);
  EXCEPT_I64_ARRAY_EQ(answ, i64_buffer, M * N, "MSMULSU_DW_MM");
}

static void test_msmulsu_mm() {
  test_msmulsu_mm_u8i8();
  test_msmulsu_b_mm();
  test_msmulsu_mm_u16i16();
  test_msmulsu_h_mm();
  test_msmulsu_mm_u32i32();
  test_msmulsu_w_mm();
  test_msmulsu_mm_u64i64();
  test_msmulsu_dw_mm();
}

static void test_mwmul_mm_i8() {
  enum { M = 8, N = 8 };
  const int8_t src1[M * N] = {
      -3, -6, 9,  -3, 5,  -5,  4,  8,   5,   -7,  7,  1,   5,  -7,  7, -9,
      9,  -2, -9, 0,  -5, -11, -2, -11, -3,  7,   -7, -12, -3, -2,  4, -4,
      -4, 10, -4, -6, -6, 6,   -2, -10, -7,  4,   10, -3,  -4, 9,   0, 0,
      -7, 3,  -8, 1,  -5, 5,   -9, 8,   -11, -11, -9, -9,  -7, -12, 0, 20};
  const int8_t src2[M * N] = {
      7,   10,  2,  -9, -9,  11, -11, -9, 5,   -6, -1, -5, 7,   -12, -3,  -3,
      -11, -12, -4, 5,  -11, -2, -7,  -2, 3,   -4, 11, 1,  -10, -4,  -2,  -11,
      6,   9,   5,  -4, 5,   -7, -6,  10, 3,   5,  8,  5,  -4,  -2,  -12, 11,
      4,   -3,  -5, 8,  0,   10, -2,  -6, -11, 9,  5,  11, -8,  -6,  -11, -12};
  const int16_t answ[M * N] = {
      -21,  -60, 18, 27,  -45, -55, -44, -72, 25,  42,  -7,  -5,  35,
      84,   -21, 27, -99, 24,  36,  0,   55,  22,  14,  22,  -9,  -28,
      -77,  -12, 30, 8,   -8,  44,  -24, 90,  -20, 24,  -30, -42, 12,
      -100, -21, 20, 80,  -15, 16,  -18, 0,   0,   -28, -9,  40,  8,
      0,    50,  18, -48, 121, -99, -45, -99, 56,  72,  0,   -240};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, N * sizeof(int8_t));
  mint8_t ms2 = mlc_m(src2, N * sizeof(int8_t));
  mint16_t md = mwmul_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, i16_buffer, N * sizeof(int16_t));
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MWMUL_MM I8");
}

static void test_mwmul_b_mm() {
  enum { M = 8, N = 8 };
  const int8_t src1[M * N] = {
      -3, -6, 9,  -3, 5,  -5,  4,  8,   5,   -7,  7,  1,   5,  -7,  7, -9,
      9,  -2, -9, 0,  -5, -11, -2, -11, -3,  7,   -7, -12, -3, -2,  4, -4,
      -4, 10, -4, -6, -6, 6,   -2, -10, -7,  4,   10, -3,  -4, 9,   0, 0,
      -7, 3,  -8, 1,  -5, 5,   -9, 8,   -11, -11, -9, -9,  -7, -12, 0, 20};
  const int8_t src2[M * N] = {
      7,   10,  2,  -9, -9,  11, -11, -9, 5,   -6, -1, -5, 7,   -12, -3,  -3,
      -11, -12, -4, 5,  -11, -2, -7,  -2, 3,   -4, 11, 1,  -10, -4,  -2,  -11,
      6,   9,   5,  -4, 5,   -7, -6,  10, 3,   5,  8,  5,  -4,  -2,  -12, 11,
      4,   -3,  -5, 8,  0,   10, -2,  -6, -11, 9,  5,  11, -8,  -6,  -11, -12};
  const int16_t answ[M * N] = {
      -21,  -60, 18, 27,  -45, -55, -44, -72, 25,  42,  -7,  -5,  35,
      84,   -21, 27, -99, 24,  36,  0,   55,  22,  14,  22,  -9,  -28,
      -77,  -12, 30, 8,   -8,  44,  -24, 90,  -20, 24,  -30, -42, 12,
      -100, -21, 20, 80,  -15, 16,  -18, 0,   0,   -28, -9,  40,  8,
      0,    50,  18, -48, 121, -99, -45, -99, 56,  72,  0,   -240};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, N * sizeof(int8_t));
  mint8_t ms2 = mlc_m(src2, N * sizeof(int8_t));
  mint16_t md = mwmul_b_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, i16_buffer, N * sizeof(int16_t));
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MWMUL_B_MM");
}

static void test_mwmul_mm_i16() {
  enum { M = 4, N = 4 };
  const int16_t src1[M * N] = {-1895, 831,   2293, 3168, 438, 637,
                               932,   1428,  2908, 2060, 157, -2839,
                               -2659, -2820, 2772, -47};
  const int16_t src2[M * N] = {-2788, 1457, 1210,  459,   -2376, -1825,
                               1263,  1992, 1958,  -2065, -2949, 2404,
                               1597,  449,  -2349, 1701};
  const int32_t answ[M * N] = {5283260,  1210767,  2774530,  1454112,
                               -1040688, -1162525, 1177116,  2844576,
                               5693864,  -4253900, -462993,  -6824956,
                               -4246423, -1266180, -6511428, -79947};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, N * sizeof(int16_t));
  mint16_t ms2 = mlc_m(src2, N * sizeof(int16_t));
  mint32_t md = mwmul_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, i16_buffer, N * sizeof(int32_t));
  EXCEPT_I32_ARRAY_EQ(answ, i16_buffer, M * N, "MWMUL_MM I16");
}

static void test_mwmul_h_mm() {
  enum { M = 4, N = 4 };
  const int16_t src1[M * N] = {-1895, 831,   2293, 3168, 438, 637,
                               932,   1428,  2908, 2060, 157, -2839,
                               -2659, -2820, 2772, -47};
  const int16_t src2[M * N] = {-2788, 1457, 1210,  459,   -2376, -1825,
                               1263,  1992, 1958,  -2065, -2949, 2404,
                               1597,  449,  -2349, 1701};
  const int32_t answ[M * N] = {5283260,  1210767,  2774530,  1454112,
                               -1040688, -1162525, 1177116,  2844576,
                               5693864,  -4253900, -462993,  -6824956,
                               -4246423, -1266180, -6511428, -79947};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, N * sizeof(int16_t));
  mint16_t ms2 = mlc_m(src2, N * sizeof(int16_t));
  mint32_t md = mwmul_h_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, i16_buffer, N * sizeof(int32_t));
  EXCEPT_I32_ARRAY_EQ(answ, i16_buffer, M * N, "MWMUL_H_MM");
}

static void test_mwmul_mm_i32() {
  enum { M = 2, N = 2 };
  const int32_t src1[M * N] = {203145675, 119149800, -22246407, -14574383};
  const int32_t src2[M * N] = {138297232, 12199660, -135655937, -82639660};
  const int64_t answ[M * N] = {28094484545271600, 1453587049068000,
                               3017857186468359, 1204422055829780};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, N * sizeof(int32_t));
  mint32_t ms2 = mlc_m(src2, N * sizeof(int32_t));
  mint64_t md = mwmul_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, i32_buffer, N * sizeof(int64_t));
  EXCEPT_I64_ARRAY_EQ(answ, i32_buffer, M * N, "MWMUL_MM I32");
}

static void test_mwmul_w_mm() {
  enum { M = 2, N = 2 };
  const int32_t src1[M * N] = {203145675, 119149800, -22246407, -14574383};
  const int32_t src2[M * N] = {138297232, 12199660, -135655937, -82639660};
  const int64_t answ[M * N] = {28094484545271600, 1453587049068000,
                               3017857186468359, 1204422055829780};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, N * sizeof(int32_t));
  mint32_t ms2 = mlc_m(src2, N * sizeof(int32_t));
  mint64_t md = mwmul_w_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, i32_buffer, N * sizeof(int64_t));
  EXCEPT_I64_ARRAY_EQ(answ, i32_buffer, M * N, "MWMUL_W_MM");
}

static void test_mwmul_mm() {
  test_mwmul_mm_i8();
  test_mwmul_b_mm();
  test_mwmul_mm_i16();
  test_mwmul_h_mm();
  test_mwmul_mm_i32();
  test_mwmul_w_mm();
}

static void test_mwmulsu_mm_u8i8() {
  enum { M = 4, N = 8 };
  const int8_t src1[M * N] = {81,  -125, -106, -42, 98,   -43, -56, -25,
                              -50, -18,  -71,  -17, -119, 53,  69,  85,
                              50,  -80,  -18,  70,  86,   61,  -76, -97,
                              12,  90,   -124, -16, 30,   -2,  -42, 95};
  const uint8_t src2[M * N] = {161, 116, 50,  52,  2,   225, 131, 114,
                               24,  55,  158, 210, 210, 180, 234, 29,
                               114, 187, 247, 229, 18,  239, 143, 90,
                               78,  56,  189, 170, 110, 88,  141, 248};
  const int16_t answ[M * N] = {
      13041, -14500, -5300,  -2184, 196,    -9675, -7336,  -2850,
      -1200, -990,   -11218, -3570, -24990, 9540,  16146,  2465,
      5700,  -14960, -4446,  16030, 1548,   14579, -10868, -8730,
      936,   5040,   -23436, -2720, 3300,   -176,  -5922,  23560};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, N * sizeof(int8_t));
  muint8_t ms2 = mlc_m(src2, N * sizeof(int8_t));
  mint16_t md = mwmulsu_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, i16_buffer, N * sizeof(int16_t));
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MWMULSU_MM I8");
}

static void test_mwmulsu_b_mm() {
  enum { M = 4, N = 8 };
  const int8_t src1[M * N] = {81,  -125, -106, -42, 98,   -43, -56, -25,
                              -50, -18,  -71,  -17, -119, 53,  69,  85,
                              50,  -80,  -18,  70,  86,   61,  -76, -97,
                              12,  90,   -124, -16, 30,   -2,  -42, 95};
  const uint8_t src2[M * N] = {161, 116, 50,  52,  2,   225, 131, 114,
                               24,  55,  158, 210, 210, 180, 234, 29,
                               114, 187, 247, 229, 18,  239, 143, 90,
                               78,  56,  189, 170, 110, 88,  141, 248};
  const int16_t answ[M * N] = {
      13041, -14500, -5300,  -2184, 196,    -9675, -7336,  -2850,
      -1200, -990,   -11218, -3570, -24990, 9540,  16146,  2465,
      5700,  -14960, -4446,  16030, 1548,   14579, -10868, -8730,
      936,   5040,   -23436, -2720, 3300,   -176,  -5922,  23560};
  SET_MBA0_I8();
  msettilem(M);
  msettilen(N);
  mint8_t ms1 = mlc_m(src1, N * sizeof(int8_t));
  muint8_t ms2 = mlc_m(src2, N * sizeof(int8_t));
  mint16_t md = mwmulsu_b_mm(ms1, ms2);
  SET_MBA0_I16();
  msc_m(md, i16_buffer, N * sizeof(int16_t));
  EXCEPT_I16_ARRAY_EQ(answ, i16_buffer, M * N, "MWMULSU_B_MM");
}

static void test_mwmulsu_mm_u16i16() {
  enum { M = 5, N = 4 };
  const int16_t src1[M * N] = {
      3077,  26375, -20913, 7514, 17717,  -9715, -16914, -23166, -26067, -29969,
      19361, -7615, 31342,  -488, -32001, 30885, -19964, 26238,  -27401, -3596};
  const uint16_t src2[M * N] = {9247,  24106, 57254, 25477, 32342, 61247, 55044,
                                63986, 25280, 58538, 60416, 24499, 29328, 43107,
                                45334, 62614, 63110, 9277,  9822,  65182};
  const int32_t answ[M * N] = {
      28453019,   635795750,   -1197352902, 191434178,  573003214,
      -595014605, -931014216,  -1482299676, -658973760, -1754325322,
      1169714176, -186559885,  919198176,   -21036216,  -1450733334,
      1933833390, -1259928040, 243409926,   -269132622, -234394472};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, N * sizeof(int16_t));
  muint16_t ms2 = mlc_m(src2, N * sizeof(int16_t));
  mint32_t md = mwmulsu_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, i16_buffer, N * sizeof(int32_t));
  EXCEPT_I32_ARRAY_EQ(answ, i16_buffer, M * N, "MWMULSU_MM I16");
}

static void test_mwmulsu_h_mm() {
  enum { M = 5, N = 4 };
  const int16_t src1[M * N] = {
      3077,  26375, -20913, 7514, 17717,  -9715, -16914, -23166, -26067, -29969,
      19361, -7615, 31342,  -488, -32001, 30885, -19964, 26238,  -27401, -3596};
  const uint16_t src2[M * N] = {9247,  24106, 57254, 25477, 32342, 61247, 55044,
                                63986, 25280, 58538, 60416, 24499, 29328, 43107,
                                45334, 62614, 63110, 9277,  9822,  65182};
  const int32_t answ[M * N] = {
      28453019,   635795750,   -1197352902, 191434178,  573003214,
      -595014605, -931014216,  -1482299676, -658973760, -1754325322,
      1169714176, -186559885,  919198176,   -21036216,  -1450733334,
      1933833390, -1259928040, 243409926,   -269132622, -234394472};
  SET_MBA0_I16();
  msettilem(M);
  msettilen(N);
  mint16_t ms1 = mlc_m(src1, N * sizeof(int16_t));
  muint16_t ms2 = mlc_m(src2, N * sizeof(int16_t));
  mint32_t md = mwmulsu_h_mm(ms1, ms2);
  SET_MBA0_I32();
  msc_m(md, i16_buffer, N * sizeof(int32_t));
  EXCEPT_I32_ARRAY_EQ(answ, i16_buffer, M * N, "MWMULSU_H_MM");
}

static void test_mwmulsu_mm_u32i32() {
  enum { M = 2, N = 2 };
  const int32_t src1[M * N] = {1049035274, 779198181, -1425260016, -1229308983};
  const uint32_t src2[M * N] = {2836295085, 4186901502, 645052748, 605534020};
  const int64_t answ[M * N] = {2975373591637828290, 3262426034384567862,
                               -919367889935323968, -744388410298101660};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, N * sizeof(int32_t));
  muint32_t ms2 = mlc_m(src2, N * sizeof(int32_t));
  mint64_t md = mwmulsu_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, i32_buffer, N * sizeof(int64_t));
  EXCEPT_I64_ARRAY_EQ(answ, i32_buffer, M * N, "MWMULSU_MM I32");
}

static void test_mwmulsu_w_mm() {
  enum { M = 2, N = 2 };
  const int32_t src1[M * N] = {1049035274, 779198181, -1425260016, -1229308983};
  const uint32_t src2[M * N] = {2836295085, 4186901502, 645052748, 605534020};
  const int64_t answ[M * N] = {2975373591637828290, 3262426034384567862,
                               -919367889935323968, -744388410298101660};
  SET_MBA0_I32();
  msettilem(M);
  msettilen(N);
  mint32_t ms1 = mlc_m(src1, N * sizeof(int32_t));
  muint32_t ms2 = mlc_m(src2, N * sizeof(int32_t));
  mint64_t md = mwmulsu_w_mm(ms1, ms2);
  SET_MBA0_I64();
  msc_m(md, i32_buffer, N * sizeof(int64_t));
  EXCEPT_I64_ARRAY_EQ(answ, i32_buffer, M * N, "MWMULSU_W_MM");
}

static void test_mwmulsu_mm() {
  test_mwmulsu_mm_u8i8();
  test_mwmulsu_b_mm();
  test_mwmulsu_mm_u16i16();
  test_mwmulsu_h_mm();
  test_mwmulsu_mm_u32i32();
  test_mwmulsu_w_mm();
}

static void test_mfadd_mm_f16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      5.613,  9.03,  -5.98,   -2.97,  -8.78,  8.65,    6.805,  -9.984,
      1.698,  7.72,  4.81,    1.946,  5.254,  -0.9487, -4.28,  -6.42,
      2.775,  -8.1,  1.407,   -5.13,  1.974,  -6.727,  -9.05,  -1.546,
      -6.676, 7.902, 1.675,   4.688,  4.48,   -0.783,  7.06,   5.734,
      7.67,   4.23,  3.102,   -7.637, 9.336,  -9.32,   -0.87,  4.633,
      8.6,    1.017, 7.117,   2.572,  -4.504, 8.48,    -0.768, 7.887,
      -7.44,  6.395, -0.9443, 6.47,   1.296,  -8.805,  6.375,  2.984,
      -4.953, 4.055, -0.0368, 1.004,  -9.03,  1.464,   0.911,  -3.375};
  const fp16_t src2[M * N] = {
      -7.387, -7.945, 5.418,  3.275,  5.51,   -8.89,   4.03,   8.805,
      -3.342, 6.305,  -1.533, -8.67,  -3.123, -4.74,   -5.227, 2.256,
      -5.754, 5.383,  6.6,    8.27,   -4.484, 3.6,     -6.848, 3.055,
      -9.914, 2.623,  8.86,   5.016,  7.62,   -5.605,  2.182,  -5.27,
      9.59,   -3.81,  -3.938, -2.791, -7.86,  -0.3218, 3.434,  -5.76,
      0.6826, 1.685,  -2.033, 4.44,   -6.523, -6.15,   -7.883, -7.656,
      8.12,   -1.337, 8.555,  4.246,  1.509,  -2.643,  -0.103, -6.445,
      -3.213, 3.365,  2.635,  4.99,   5.242,  -6.547,  -9.21,  4.074};
  const fp16_t answ[M * N] = {
      -1.773, 1.086,  -0.5625, 0.3047, -3.27,  -0.2422, 10.836, -1.18,
      -1.644, 14.02,  3.275,   -6.727, 2.13,   -5.688,  -9.51,  -4.164,
      -2.979, -2.719, 8.01,    3.145,  -2.512, -3.127,  -15.89, 1.509,
      -16.6,  10.52,  10.53,   9.7,    12.1,   -6.39,   9.24,   0.4648,
      17.27,  0.42,   -0.836,  -10.43, 1.477,  -9.64,   2.562,  -1.129,
      9.28,   2.701,  5.086,   7.016,  -11.03, 2.328,   -8.65,  0.2305,
      0.676,  5.06,   7.61,    10.72,  2.805,  -11.445, 6.273,  -3.46,
      -8.164, 7.42,   2.598,   5.992,  -3.79,  -5.082,  -8.3,   0.699};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfadd_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFADD_MM F16");
}

static void test_mfadd_hf_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      5.613,  9.03,  -5.98,   -2.97,  -8.78,  8.65,    6.805,  -9.984,
      1.698,  7.72,  4.81,    1.946,  5.254,  -0.9487, -4.28,  -6.42,
      2.775,  -8.1,  1.407,   -5.13,  1.974,  -6.727,  -9.05,  -1.546,
      -6.676, 7.902, 1.675,   4.688,  4.48,   -0.783,  7.06,   5.734,
      7.67,   4.23,  3.102,   -7.637, 9.336,  -9.32,   -0.87,  4.633,
      8.6,    1.017, 7.117,   2.572,  -4.504, 8.48,    -0.768, 7.887,
      -7.44,  6.395, -0.9443, 6.47,   1.296,  -8.805,  6.375,  2.984,
      -4.953, 4.055, -0.0368, 1.004,  -9.03,  1.464,   0.911,  -3.375};
  const fp16_t src2[M * N] = {
      -7.387, -7.945, 5.418,  3.275,  5.51,   -8.89,   4.03,   8.805,
      -3.342, 6.305,  -1.533, -8.67,  -3.123, -4.74,   -5.227, 2.256,
      -5.754, 5.383,  6.6,    8.27,   -4.484, 3.6,     -6.848, 3.055,
      -9.914, 2.623,  8.86,   5.016,  7.62,   -5.605,  2.182,  -5.27,
      9.59,   -3.81,  -3.938, -2.791, -7.86,  -0.3218, 3.434,  -5.76,
      0.6826, 1.685,  -2.033, 4.44,   -6.523, -6.15,   -7.883, -7.656,
      8.12,   -1.337, 8.555,  4.246,  1.509,  -2.643,  -0.103, -6.445,
      -3.213, 3.365,  2.635,  4.99,   5.242,  -6.547,  -9.21,  4.074};
  const fp16_t answ[M * N] = {
      -1.773, 1.086,  -0.5625, 0.3047, -3.27,  -0.2422, 10.836, -1.18,
      -1.644, 14.02,  3.275,   -6.727, 2.13,   -5.688,  -9.51,  -4.164,
      -2.979, -2.719, 8.01,    3.145,  -2.512, -3.127,  -15.89, 1.509,
      -16.6,  10.52,  10.53,   9.7,    12.1,   -6.39,   9.24,   0.4648,
      17.27,  0.42,   -0.836,  -10.43, 1.477,  -9.64,   2.562,  -1.129,
      9.28,   2.701,  5.086,   7.016,  -11.03, 2.328,   -8.65,  0.2305,
      0.676,  5.06,   7.61,    10.72,  2.805,  -11.445, 6.273,  -3.46,
      -8.164, 7.42,   2.598,   5.992,  -3.79,  -5.082,  -8.3,   0.699};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfadd_hf_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFADD_HF_MM");
}

static void test_mfadd_mm_f32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {-5.6199865, -9.576524,  -6.0314574, -1.1050007,
                              6.115242,   0.30646932, 3.9777586,  -7.291481,
                              4.617499,   -5.650439,  5.7641172,  -4.1815724,
                              0.92247057, -3.8819299, 7.172063,   -2.4686422};
  const fp32_t src2[M * N] = {6.872719,    -7.0061502, 6.270948,  8.382641,
                              9.737984,    -3.83753,   -9.39293,  -2.415724,
                              9.120699,    -9.917874,  1.321102,  2.8454797,
                              -0.16081338, -5.3009872, 1.2571584, -6.103368};
  const fp32_t answ[M * N] = {1.2527323, -16.582674, 0.23949051, 7.2776403,
                              15.853226, -3.5310607, -5.4151716, -9.707205,
                              13.738197, -15.568314, 7.0852194,  -1.3360927,
                              0.7616572, -9.182917,  8.429221,   -8.57201};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfadd_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFADD_MM F32");
}

static void test_mfadd_f_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {-5.6199865, -9.576524,  -6.0314574, -1.1050007,
                              6.115242,   0.30646932, 3.9777586,  -7.291481,
                              4.617499,   -5.650439,  5.7641172,  -4.1815724,
                              0.92247057, -3.8819299, 7.172063,   -2.4686422};
  const fp32_t src2[M * N] = {6.872719,    -7.0061502, 6.270948,  8.382641,
                              9.737984,    -3.83753,   -9.39293,  -2.415724,
                              9.120699,    -9.917874,  1.321102,  2.8454797,
                              -0.16081338, -5.3009872, 1.2571584, -6.103368};
  const fp32_t answ[M * N] = {1.2527323, -16.582674, 0.23949051, 7.2776403,
                              15.853226, -3.5310607, -5.4151716, -9.707205,
                              13.738197, -15.568314, 7.0852194,  -1.3360927,
                              0.7616572, -9.182917,  8.429221,   -8.57201};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfadd_f_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFADD_F_MM");
}

static void test_mfadd_mm_f64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {4.39025751, 3.01581306, -3.88292662, -2.68640874};
  const fp64_t src2[M * N] = {-9.76547075, 1.08372089, 0.95569345, 3.25536365};
  const fp64_t answ[M * N] = {-5.37521323, 4.09953395, -2.92723318, 0.56895491};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfadd_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFADD_MM F64");
}

static void test_mfadd_d_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {4.39025751, 3.01581306, -3.88292662, -2.68640874};
  const fp64_t src2[M * N] = {-9.76547075, 1.08372089, 0.95569345, 3.25536365};
  const fp64_t answ[M * N] = {-5.37521323, 4.09953395, -2.92723318, 0.56895491};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfadd_d_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFADD_D_MM");
}

static void test_mfadd_mm() {
  test_mfadd_mm_f16();
  test_mfadd_hf_mm();
  test_mfadd_mm_f32();
  test_mfadd_f_mm();
  test_mfadd_mm_f64();
  test_mfadd_d_mm();
}

static void test_mfwadd_mm_f16() {
  enum { M = 4, N = 4 };
  const fp16_t src1[M * N] = {-4.42, -1.56, 1.71,   -3.115, 8.414, -1.303,
                              -7.7,  4.695, -9.734, -1.316, 5.227, -6.69,
                              1.667, 2.441, 5.574,  -0.1273};
  const fp16_t src2[M * N] = {-1.040e+00, 9.586e+00,  -7.809e+00, 3.922e+00,
                              8.472e-01,  -2.195e-03, 5.672e+00,  1.698e-02,
                              6.188e+00,  -6.645e+00, 7.996e+00,  -7.566e+00,
                              -6.851e-01, 4.867e+00,  9.891e+00,  -2.742e+00};
  const fp32_t answ[M * N] = {-5.4609375, 8.0234375,  -6.0976562, 0.8066406,
                              9.2578125,  -1.3046875, -2.0273438, 4.7109375,
                              -3.546875,  -7.9609375, 13.21875,   -14.2578125,
                              0.9819336,  7.3085938,  15.46875,   -2.8691406};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, N * sizeof(fp16_t));
  mfloat16_t ms2 = mlc_m(src2, N * sizeof(fp16_t));
  SET_MBA0_F16F32();
  mfloat32_t md = mfwadd_mm(ms1, ms2);
  msc_m(md, f32_buffer, N * sizeof(fp32_t));
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFWADD_MM F16");
}

static void test_mfwadd_hf_mm() {
  enum { M = 4, N = 4 };
  const fp16_t src1[M * N] = {-4.42, -1.56, 1.71,   -3.115, 8.414, -1.303,
                              -7.7,  4.695, -9.734, -1.316, 5.227, -6.69,
                              1.667, 2.441, 5.574,  -0.1273};
  const fp16_t src2[M * N] = {-1.040e+00, 9.586e+00,  -7.809e+00, 3.922e+00,
                              8.472e-01,  -2.195e-03, 5.672e+00,  1.698e-02,
                              6.188e+00,  -6.645e+00, 7.996e+00,  -7.566e+00,
                              -6.851e-01, 4.867e+00,  9.891e+00,  -2.742e+00};
  const fp32_t answ[M * N] = {-5.4609375, 8.0234375,  -6.0976562, 0.8066406,
                              9.2578125,  -1.3046875, -2.0273438, 4.7109375,
                              -3.546875,  -7.9609375, 13.21875,   -14.2578125,
                              0.9819336,  7.3085938,  15.46875,   -2.8691406};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, N * sizeof(fp16_t));
  mfloat16_t ms2 = mlc_m(src2, N * sizeof(fp16_t));
  SET_MBA0_F16F32();
  mfloat32_t md = mfwadd_hf_mm(ms1, ms2);
  msc_m(md, f32_buffer, N * sizeof(fp32_t));
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFWADD_HF_MM");
}

static void test_mfwadd_mm_f32() {
  enum { M = 2, N = 2 };
  const fp32_t src1[M * N] = {-1.0649011, -9.851758, 0.91975886, 1.186425};
  const fp32_t src2[M * N] = {-5.7752676, 0.8597922, 3.5711987, -9.996138};
  const fp64_t answ[M * N] = {-6.84016895, -8.99196625, 4.49095774,
                              -8.80971241};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, N * sizeof(fp32_t));
  mfloat32_t ms2 = mlc_m(src2, N * sizeof(fp32_t));
  SET_MBA0_F32F64();
  mfloat64_t md = mfwadd_mm(ms1, ms2);
  msc_m(md, f64_buffer, N * sizeof(fp64_t));
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFWADD_MM F32");
}

static void test_mfwadd_f_mm() {
  enum { M = 2, N = 2 };
  const fp32_t src1[M * N] = {-1.0649011, -9.851758, 0.91975886, 1.186425};
  const fp32_t src2[M * N] = {-5.7752676, 0.8597922, 3.5711987, -9.996138};
  const fp64_t answ[M * N] = {-6.84016895, -8.99196625, 4.49095774,
                              -8.80971241};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, N * sizeof(fp32_t));
  mfloat32_t ms2 = mlc_m(src2, N * sizeof(fp32_t));
  SET_MBA0_F32F64();
  mfloat64_t md = mfwadd_f_mm(ms1, ms2);
  msc_m(md, f64_buffer, N * sizeof(fp64_t));
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFWADD_F_MM");
}

static void test_mfwadd_mm() {
  test_mfwadd_mm_f16();
  test_mfwadd_hf_mm();
  test_mfwadd_mm_f32();
  test_mfwadd_f_mm();
}

static void test_mfsub_mm_f16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      0.755,  -9.28,  4.836,  2.201,  5.742,   -2.22,  -2.39,  5.453,
      -2.363, 3.26,   9.45,   0.1654, 7.785,   0.0438, 4.344,  -3.77,
      -3.412, -1.788, 7.125,  9.53,   3.25,    -5.52,  4.156,  0.2947,
      2.955,  -9.13,  -0.989, -4.188, -0.7817, 0.2795, -7.59,  -8.445,
      -4.53,  -1.337, 6.14,   -6.94,  0.752,   3.434,  -9.99,  -4.25,
      8.39,   -7.96,  6.55,   -8.05,  7.184,   -4.56,  -8.78,  -0.7803,
      5.934,  -2.299, 6.152,  -5.36,  4.902,   9.55,   -7.836, 0.1616,
      -4.098, 3.71,   -8.41,  9.08,   7.906,   -9.49,  1.709,  5.22};
  const fp16_t src2[M * N] = {
      0.0766, 0.2141, 3.342,  8.195,  -5.14,   2.838,  0.576,  -1.389,
      7.215,  -5.31,  -4.98,  -0.612, 3.445,   -6.46,  -3.664, 4.637,
      9.336,  -7.35,  -1.383, -3.69,  -2.047,  9.49,   -8.16,  -5.29,
      8.63,   5.55,   7.066,  -5.645, 3.459,   4.582,  -0.702, 0.01399,
      3.205,  -3.295, -4.473, -8.65,  3.834,   9.65,   5.035,  -4.332,
      4.62,   8.24,   0.8003, 8.805,  -2.816,  -8.96,  7.61,   -8.13,
      6.16,   3.219,  -1.016, -9.125, 6.473,   -7.574, 7.414,  -5.04,
      2.414,  7.77,   7.125,  6.367,  -1.8125, -6.816, 4.26,   -0.6743};
  const fp16_t answ[M * N] = {
      0.678,   -9.49,  1.494,  -5.992, 10.88,  -5.06,   -2.967, 6.844,
      -9.58,   8.57,   14.44,  0.7773, 4.34,   6.504,   8.01,   -8.41,
      -12.75,  5.562,  8.51,   13.22,  5.297,  -15.016, 12.31,  5.582,
      -5.68,   -14.69, -8.055, 1.457,  -4.242, -4.3,    -6.887, -8.46,
      -7.734,  1.958,  10.61,  1.707,  -3.082, -6.215,  -15.03, 0.08203,
      3.77,    -16.2,  5.75,   -16.84, 10.,    4.402,   -16.39, 7.35,
      -0.2266, -5.516, 7.168,  3.766,  -1.57,  17.12,   -15.25, 5.2,
      -6.51,   -4.06,  -15.53, 2.71,   9.72,   -2.676,  -2.553, 5.895};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfsub_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFSUB_MM F16");
}

static void test_mfsub_hf_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      0.755,  -9.28,  4.836,  2.201,  5.742,   -2.22,  -2.39,  5.453,
      -2.363, 3.26,   9.45,   0.1654, 7.785,   0.0438, 4.344,  -3.77,
      -3.412, -1.788, 7.125,  9.53,   3.25,    -5.52,  4.156,  0.2947,
      2.955,  -9.13,  -0.989, -4.188, -0.7817, 0.2795, -7.59,  -8.445,
      -4.53,  -1.337, 6.14,   -6.94,  0.752,   3.434,  -9.99,  -4.25,
      8.39,   -7.96,  6.55,   -8.05,  7.184,   -4.56,  -8.78,  -0.7803,
      5.934,  -2.299, 6.152,  -5.36,  4.902,   9.55,   -7.836, 0.1616,
      -4.098, 3.71,   -8.41,  9.08,   7.906,   -9.49,  1.709,  5.22};
  const fp16_t src2[M * N] = {
      0.0766, 0.2141, 3.342,  8.195,  -5.14,   2.838,  0.576,  -1.389,
      7.215,  -5.31,  -4.98,  -0.612, 3.445,   -6.46,  -3.664, 4.637,
      9.336,  -7.35,  -1.383, -3.69,  -2.047,  9.49,   -8.16,  -5.29,
      8.63,   5.55,   7.066,  -5.645, 3.459,   4.582,  -0.702, 0.01399,
      3.205,  -3.295, -4.473, -8.65,  3.834,   9.65,   5.035,  -4.332,
      4.62,   8.24,   0.8003, 8.805,  -2.816,  -8.96,  7.61,   -8.13,
      6.16,   3.219,  -1.016, -9.125, 6.473,   -7.574, 7.414,  -5.04,
      2.414,  7.77,   7.125,  6.367,  -1.8125, -6.816, 4.26,   -0.6743};
  const fp16_t answ[M * N] = {
      0.678,   -9.49,  1.494,  -5.992, 10.88,  -5.06,   -2.967, 6.844,
      -9.58,   8.57,   14.44,  0.7773, 4.34,   6.504,   8.01,   -8.41,
      -12.75,  5.562,  8.51,   13.22,  5.297,  -15.016, 12.31,  5.582,
      -5.68,   -14.69, -8.055, 1.457,  -4.242, -4.3,    -6.887, -8.46,
      -7.734,  1.958,  10.61,  1.707,  -3.082, -6.215,  -15.03, 0.08203,
      3.77,    -16.2,  5.75,   -16.84, 10.,    4.402,   -16.39, 7.35,
      -0.2266, -5.516, 7.168,  3.766,  -1.57,  17.12,   -15.25, 5.2,
      -6.51,   -4.06,  -15.53, 2.71,   9.72,   -2.676,  -2.553, 5.895};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfsub_hf_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFSUB_HF_MM");
}

static void test_mfsub_mm_f32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {-8.718435, 3.130281,  -9.237613,  6.324169,
                              1.234885,  -8.183972, -8.038334,  -1.8241533,
                              -7.47869,  1.5081388, -5.9857497, 6.4675727,
                              7.6962743, 1.684017,  -5.996631,  -6.761588};
  const fp32_t src2[M * N] = {9.6312475,  -0.68340653, 7.578151,   2.8450165,
                              3.6668856,  -4.3885374,  -6.517833,  7.0894265,
                              7.9951987,  3.1218631,   -5.9686847, -5.053279,
                              -6.7206616, 4.601142,    7.8529305,  7.7498116};
  const fp32_t answ[M * N] = {
      -1.8349682e+01, 3.8136876e+00,  -1.6815763e+01, 3.4791527e+00,
      -2.4320006e+00, -3.7954350e+00, -1.5205007e+00, -8.9135799e+00,
      -1.5473888e+01, -1.6137244e+00, -1.7065048e-02, 1.1520851e+01,
      1.4416936e+01,  -2.9171250e+00, -1.3849562e+01, -1.4511400e+01};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfsub_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFSUB_MM F32");
}

static void test_mfsub_f_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {-8.718435, 3.130281,  -9.237613,  6.324169,
                              1.234885,  -8.183972, -8.038334,  -1.8241533,
                              -7.47869,  1.5081388, -5.9857497, 6.4675727,
                              7.6962743, 1.684017,  -5.996631,  -6.761588};
  const fp32_t src2[M * N] = {9.6312475,  -0.68340653, 7.578151,   2.8450165,
                              3.6668856,  -4.3885374,  -6.517833,  7.0894265,
                              7.9951987,  3.1218631,   -5.9686847, -5.053279,
                              -6.7206616, 4.601142,    7.8529305,  7.7498116};
  const fp32_t answ[M * N] = {
      -1.8349682e+01, 3.8136876e+00,  -1.6815763e+01, 3.4791527e+00,
      -2.4320006e+00, -3.7954350e+00, -1.5205007e+00, -8.9135799e+00,
      -1.5473888e+01, -1.6137244e+00, -1.7065048e-02, 1.1520851e+01,
      1.4416936e+01,  -2.9171250e+00, -1.3849562e+01, -1.4511400e+01};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfsub_f_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFSUB_F_MM");
}

static void test_mfsub_mm_f64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {8.17333689, -3.69501845, 9.83427576, 8.22168722};
  const fp64_t src2[M * N] = {-2.41293107, 0.23270118, 1.98941289, 4.27188754};
  const fp64_t answ[M * N] = {10.58626796, -3.92771963, 7.84486287, 3.94979968};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfsub_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFSUB_MM F64");
}

static void test_mfsub_d_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {8.17333689, -3.69501845, 9.83427576, 8.22168722};
  const fp64_t src2[M * N] = {-2.41293107, 0.23270118, 1.98941289, 4.27188754};
  const fp64_t answ[M * N] = {10.58626796, -3.92771963, 7.84486287, 3.94979968};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfsub_d_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFSUB_D_MM");
}

static void test_mfsub_mm() {
  test_mfsub_mm_f16();
  test_mfsub_hf_mm();
  test_mfsub_mm_f32();
  test_mfsub_f_mm();
  test_mfsub_mm_f64();
  test_mfsub_d_mm();
}

static void test_mfwsub_mm_f16() {
  enum { M = 4, N = 4 };
  const fp16_t src1[M * N] = {2.03,   -5.81,   -4.24,  6.527, 1.539,  -2.416,
                              7.652,  6.777,   -6.883, 7.348, -7.918, -0.8604,
                              -3.285, 0.08246, 1.342,  3.072};
  const fp16_t src2[M * N] = {-5.488e+00, -9.023e+00, 7.285e+00,  -9.271e-02,
                              4.398e+00,  1.049e+00,  -3.311e+00, -8.289e+00,
                              2.307e+00,  -3.527e+00, -7.111e-03, 6.121e+00,
                              9.641e+00,  -2.355e+00, -1.950e+00, 9.656e+00};
  const fp32_t answ[M * N] = {7.515625,   3.2148438,  -11.5234375, 6.6210938,
                              -2.859375,  -3.4648438, 10.9609375,  15.0625,
                              -9.1875,    10.875,     -7.9101562,  -6.9804688,
                              -12.921875, 2.4375,     3.2929688,   -6.5859375};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, N * sizeof(fp16_t));
  mfloat16_t ms2 = mlc_m(src2, N * sizeof(fp16_t));
  SET_MBA0_F16F32();
  mfloat32_t md = mfwsub_mm(ms1, ms2);
  msc_m(md, f32_buffer, N * sizeof(fp32_t));
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFWSUB_MM F16");
}

static void test_mfwsub_hf_mm() {
  enum { M = 4, N = 4 };
  const fp16_t src1[M * N] = {2.03,   -5.81,   -4.24,  6.527, 1.539,  -2.416,
                              7.652,  6.777,   -6.883, 7.348, -7.918, -0.8604,
                              -3.285, 0.08246, 1.342,  3.072};
  const fp16_t src2[M * N] = {-5.488e+00, -9.023e+00, 7.285e+00,  -9.271e-02,
                              4.398e+00,  1.049e+00,  -3.311e+00, -8.289e+00,
                              2.307e+00,  -3.527e+00, -7.111e-03, 6.121e+00,
                              9.641e+00,  -2.355e+00, -1.950e+00, 9.656e+00};
  const fp32_t answ[M * N] = {7.515625,   3.2148438,  -11.5234375, 6.6210938,
                              -2.859375,  -3.4648438, 10.9609375,  15.0625,
                              -9.1875,    10.875,     -7.9101562,  -6.9804688,
                              -12.921875, 2.4375,     3.2929688,   -6.5859375};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, N * sizeof(fp16_t));
  mfloat16_t ms2 = mlc_m(src2, N * sizeof(fp16_t));
  SET_MBA0_F16F32();
  mfloat32_t md = mfwsub_hf_mm(ms1, ms2);
  msc_m(md, f32_buffer, N * sizeof(fp32_t));
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFWSUB_HF_MM");
}

static void test_mfwsub_mm_f32() {
  enum { M = 2, N = 2 };
  const fp32_t src1[M * N] = {7.1470366, -0.31278947, 7.4886475, -8.430981};
  const fp32_t src2[M * N] = {9.90859, 7.987149, -0.9798009, 3.5051417};
  const fp64_t answ[M * N] = {-2.76155376, -8.2999382, 8.46844864,
                              -11.93612289};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, N * sizeof(fp32_t));
  mfloat32_t ms2 = mlc_m(src2, N * sizeof(fp32_t));
  SET_MBA0_F32F64();
  mfloat64_t md = mfwsub_mm(ms1, ms2);
  msc_m(md, f64_buffer, N * sizeof(fp64_t));
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFWSUB_MM F32");
}

static void test_mfwsub_f_mm() {
  enum { M = 2, N = 2 };
  const fp32_t src1[M * N] = {7.1470366, -0.31278947, 7.4886475, -8.430981};
  const fp32_t src2[M * N] = {9.90859, 7.987149, -0.9798009, 3.5051417};
  const fp64_t answ[M * N] = {-2.76155376, -8.2999382, 8.46844864,
                              -11.93612289};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, N * sizeof(fp32_t));
  mfloat32_t ms2 = mlc_m(src2, N * sizeof(fp32_t));
  SET_MBA0_F32F64();
  mfloat64_t md = mfwsub_f_mm(ms1, ms2);
  msc_m(md, f64_buffer, N * sizeof(fp64_t));
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFWSUB_F_MM");
}

static void test_mfwsub_mm() {
  test_mfwsub_mm_f16();
  test_mfwsub_hf_mm();
  test_mfwsub_mm_f32();
  test_mfwsub_f_mm();
}

static void test_mfmin_mm_f16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      0.6353,  -1.034, 9.586,  -0.2524, -6.98,  -4.848, -5.082, 6.957,
      -0.0999, -3.623, -9.836, 9.09,    -2.535, -4.39,  7.54,   0.586,
      -4.473,  4.996,  6.332,  -5.258,  6.465,  1.81,   8.52,   -0.981,
      4.113,   2.29,   3.912,  7.46,    6.242,  -7.62,  -5.184, -4.176,
      -2.506,  0.533,  -0.875, -3.307,  -9.34,  -1.251, 1.286,  -7.89,
      2.838,   9.69,   -9.086, -2.516,  0.5693, -9.13,  9.07,   -0.2268,
      4.277,   9.3,    4.02,   4.97,    0.537,  -1.605, 6.492,  -0.446,
      4.73,    -1.161, 5.367,  8.11,    -0.468, 4.055,  1.857,  9.76};
  const fp16_t src2[M * N] = {
      -3.555, -9.984, -1.651, 6.176,  2.42,   -6.695, -0.2351, 1.137,
      4.28,   8.69,   -7.926, 0.77,   -5.824, -1.699, 6.195,   -4.723,
      -6.176, -4.293, -9.35,  -2.812, 6.145,  4.273,  1.597,   3.494,
      -8.06,  0.1239, 5.336,  1.772,  -6.016, 1.102,  -0.5957, 0.9976,
      -2.191, 0.9844, -5.22,  4.605,  1.894,  -6.094, -7.49,   9.266,
      6.77,   6.844,  -8.234, -6.957, 5.71,   6.035,  -0.7314, -6.805,
      5.06,   3.494,  6.19,   6.293,  -1.123, 2.75,   5.875,   0.151,
      5.523,  9.164,  -9.805, 5.688,  -3.447, -3.727, 3.271,   8.586};
  const fp16_t answ[M * N] = {
      -3.555,  -9.984, -1.651, -0.2524, -6.98,  -6.695, -5.082,  1.137,
      -0.0999, -3.623, -9.836, 0.77,    -5.824, -4.39,  6.195,   -4.723,
      -6.176,  -4.293, -9.35,  -5.258,  6.145,  1.81,   1.597,   -0.981,
      -8.06,   0.1239, 3.912,  1.772,   -6.016, -7.62,  -5.184,  -4.176,
      -2.506,  0.533,  -5.22,  -3.307,  -9.34,  -6.094, -7.49,   -7.89,
      2.838,   6.844,  -9.086, -6.957,  0.5693, -9.13,  -0.7314, -6.805,
      4.277,   3.494,  4.02,   4.97,    -1.123, -1.605, 5.875,   -0.446,
      4.73,    -1.161, -9.805, 5.688,   -3.447, -3.727, 1.857,   8.586};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfmin_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFMIN_MM F16");
}

static void test_mfmin_hf_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      0.6353,  -1.034, 9.586,  -0.2524, -6.98,  -4.848, -5.082, 6.957,
      -0.0999, -3.623, -9.836, 9.09,    -2.535, -4.39,  7.54,   0.586,
      -4.473,  4.996,  6.332,  -5.258,  6.465,  1.81,   8.52,   -0.981,
      4.113,   2.29,   3.912,  7.46,    6.242,  -7.62,  -5.184, -4.176,
      -2.506,  0.533,  -0.875, -3.307,  -9.34,  -1.251, 1.286,  -7.89,
      2.838,   9.69,   -9.086, -2.516,  0.5693, -9.13,  9.07,   -0.2268,
      4.277,   9.3,    4.02,   4.97,    0.537,  -1.605, 6.492,  -0.446,
      4.73,    -1.161, 5.367,  8.11,    -0.468, 4.055,  1.857,  9.76};
  const fp16_t src2[M * N] = {
      -3.555, -9.984, -1.651, 6.176,  2.42,   -6.695, -0.2351, 1.137,
      4.28,   8.69,   -7.926, 0.77,   -5.824, -1.699, 6.195,   -4.723,
      -6.176, -4.293, -9.35,  -2.812, 6.145,  4.273,  1.597,   3.494,
      -8.06,  0.1239, 5.336,  1.772,  -6.016, 1.102,  -0.5957, 0.9976,
      -2.191, 0.9844, -5.22,  4.605,  1.894,  -6.094, -7.49,   9.266,
      6.77,   6.844,  -8.234, -6.957, 5.71,   6.035,  -0.7314, -6.805,
      5.06,   3.494,  6.19,   6.293,  -1.123, 2.75,   5.875,   0.151,
      5.523,  9.164,  -9.805, 5.688,  -3.447, -3.727, 3.271,   8.586};
  const fp16_t answ[M * N] = {
      -3.555,  -9.984, -1.651, -0.2524, -6.98,  -6.695, -5.082,  1.137,
      -0.0999, -3.623, -9.836, 0.77,    -5.824, -4.39,  6.195,   -4.723,
      -6.176,  -4.293, -9.35,  -5.258,  6.145,  1.81,   1.597,   -0.981,
      -8.06,   0.1239, 3.912,  1.772,   -6.016, -7.62,  -5.184,  -4.176,
      -2.506,  0.533,  -5.22,  -3.307,  -9.34,  -6.094, -7.49,   -7.89,
      2.838,   6.844,  -9.086, -6.957,  0.5693, -9.13,  -0.7314, -6.805,
      4.277,   3.494,  4.02,   4.97,    -1.123, -1.605, 5.875,   -0.446,
      4.73,    -1.161, -9.805, 5.688,   -3.447, -3.727, 1.857,   8.586};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfmin_hf_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFMIN_HF_MM");
}

static void test_mfmin_mm_f32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {-0.41978237, 0.3984203,  6.1187,      -8.995303,
                              1.000418,    -6.994458,  -0.20482373, -4.32034,
                              2.258843,    9.742502,   1.0760392,   -0.62470275,
                              -2.680081,   -6.7111683, -3.4915137,  -1.993269};
  const fp32_t src2[M * N] = {3.2227325,  -2.24363,   5.2297006,  4.301303,
                              -2.1300964, 5.8828263,  0.7587649,  -1.9380943,
                              1.5246394,  -1.9869589, 5.388156,   -3.4889271,
                              0.7009421,  -6.8169503, -2.1538148, -2.7323887};
  const fp32_t answ[M * N] = {-0.41978237, -2.24363,   5.2297006,   -8.995303,
                              -2.1300964,  -6.994458,  -0.20482373, -4.32034,
                              1.5246394,   -1.9869589, 1.0760392,   -3.4889271,
                              -2.680081,   -6.8169503, -3.4915137,  -2.7323887};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfmin_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFMIN_MM F32");
}

static void test_mfmin_f_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {-0.41978237, 0.3984203,  6.1187,      -8.995303,
                              1.000418,    -6.994458,  -0.20482373, -4.32034,
                              2.258843,    9.742502,   1.0760392,   -0.62470275,
                              -2.680081,   -6.7111683, -3.4915137,  -1.993269};
  const fp32_t src2[M * N] = {3.2227325,  -2.24363,   5.2297006,  4.301303,
                              -2.1300964, 5.8828263,  0.7587649,  -1.9380943,
                              1.5246394,  -1.9869589, 5.388156,   -3.4889271,
                              0.7009421,  -6.8169503, -2.1538148, -2.7323887};
  const fp32_t answ[M * N] = {-0.41978237, -2.24363,   5.2297006,   -8.995303,
                              -2.1300964,  -6.994458,  -0.20482373, -4.32034,
                              1.5246394,   -1.9869589, 1.0760392,   -3.4889271,
                              -2.680081,   -6.8169503, -3.4915137,  -2.7323887};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfmin_f_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFMIN_F_MM");
}

static void test_mfmin_mm_f64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {-8.20575234, -6.65971006, 5.32152915, 4.86046932};
  const fp64_t src2[M * N] = {-9.36110537, -1.11600557, 7.14487806, 6.44558126};
  const fp64_t answ[M * N] = {-9.36110537, -6.65971006, 5.32152915, 4.86046932};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfmin_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFMIN_MM F64");
}

static void test_mfmin_d_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {-8.20575234, -6.65971006, 5.32152915, 4.86046932};
  const fp64_t src2[M * N] = {-9.36110537, -1.11600557, 7.14487806, 6.44558126};
  const fp64_t answ[M * N] = {-9.36110537, -6.65971006, 5.32152915, 4.86046932};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfmin_d_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFMIN_D_MM");
}

static void test_mfmin_mm() {
  test_mfmin_mm_f16();
  test_mfmin_hf_mm();
  test_mfmin_mm_f32();
  test_mfmin_f_mm();
  test_mfmin_mm_f64();
  test_mfmin_d_mm();
}

static void test_mfmax_mm_f16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      -7.902, -7.77,  4.92,   1.503,  1.765,  -2.129,  6.94,   -8.2,
      8.02,   -4.277, 1.77,   4.895,  4.28,   5.902,   0.5645, 3.75,
      -7.754, 9.61,   -2.758, -2.771, 6.848,  -0.6025, -5.797, -7.46,
      8.93,   -9.96,  7.305,  -9.53,  9.83,   2.768,   -8.45,  -4.156,
      -9.37,  5.67,   7.938,  2.662,  -2.664, -9.59,   9.5,    -5.04,
      7.242,  -5.35,  -0.422, 9.39,   0.861,  -1.502,  -6.758, 1.335,
      4.676,  -9.53,  3.852,  7.836,  -4.406, 7.94,    5.664,  8.91,
      3.066,  -6.98,  0.746,  -3.787, 7.562,  -5.375,  6.18,   8.31};
  const fp16_t src2[M * N] = {
      1.688,   2.396,  -7.742,  -4.99,  2.307,  -0.544,  -0.65,   1.601,
      5.684,   6.473,  3.566,   8.4,    -8.195, -0.6763, -0.2015, 1.561,
      -0.2903, -1.07,  -0.1002, 0.7207, 8.51,   -4.49,   -7.336,  4.832,
      -7.39,   4.85,   -2.42,   -1.961, 3.04,   3.537,   -5.625,  0.8154,
      2.055,   4.254,  -7.03,   4.08,   4.324,  1.756,   -3.033,  7.777,
      6.805,   0.1461, -2.678,  6.023,  7.832,  -3.22,   -7.566,  8.2,
      3.754,   4.188,  -8.82,   9.2,    -7.79,  7.7,     6.6,     3.266,
      4.83,    -6.664, 4.848,   9.21,   8.49,   -4.805,  -4.184,  -4.355};
  const fp16_t answ[M * N] = {
      1.688,   2.396,  4.92,    1.503,  2.307,  -0.544,  6.94,   1.601,
      8.02,    6.473,  3.566,   8.4,    4.28,   5.902,   0.5645, 3.75,
      -0.2903, 9.61,   -0.1002, 0.7207, 8.51,   -0.6025, -5.797, 4.832,
      8.93,    4.85,   7.305,   -1.961, 9.83,   3.537,   -5.625, 0.8154,
      2.055,   5.67,   7.938,   4.08,   4.324,  1.756,   9.5,    7.777,
      7.242,   0.1461, -0.422,  9.39,   7.832,  -1.502,  -6.758, 8.2,
      4.676,   4.188,  3.852,   9.2,    -4.406, 7.94,    6.6,    8.91,
      4.83,    -6.664, 4.848,   9.21,   8.49,   -4.805,  6.18,   8.31};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfmax_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFMAX_MM F16");
}

static void test_mfmax_hf_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      -7.902, -7.77,  4.92,   1.503,  1.765,  -2.129,  6.94,   -8.2,
      8.02,   -4.277, 1.77,   4.895,  4.28,   5.902,   0.5645, 3.75,
      -7.754, 9.61,   -2.758, -2.771, 6.848,  -0.6025, -5.797, -7.46,
      8.93,   -9.96,  7.305,  -9.53,  9.83,   2.768,   -8.45,  -4.156,
      -9.37,  5.67,   7.938,  2.662,  -2.664, -9.59,   9.5,    -5.04,
      7.242,  -5.35,  -0.422, 9.39,   0.861,  -1.502,  -6.758, 1.335,
      4.676,  -9.53,  3.852,  7.836,  -4.406, 7.94,    5.664,  8.91,
      3.066,  -6.98,  0.746,  -3.787, 7.562,  -5.375,  6.18,   8.31};
  const fp16_t src2[M * N] = {
      1.688,   2.396,  -7.742,  -4.99,  2.307,  -0.544,  -0.65,   1.601,
      5.684,   6.473,  3.566,   8.4,    -8.195, -0.6763, -0.2015, 1.561,
      -0.2903, -1.07,  -0.1002, 0.7207, 8.51,   -4.49,   -7.336,  4.832,
      -7.39,   4.85,   -2.42,   -1.961, 3.04,   3.537,   -5.625,  0.8154,
      2.055,   4.254,  -7.03,   4.08,   4.324,  1.756,   -3.033,  7.777,
      6.805,   0.1461, -2.678,  6.023,  7.832,  -3.22,   -7.566,  8.2,
      3.754,   4.188,  -8.82,   9.2,    -7.79,  7.7,     6.6,     3.266,
      4.83,    -6.664, 4.848,   9.21,   8.49,   -4.805,  -4.184,  -4.355};
  const fp16_t answ[M * N] = {
      1.688,   2.396,  4.92,    1.503,  2.307,  -0.544,  6.94,   1.601,
      8.02,    6.473,  3.566,   8.4,    4.28,   5.902,   0.5645, 3.75,
      -0.2903, 9.61,   -0.1002, 0.7207, 8.51,   -0.6025, -5.797, 4.832,
      8.93,    4.85,   7.305,   -1.961, 9.83,   3.537,   -5.625, 0.8154,
      2.055,   5.67,   7.938,   4.08,   4.324,  1.756,   9.5,    7.777,
      7.242,   0.1461, -0.422,  9.39,   7.832,  -1.502,  -6.758, 8.2,
      4.676,   4.188,  3.852,   9.2,    -4.406, 7.94,    6.6,    8.91,
      4.83,    -6.664, 4.848,   9.21,   8.49,   -4.805,  6.18,   8.31};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfmax_hf_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFMAX_HF_MM");
}

static void test_mfmax_mm_f32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {3.1510124,  4.831404,    -9.610977,  -9.236803,
                              -7.1168365, 9.466589,    1.8743871,  -6.789111,
                              -5.9939976, -0.58182883, 9.893524,   6.680588,
                              0.8786394,  0.65212,     0.02507398, -6.8902345};
  const fp32_t src2[M * N] = {6.8097806, -6.9259896,  -7.8465166, 1.1224791,
                              6.0889125, 7.9032435,   -4.8947387, -9.683324,
                              -8.148475, -0.26568392, 9.70854,    -3.4461548,
                              -8.616366, 7.2275248,   7.0592265,  6.367507};
  const fp32_t answ[M * N] = {6.8097806,  4.831404,    -7.8465166, 1.1224791,
                              6.0889125,  9.466589,    1.8743871,  -6.789111,
                              -5.9939976, -0.26568392, 9.893524,   6.680588,
                              0.8786394,  7.2275248,   7.0592265,  6.367507};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfmax_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFMAX_MM F32");
}

static void test_mfmax_f_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {3.1510124,  4.831404,    -9.610977,  -9.236803,
                              -7.1168365, 9.466589,    1.8743871,  -6.789111,
                              -5.9939976, -0.58182883, 9.893524,   6.680588,
                              0.8786394,  0.65212,     0.02507398, -6.8902345};
  const fp32_t src2[M * N] = {6.8097806, -6.9259896,  -7.8465166, 1.1224791,
                              6.0889125, 7.9032435,   -4.8947387, -9.683324,
                              -8.148475, -0.26568392, 9.70854,    -3.4461548,
                              -8.616366, 7.2275248,   7.0592265,  6.367507};
  const fp32_t answ[M * N] = {6.8097806,  4.831404,    -7.8465166, 1.1224791,
                              6.0889125,  9.466589,    1.8743871,  -6.789111,
                              -5.9939976, -0.26568392, 9.893524,   6.680588,
                              0.8786394,  7.2275248,   7.0592265,  6.367507};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfmax_f_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFMAX_F_MM");
}

static void test_mfmax_mm_f64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {-1.57607724, 1.68942635, 0.98343359, 9.11956802};
  const fp64_t src2[M * N] = {1.5602988, -5.98944127, -0.47489555, 8.36002542};
  const fp64_t answ[M * N] = {1.5602988, 1.68942635, 0.98343359, 9.11956802};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfmax_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFMAX_MM F64");
}

static void test_mfmax_d_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {-1.57607724, 1.68942635, 0.98343359, 9.11956802};
  const fp64_t src2[M * N] = {1.5602988, -5.98944127, -0.47489555, 8.36002542};
  const fp64_t answ[M * N] = {1.5602988, 1.68942635, 0.98343359, 9.11956802};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfmax_d_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFMAX_D_MM");
}

static void test_mfmax_mm() {
  test_mfmax_mm_f16();
  test_mfmax_hf_mm();
  test_mfmax_mm_f32();
  test_mfmax_f_mm();
  test_mfmax_mm_f64();
  test_mfmax_d_mm();
}

static void test_mfmul_mm_f16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      4.332,  7.06,   -0.5215, 2.322,  7.562,  -3.285, 4.645, 3.072,
      3.916,  6.93,   -4.504,  -8.56,  0.5205, -4.19,  4.324, -7.098,
      -7.195, -8.375, 9.99,    1.439,  -9.24,  2.463,  6.67,  -2.996,
      0.7676, 1.613,  0.502,   -4.043, 0.4685, -9.16,  8.92,  1.723,
      -1.213, -2.176, 5.24,    2.951,  -2.986, 7.87,   -8.9,  -9.7,
      -4.387, 0.2147, 4.582,   -5.96,  -3.77,  -9.164, 5.773, 4.027,
      -9.414, 8.71,   4.195,   6.44,   -2.709, 1.248,  2.238, 7.33,
      -1.584, -8.805, -8.77,   -6.395, -6.816, -6.023, -8.17, 3.535};
  const fp16_t src2[M * N] = {
      -7.305, -4.24, -5.793, -2.508,  8.24,   4.645,    2.12,   1.628,
      -9.484, 1.049, -1.314, -8.29,   -1.744, -2.82,    -6.043, 0.7114,
      -7.14,  5.17,  -3.83,  3.459,   7.074,  1.992,    7.85,   1.487,
      -1.037, -8.23, 3.803,  0.778,   -7.5,   3.95,     -3.25,  5.594,
      -1.258, 3.35,  -5.254, -0.6035, -4.816, -7.945,   0.3936, -5.426,
      9.85,   1.165, 3.113,  -4.72,   8.26,   6.2,      -1.55,  5.01,
      -2.672, -2.87, -3.137, 2.861,   5.137,  -0.01471, -7.055, -4.54,
      4.69,   -8.53, 6.785,  -6.43,   -5.34,  0.8125,   4.38,   -0.1077};
  const fp16_t answ[M * N] = {
      -3.1641e+01, -2.9922e+01, 3.0215e+00,  -5.8242e+00, 6.2344e+01,
      -1.5258e+01, 9.8438e+00,  5.0000e+00,  -3.7156e+01, 7.2695e+00,
      5.9219e+00,  7.1000e+01,  -9.0771e-01, 1.1820e+01,  -2.6125e+01,
      -5.0508e+00, 5.1375e+01,  -4.3312e+01, -3.8281e+01, 4.9805e+00,
      -6.5375e+01, 4.9062e+00,  5.2375e+01,  -4.4570e+00, -7.9590e-01,
      -1.3273e+01, 1.9092e+00,  -3.1445e+00, -3.5137e+00, -3.6156e+01,
      -2.9000e+01, 9.6328e+00,  1.5254e+00,  -7.2891e+00, -2.7516e+01,
      -1.7812e+00, 1.4383e+01,  -6.2531e+01, -3.5020e+00, 5.2656e+01,
      -4.3219e+01, 2.5024e-01,  1.4266e+01,  2.8125e+01,  -3.1125e+01,
      -5.6812e+01, -8.9453e+00, 2.0188e+01,  2.5156e+01,  -2.5000e+01,
      -1.3156e+01, 1.8438e+01,  -1.3914e+01, -1.8356e-02, -1.5789e+01,
      -3.3250e+01, -7.4297e+00, 7.5125e+01,  -5.9531e+01, 4.1125e+01,
      3.6406e+01,  -4.8945e+00, -3.5781e+01, -3.8086e-01};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfmul_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFMUL_MM F16");
}

static void test_mfmul_hf_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      4.332,  7.06,   -0.5215, 2.322,  7.562,  -3.285, 4.645, 3.072,
      3.916,  6.93,   -4.504,  -8.56,  0.5205, -4.19,  4.324, -7.098,
      -7.195, -8.375, 9.99,    1.439,  -9.24,  2.463,  6.67,  -2.996,
      0.7676, 1.613,  0.502,   -4.043, 0.4685, -9.16,  8.92,  1.723,
      -1.213, -2.176, 5.24,    2.951,  -2.986, 7.87,   -8.9,  -9.7,
      -4.387, 0.2147, 4.582,   -5.96,  -3.77,  -9.164, 5.773, 4.027,
      -9.414, 8.71,   4.195,   6.44,   -2.709, 1.248,  2.238, 7.33,
      -1.584, -8.805, -8.77,   -6.395, -6.816, -6.023, -8.17, 3.535};
  const fp16_t src2[M * N] = {
      -7.305, -4.24, -5.793, -2.508,  8.24,   4.645,    2.12,   1.628,
      -9.484, 1.049, -1.314, -8.29,   -1.744, -2.82,    -6.043, 0.7114,
      -7.14,  5.17,  -3.83,  3.459,   7.074,  1.992,    7.85,   1.487,
      -1.037, -8.23, 3.803,  0.778,   -7.5,   3.95,     -3.25,  5.594,
      -1.258, 3.35,  -5.254, -0.6035, -4.816, -7.945,   0.3936, -5.426,
      9.85,   1.165, 3.113,  -4.72,   8.26,   6.2,      -1.55,  5.01,
      -2.672, -2.87, -3.137, 2.861,   5.137,  -0.01471, -7.055, -4.54,
      4.69,   -8.53, 6.785,  -6.43,   -5.34,  0.8125,   4.38,   -0.1077};
  const fp16_t answ[M * N] = {
      -3.1641e+01, -2.9922e+01, 3.0215e+00,  -5.8242e+00, 6.2344e+01,
      -1.5258e+01, 9.8438e+00,  5.0000e+00,  -3.7156e+01, 7.2695e+00,
      5.9219e+00,  7.1000e+01,  -9.0771e-01, 1.1820e+01,  -2.6125e+01,
      -5.0508e+00, 5.1375e+01,  -4.3312e+01, -3.8281e+01, 4.9805e+00,
      -6.5375e+01, 4.9062e+00,  5.2375e+01,  -4.4570e+00, -7.9590e-01,
      -1.3273e+01, 1.9092e+00,  -3.1445e+00, -3.5137e+00, -3.6156e+01,
      -2.9000e+01, 9.6328e+00,  1.5254e+00,  -7.2891e+00, -2.7516e+01,
      -1.7812e+00, 1.4383e+01,  -6.2531e+01, -3.5020e+00, 5.2656e+01,
      -4.3219e+01, 2.5024e-01,  1.4266e+01,  2.8125e+01,  -3.1125e+01,
      -5.6812e+01, -8.9453e+00, 2.0188e+01,  2.5156e+01,  -2.5000e+01,
      -1.3156e+01, 1.8438e+01,  -1.3914e+01, -1.8356e-02, -1.5789e+01,
      -3.3250e+01, -7.4297e+00, 7.5125e+01,  -5.9531e+01, 4.1125e+01,
      3.6406e+01,  -4.8945e+00, -3.5781e+01, -3.8086e-01};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfmul_hf_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFMUL_HF_MM");
}

static void test_mfmul_mm_f32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {-9.857592,   3.4942253,  5.296346,    -9.271283,
                              -0.19597366, 2.610578,   -0.41700044, -2.0807903,
                              -8.452218,   -9.056247,  5.82158,     7.7356176,
                              0.22607163,  -3.2042193, -1.398798,   -9.94592};
  const fp32_t src2[M * N] = {-8.011158, -1.764336,  -2.1800065, 1.7776477,
                              3.1574569, 9.678652,   -6.281421,  -0.49432048,
                              3.8645086, -7.7984943, -2.6432319, -4.0625796,
                              8.989088,  -7.6459374, -4.9491177, 3.9620306};
  const fp32_t answ[M * N] = {78.970726,  -6.1649876, -11.546069, -16.481075,
                              -0.6187784, 25.266876,  2.6193554,  1.0285772,
                              -32.66367,  70.62509,   -15.387786, -31.426563,
                              2.0321777,  24.49926,   6.922816,   -39.40604};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfmul_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFMUL_MM F32");
}

static void test_mfmul_f_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {-9.857592,   3.4942253,  5.296346,    -9.271283,
                              -0.19597366, 2.610578,   -0.41700044, -2.0807903,
                              -8.452218,   -9.056247,  5.82158,     7.7356176,
                              0.22607163,  -3.2042193, -1.398798,   -9.94592};
  const fp32_t src2[M * N] = {-8.011158, -1.764336,  -2.1800065, 1.7776477,
                              3.1574569, 9.678652,   -6.281421,  -0.49432048,
                              3.8645086, -7.7984943, -2.6432319, -4.0625796,
                              8.989088,  -7.6459374, -4.9491177, 3.9620306};
  const fp32_t answ[M * N] = {78.970726,  -6.1649876, -11.546069, -16.481075,
                              -0.6187784, 25.266876,  2.6193554,  1.0285772,
                              -32.66367,  70.62509,   -15.387786, -31.426563,
                              2.0321777,  24.49926,   6.922816,   -39.40604};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfmul_f_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFMUL_F_MM");
}

static void test_mfmul_mm_f64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {-2.00791335, 7.91507247, -2.12460501,
                              -3.91298575};
  const fp64_t src2[M * N] = {-3.42547474, -6.90497274, 8.75545983, 9.53043154};
  const fp64_t answ[M * N] = {6.87805645, -54.65335966, -18.6018938,
                              -37.29244278};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfmul_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFMUL_MM F64");
}

static void test_mfmul_d_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {-2.00791335, 7.91507247, -2.12460501,
                              -3.91298575};
  const fp64_t src2[M * N] = {-3.42547474, -6.90497274, 8.75545983, 9.53043154};
  const fp64_t answ[M * N] = {6.87805645, -54.65335966, -18.6018938,
                              -37.29244278};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfmul_d_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFMUL_D_MM");
}

static void test_mfmul_mm() {
  test_mfmul_mm_f16();
  test_mfmul_hf_mm();
  test_mfmul_mm_f32();
  test_mfmul_f_mm();
  test_mfmul_mm_f64();
  test_mfmul_d_mm();
}

static void test_mfwmul_mm_f16() {
  enum { M = 4, N = 4 };
  const fp16_t src1[M * N] = {-2.4304533, -5.3403764, -6.519902,  -2.2903361,
                              4.115905,   -4.758715,  9.927346,   1.8063143,
                              9.625583,   5.7489,     -7.1468086, -5.8859353,
                              1.6808083,  3.4394956,  -8.688804,  3.7498767};
  const fp16_t src2[M * N] = {5.739596,   -2.7156143, -4.666864,  -2.5585773,
                              -2.618982,  -4.655937,  -1.4731995, 6.025878,
                              -1.2987155, 4.682494,   2.7780344,  9.754377,
                              -3.7460315, 2.561633,   3.7861645,  8.74162};
  const fp32_t answ[M * N] = {-13.94982,  14.502402, 30.427496,  5.860002,
                              -10.779481, 22.156279, -14.624961, 10.88463,
                              -12.500894, 26.91919,  -19.85408,  -57.413635,
                              -6.296361,  8.810726,  -32.89724,  32.78};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, N * sizeof(fp16_t));
  mfloat16_t ms2 = mlc_m(src2, N * sizeof(fp16_t));
  SET_MBA0_F16F32();
  mfloat32_t md = mfwmul_mm(ms1, ms2);
  SET_MBA0_F32();
  msc_m(md, f32_buffer, N * sizeof(fp32_t));
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFWMUL_MM F16");
}

static void test_mfwmul_hf_mm() {
  enum { M = 4, N = 4 };
  const fp16_t src1[M * N] = {-2.4304533, -5.3403764, -6.519902,  -2.2903361,
                              4.115905,   -4.758715,  9.927346,   1.8063143,
                              9.625583,   5.7489,     -7.1468086, -5.8859353,
                              1.6808083,  3.4394956,  -8.688804,  3.7498767};
  const fp16_t src2[M * N] = {5.739596,   -2.7156143, -4.666864,  -2.5585773,
                              -2.618982,  -4.655937,  -1.4731995, 6.025878,
                              -1.2987155, 4.682494,   2.7780344,  9.754377,
                              -3.7460315, 2.561633,   3.7861645,  8.74162};
  const fp32_t answ[M * N] = {-13.94982,  14.502402, 30.427496,  5.860002,
                              -10.779481, 22.156279, -14.624961, 10.88463,
                              -12.500894, 26.91919,  -19.85408,  -57.413635,
                              -6.296361,  8.810726,  -32.89724,  32.78};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, N * sizeof(fp16_t));
  mfloat16_t ms2 = mlc_m(src2, N * sizeof(fp16_t));
  SET_MBA0_F16F32();
  mfloat32_t md = mfwmul_hf_mm(ms1, ms2);
  SET_MBA0_F32();
  msc_m(md, f32_buffer, N * sizeof(fp32_t));
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFWMUL_HF_MM");
}

static void test_mfwmul_mm_f32() {
  enum { M = 2, N = 2 };
  const fp32_t src1[M * N] = {-4.8688207, -4.295366, -2.4539766, 4.789568};
  const fp32_t src2[M * N] = {8.607289, 0.80398166, -9.637726, 4.9834113};
  const fp64_t answ[M * N] = {-41.90734863, -3.45339537, 23.65075302,
                              23.86838722};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, N * sizeof(fp32_t));
  mfloat32_t ms2 = mlc_m(src2, N * sizeof(fp32_t));
  SET_MBA0_F32F64();
  mfloat64_t md = mfwmul_mm(ms1, ms2);
  SET_MBA0_F64();
  msc_m(md, f64_buffer, N * sizeof(fp64_t));
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFWMUL_MM F32");
}

static void test_mfwmul_f_mm() {
  enum { M = 2, N = 2 };
  const fp32_t src1[M * N] = {-4.8688207, -4.295366, -2.4539766, 4.789568};
  const fp32_t src2[M * N] = {8.607289, 0.80398166, -9.637726, 4.9834113};
  const fp64_t answ[M * N] = {-41.90734863, -3.45339537, 23.65075302,
                              23.86838722};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, N * sizeof(fp32_t));
  mfloat32_t ms2 = mlc_m(src2, N * sizeof(fp32_t));
  SET_MBA0_F32F64();
  mfloat64_t md = mfwmul_f_mm(ms1, ms2);
  SET_MBA0_F64();
  msc_m(md, f64_buffer, N * sizeof(fp64_t));
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFWMUL_F_MM");
}

static void test_mfwmul_mm() {
  test_mfwmul_mm_f16();
  test_mfwmul_hf_mm();
  test_mfwmul_mm_f32();
  test_mfwmul_f_mm();
}

static void test_mfdiv_mm_f16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      -3.283, 0.9106, -8.96,  0.644,  9.734,  4.836,  0.839,   -4.81,
      2.318,  1.684,  -4.484, 8.72,   -6.793, -9.42,  9.2,     3.5,
      -7.684, 8.24,   1.288,  -7.19,  -8.84,  -5.715, -1.925,  5.62,
      5.305,  -9.82,  4.387,  -8.7,   8.92,   -9.39,  -3.465,  -4.203,
      -9.74,  7.113,  -2.102, 9.33,   -5.156, -9.29,  -2.482,  -8.266,
      -2.248, 6.777,  7.67,   9.5,    5.59,   9.7,    9.555,   -6.348,
      1.192,  9.55,   2.303,  8.92,   6.434,  4.87,   5.63,    6.746,
      -5.316, -1.653, 1.987,  -3.846, -7.348, -3.26,  -0.6143, -5.19};
  const fp16_t src2[M * N] = {
      6.758,  -8.125, 6.734,  -9.97,  -2.77,  2.268,  4.06,   -6.06,
      0.759,  -1.083, 1.511,  -4.586, -7.55,  8.695,  1.676,  -2.996,
      -3.064, 4.125,  1.354,  6.156,  -1.626, 3.098,  -6.133, 3.06,
      -7.145, -4.93,  -7.766, 1.334,  -9.56,  6.6,    -2.824, -4.793,
      -8.35,  8.14,   2.238,  9.99,   -7.637, 5.15,   0.1929, 7.824,
      -8.97,  8.195,  -5.62,  5.336,  8.88,   -8.766, -7.62,  3.307,
      -8.07,  5.023,  -3.668, 5.562,  0.2461, -1.933, -1.745, 5.24,
      7.695,  -4.754, -6.4,   7.36,   8.555,  -3.098, -8.43,  -9.02};
  const fp16_t answ[M * N] = {
      -0.4858, -0.11206, -1.331,  -0.06464, -3.516, 2.133,  0.2067, 0.7935,
      3.055,   -1.555,   -2.969,  -1.901,   0.8994, -1.084, 5.492,  -1.168,
      2.508,   1.998,    0.9517,  -1.168,   5.438,  -1.845, 0.314,  1.837,
      -0.7427, 1.992,    -0.565,  -6.523,   -0.933, -1.423, 1.227,  0.877,
      1.167,   0.874,    -0.939,  0.9336,   0.6753, -1.805, -12.87, -1.057,
      0.2507,  0.827,    -1.365,  1.78,     0.6294, -1.107, -1.254, -1.92,
      -0.1477, 1.9,      -0.628,  1.604,    26.14,  -2.52,  -3.225, 1.288,
      -0.691,  0.348,    -0.3105, -0.5225,  -0.859, 1.053,  0.0729, 0.575};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfdiv_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFDIV_MM F16");
}

static void test_mfdiv_hf_mm() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  const fp16_t src1[M * N] = {
      -3.283, 0.9106, -8.96,  0.644,  9.734,  4.836,  0.839,   -4.81,
      2.318,  1.684,  -4.484, 8.72,   -6.793, -9.42,  9.2,     3.5,
      -7.684, 8.24,   1.288,  -7.19,  -8.84,  -5.715, -1.925,  5.62,
      5.305,  -9.82,  4.387,  -8.7,   8.92,   -9.39,  -3.465,  -4.203,
      -9.74,  7.113,  -2.102, 9.33,   -5.156, -9.29,  -2.482,  -8.266,
      -2.248, 6.777,  7.67,   9.5,    5.59,   9.7,    9.555,   -6.348,
      1.192,  9.55,   2.303,  8.92,   6.434,  4.87,   5.63,    6.746,
      -5.316, -1.653, 1.987,  -3.846, -7.348, -3.26,  -0.6143, -5.19};
  const fp16_t src2[M * N] = {
      6.758,  -8.125, 6.734,  -9.97,  -2.77,  2.268,  4.06,   -6.06,
      0.759,  -1.083, 1.511,  -4.586, -7.55,  8.695,  1.676,  -2.996,
      -3.064, 4.125,  1.354,  6.156,  -1.626, 3.098,  -6.133, 3.06,
      -7.145, -4.93,  -7.766, 1.334,  -9.56,  6.6,    -2.824, -4.793,
      -8.35,  8.14,   2.238,  9.99,   -7.637, 5.15,   0.1929, 7.824,
      -8.97,  8.195,  -5.62,  5.336,  8.88,   -8.766, -7.62,  3.307,
      -8.07,  5.023,  -3.668, 5.562,  0.2461, -1.933, -1.745, 5.24,
      7.695,  -4.754, -6.4,   7.36,   8.555,  -3.098, -8.43,  -9.02};
  const fp16_t answ[M * N] = {
      -0.4858, -0.11206, -1.331,  -0.06464, -3.516, 2.133,  0.2067, 0.7935,
      3.055,   -1.555,   -2.969,  -1.901,   0.8994, -1.084, 5.492,  -1.168,
      2.508,   1.998,    0.9517,  -1.168,   5.438,  -1.845, 0.314,  1.837,
      -0.7427, 1.992,    -0.565,  -6.523,   -0.933, -1.423, 1.227,  0.877,
      1.167,   0.874,    -0.939,  0.9336,   0.6753, -1.805, -12.87, -1.057,
      0.2507,  0.827,    -1.365,  1.78,     0.6294, -1.107, -1.254, -1.92,
      -0.1477, 1.9,      -0.628,  1.604,    26.14,  -2.52,  -3.225, 1.288,
      -0.691,  0.348,    -0.3105, -0.5225,  -0.859, 1.053,  0.0729, 0.575};
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  mfloat16_t ms1 = mlc_m(src1, stride);
  mfloat16_t ms2 = mlc_m(src2, stride);
  mfloat16_t md = mfdiv_hf_mm(ms1, ms2);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(answ, f16_buffer, M * N, "MFDIV_HF_MM");
}

static void test_mfdiv_mm_f32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {2.485123,   -3.6321282, 2.639099,   5.8787804,
                              -5.1751127, 3.0087798,  -6.5896087, 6.7653117,
                              6.4718733,  1.5162358,  9.559005,   1.7181824,
                              1.7400156,  0.26429704, 2.0354016,  2.4765193};
  const fp32_t src2[M * N] = {3.8827739, 7.1479073,   -4.9009156, 8.80528,
                              5.7097406, -0.37908036, 1.3435944,  7.1927743,
                              9.008908,  -3.6499598,  -7.4929233, -7.3675547,
                              -6.929369, 9.718,       -2.642453,  8.20179};
  const fp32_t answ[M * N] = {
      0.640038,    -0.5081387,  -0.538491,   0.66764265,
      -0.90636563, -7.93705,    -4.904463,   0.94057053,
      0.718386,    -0.41541165, -1.2757378,  -0.23320933,
      -0.25110736, 0.02719665,  -0.77026975, 0.30194864};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfdiv_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFDIV_MM F32");
}

static void test_mfdiv_f_mm() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  const fp32_t src1[M * N] = {2.485123,   -3.6321282, 2.639099,   5.8787804,
                              -5.1751127, 3.0087798,  -6.5896087, 6.7653117,
                              6.4718733,  1.5162358,  9.559005,   1.7181824,
                              1.7400156,  0.26429704, 2.0354016,  2.4765193};
  const fp32_t src2[M * N] = {3.8827739, 7.1479073,   -4.9009156, 8.80528,
                              5.7097406, -0.37908036, 1.3435944,  7.1927743,
                              9.008908,  -3.6499598,  -7.4929233, -7.3675547,
                              -6.929369, 9.718,       -2.642453,  8.20179};
  const fp32_t answ[M * N] = {
      0.640038,    -0.5081387,  -0.538491,   0.66764265,
      -0.90636563, -7.93705,    -4.904463,   0.94057053,
      0.718386,    -0.41541165, -1.2757378,  -0.23320933,
      -0.25110736, 0.02719665,  -0.77026975, 0.30194864};
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  mfloat32_t ms1 = mlc_m(src1, stride);
  mfloat32_t ms2 = mlc_m(src2, stride);
  mfloat32_t md = mfdiv_f_mm(ms1, ms2);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(answ, f32_buffer, M * N, "MFDIV_F_MM");
}

static void test_mfdiv_mm_f64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {7.62014114, 5.10401528, 8.49089683, 5.70644764};
  const fp64_t src2[M * N] = {0.5392185, 9.86551396, -0.55058072, -8.91901953};
  const fp64_t answ[M * N] = {14.13182443, 0.51735929, -15.42171104,
                              -0.63980661};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfdiv_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFDIV_MM F64");
}

static void test_mfdiv_d_mm() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  const fp64_t src1[M * N] = {7.62014114, 5.10401528, 8.49089683, 5.70644764};
  const fp64_t src2[M * N] = {0.5392185, 9.86551396, -0.55058072, -8.91901953};
  const fp64_t answ[M * N] = {14.13182443, 0.51735929, -15.42171104,
                              -0.63980661};
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  mfloat64_t ms1 = mlc_m(src1, stride);
  mfloat64_t ms2 = mlc_m(src2, stride);
  mfloat64_t md = mfdiv_d_mm(ms1, ms2);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(answ, f64_buffer, M * N, "MFDIV_D_MM");
}

static void test_mfdiv_mm() {
  test_mfdiv_mm_f16();
  test_mfdiv_hf_mm();
  test_mfdiv_mm_f32();
  test_mfdiv_f_mm();
  test_mfdiv_mm_f64();
  test_mfdiv_d_mm();
}

static void test_mfsqrt_m_f16() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  const fp16_t src[M * N] = {
      5.766,  9.87,   1.722,  3.35,  1.747, 5.906, 7.176, 9.1,   2.572, 7.195,
      5.27,   0.6455, 0.4463, 5.574, 9.78,  9.36,  4.797, 4.64,  5.31,  4.105,
      1.65,   7.484,  5.168,  3.424, 6.973, 9.055, 7.668, 1.806, 3.201, 9.805,
      0.8223, 8.984,  0.702,  1.948, 8.96,  6.188, 5.31,  5.76,  1.063, 5.45,
      2.06,   4.426,  8.664,  3.389, 4.645, 5.48,  4.215, 7.7,   8.695, 8.91,
      0.7324, 8.98,   7.906,  4.195, 6.83,  5.824, 3.152, 7.285, 6.05,  1.025,
      7.844,  7.086,  5.156,  6.246};
  const fp16_t ans[M * N] = {
      2.4,    3.14,  1.3125, 1.83,   1.321, 2.43,  2.68,  3.018, 1.604, 2.682,
      2.295,  0.803, 0.668,  2.361,  3.127, 3.059, 2.19,  2.154, 2.305, 2.025,
      1.285,  2.736, 2.273,  1.851,  2.64,  3.01,  2.77,  1.344, 1.789, 3.13,
      0.9067, 2.998, 0.838,  1.3955, 2.994, 2.488, 2.305, 2.4,   1.031, 2.334,
      1.436,  2.104, 2.943,  1.841,  2.154, 2.342, 2.053, 2.775, 2.95,  2.984,
      0.856,  2.996, 2.812,  2.049,  2.613, 2.414, 1.775, 2.7,   2.459, 1.013,
      2.8,    2.662, 2.271,  2.5};
  mfloat16_t ms = mlc_m(src, stride);
  mfloat16_t md = mfsqrt_m(ms);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(ans, f16_buffer, M * N, "MFSQRT_M F16");
}

static void test_mfsqrt_hf_m() {
  enum { M = 8, N = 8 };
  const size_t stride = N * sizeof(fp16_t);
  SET_MBA0_F16();
  msettilem(M);
  msettilen(N);
  const fp16_t src[M * N] = {
      5.766,  9.87,   1.722,  3.35,  1.747, 5.906, 7.176, 9.1,   2.572, 7.195,
      5.27,   0.6455, 0.4463, 5.574, 9.78,  9.36,  4.797, 4.64,  5.31,  4.105,
      1.65,   7.484,  5.168,  3.424, 6.973, 9.055, 7.668, 1.806, 3.201, 9.805,
      0.8223, 8.984,  0.702,  1.948, 8.96,  6.188, 5.31,  5.76,  1.063, 5.45,
      2.06,   4.426,  8.664,  3.389, 4.645, 5.48,  4.215, 7.7,   8.695, 8.91,
      0.7324, 8.98,   7.906,  4.195, 6.83,  5.824, 3.152, 7.285, 6.05,  1.025,
      7.844,  7.086,  5.156,  6.246};
  const fp16_t ans[M * N] = {
      2.4,    3.14,  1.3125, 1.83,   1.321, 2.43,  2.68,  3.018, 1.604, 2.682,
      2.295,  0.803, 0.668,  2.361,  3.127, 3.059, 2.19,  2.154, 2.305, 2.025,
      1.285,  2.736, 2.273,  1.851,  2.64,  3.01,  2.77,  1.344, 1.789, 3.13,
      0.9067, 2.998, 0.838,  1.3955, 2.994, 2.488, 2.305, 2.4,   1.031, 2.334,
      1.436,  2.104, 2.943,  1.841,  2.154, 2.342, 2.053, 2.775, 2.95,  2.984,
      0.856,  2.996, 2.812,  2.049,  2.613, 2.414, 1.775, 2.7,   2.459, 1.013,
      2.8,    2.662, 2.271,  2.5};
  mfloat16_t ms = mlc_m(src, stride);
  mfloat16_t md = mfsqrt_hf_m(ms);
  msc_m(md, f16_buffer, stride);
  EXCEPT_F16_ARRAY_LAX_EQ(ans, f16_buffer, M * N, "MFSQRT_HF_M");
}

static void test_mfsqrt_m_f32() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  const fp32_t src[M * N] = {80.85917,  18.60444, 73.70842,  55.199314,
                             87.71046,  95.24154, 21.72718,  0.608819,
                             92.78908,  36.9761,  50.479355, 29.702042,
                             28.003447, 38.91682, 23.002245, 93.95415};
  const fp32_t ans[M * N] = {8.992172, 4.3132863, 8.585361,  7.429624,
                             9.365386, 9.759177,  4.6612425, 0.78026855,
                             9.632709, 6.0807977, 7.1048822, 5.449958,
                             5.291828, 6.2383347, 4.796066,  9.692995};
  mfloat32_t ms = mlc_m(src, stride);
  mfloat32_t md = mfsqrt_m(ms);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(ans, f32_buffer, M * N, "MFSQRT_M F32");
}

static void test_mfsqrt_f_m() {
  enum { M = 4, N = 4 };
  const size_t stride = N * sizeof(fp32_t);
  SET_MBA0_F32();
  msettilem(M);
  msettilen(N);
  const fp32_t src[M * N] = {80.85917,  18.60444, 73.70842,  55.199314,
                             87.71046,  95.24154, 21.72718,  0.608819,
                             92.78908,  36.9761,  50.479355, 29.702042,
                             28.003447, 38.91682, 23.002245, 93.95415};
  const fp32_t ans[M * N] = {8.992172, 4.3132863, 8.585361,  7.429624,
                             9.365386, 9.759177,  4.6612425, 0.78026855,
                             9.632709, 6.0807977, 7.1048822, 5.449958,
                             5.291828, 6.2383347, 4.796066,  9.692995};
  mfloat32_t ms = mlc_m(src, stride);
  mfloat32_t md = mfsqrt_f_m(ms);
  msc_m(md, f32_buffer, stride);
  EXCEPT_F32_ARRAY_LAX_EQ(ans, f32_buffer, M * N, "MFSQRT_F_M");
}

static void test_mfsqrt_m_f64() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  const fp64_t src[M * N] = {4.43144271, 6.36103397, 8.73636724, 2.27838726};
  const fp64_t ans[M * N] = {2.10509922, 2.52210903, 2.95573464, 1.50943276};
  mfloat64_t ms = mlc_m(src, stride);
  mfloat64_t md = mfsqrt_m(ms);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(ans, f64_buffer, M * N, "MFSQRT_M F64");
}

static void test_mfsqrt_d_m() {
  enum { M = 2, N = 2 };
  const size_t stride = N * sizeof(fp64_t);
  SET_MBA0_F64();
  msettilem(M);
  msettilen(N);
  const fp64_t src[M * N] = {4.43144271, 6.36103397, 8.73636724, 2.27838726};
  const fp64_t ans[M * N] = {2.10509922, 2.52210903, 2.95573464, 1.50943276};
  mfloat64_t ms = mlc_m(src, stride);
  mfloat64_t md = mfsqrt_d_m(ms);
  msc_m(md, f64_buffer, stride);
  EXCEPT_F64_ARRAY_LAX_EQ(ans, f64_buffer, M * N, "MFSQRT_D_M");
}

static void test_msqrt_m() {
  test_mfsqrt_m_f16();
  test_mfsqrt_hf_m();
  test_mfsqrt_m_f32();
  test_mfsqrt_f_m();
  test_mfsqrt_m_f64();
  test_mfsqrt_d_m();
}

static void test_eletwise() {
  test_maddu_mm();
  test_msaddu_mm();
  test_mwaddu_mm();
  test_madd_mm();
  test_msadd_mm();
  test_mwadd_mm();
  test_msubu_mm();
  test_mssubu_mm();
  test_msub_mm();
  test_mssub_mm();
  test_mwsub_mm();
  test_mmin_mm();
  test_mminu_mm();
  test_mmaxu_mm();
  test_mmax_mm();
  test_mand_mm();
  test_mor_mm();
  test_mxor_mm();
  test_msll_mm();
  test_msrl_mm();
  test_msra_mm();
  test_mmul_mm();
  test_mmulh_mm();
  test_mmulhu_mm();
  test_mmulhsu_mm();
  test_msmul_mm();
  test_msmulu_mm();
  test_msmulsu_mm();
  test_mwmul_mm();
  test_mwmulsu_mm();
  test_mfadd_mm();
  test_mfwadd_mm();
  test_mfsub_mm();
  test_mfwsub_mm();
  test_mfmin_mm();
  test_mfmax_mm();
  test_mfmul_mm();
  test_mfwmul_mm();
  test_mfdiv_mm();
  test_msqrt_m();
}

#endif  // !MATRIX_TESTS_ISA_ELETWISE_H_